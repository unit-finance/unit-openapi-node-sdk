/* tslint:disable */
/* eslint-disable */
/**
 * Unit OpenAPI specifications
 * An OpenAPI specifications for unit-sdk clients
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'type'?: AccountTypeEnum;
}

export const AccountTypeEnum = {
    DepositAccount: 'depositAccount',
    CreditAccount: 'creditAccount'
} as const;

export type AccountTypeEnum = typeof AccountTypeEnum[keyof typeof AccountTypeEnum];

/**
 * 
 * @export
 * @interface AccountEndOfDay
 */
export interface AccountEndOfDay {
    /**
     * 
     * @type {string}
     * @memberof AccountEndOfDay
     */
    'type': AccountEndOfDayTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AccountEndOfDay
     */
    'id': string;
    /**
     * 
     * @type {Attributes}
     * @memberof AccountEndOfDay
     */
    'attributes': Attributes;
    /**
     * 
     * @type {AccountEndOfDayRelationships}
     * @memberof AccountEndOfDay
     */
    'relationships': AccountEndOfDayRelationships;
}

export const AccountEndOfDayTypeEnum = {
    AccountEndOfDay: 'accountEndOfDay'
} as const;

export type AccountEndOfDayTypeEnum = typeof AccountEndOfDayTypeEnum[keyof typeof AccountEndOfDayTypeEnum];

/**
 * 
 * @export
 * @interface AccountEndOfDayRelationships
 */
export interface AccountEndOfDayRelationships {
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof AccountEndOfDayRelationships
     */
    'customer': CustomerRelationship;
    /**
     * 
     * @type {AccountRelationship}
     * @memberof AccountEndOfDayRelationships
     */
    'account': AccountRelationship;
}
/**
 * 
 * @export
 * @interface AccountLowBalanceClosureTransaction
 */
export interface AccountLowBalanceClosureTransaction extends Transaction {
    /**
     * 
     * @type {AccountLowBalanceClosureTransactionAllOfAttributes}
     * @memberof AccountLowBalanceClosureTransaction
     */
    'attributes': AccountLowBalanceClosureTransactionAllOfAttributes;
    /**
     * 
     * @type {AccountLowBalanceClosureTransactionRelationships}
     * @memberof AccountLowBalanceClosureTransaction
     */
    'relationships': AccountLowBalanceClosureTransactionRelationships;
}


/**
 * 
 * @export
 * @interface AccountLowBalanceClosureTransactionAllOfAttributes
 */
export interface AccountLowBalanceClosureTransactionAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof AccountLowBalanceClosureTransactionAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof AccountLowBalanceClosureTransactionAllOfAttributes
     */
    'direction'?: AccountLowBalanceClosureTransactionAllOfAttributesDirectionEnum;
    /**
     * 
     * @type {number}
     * @memberof AccountLowBalanceClosureTransactionAllOfAttributes
     */
    'amount': number;
    /**
     * 
     * @type {number}
     * @memberof AccountLowBalanceClosureTransactionAllOfAttributes
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof AccountLowBalanceClosureTransactionAllOfAttributes
     */
    'summary': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AccountLowBalanceClosureTransactionAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
}

export const AccountLowBalanceClosureTransactionAllOfAttributesDirectionEnum = {
    Credit: 'Credit',
    Debit: 'Debit'
} as const;

export type AccountLowBalanceClosureTransactionAllOfAttributesDirectionEnum = typeof AccountLowBalanceClosureTransactionAllOfAttributesDirectionEnum[keyof typeof AccountLowBalanceClosureTransactionAllOfAttributesDirectionEnum];

/**
 * 
 * @export
 * @interface AccountLowBalanceClosureTransactionRelationships
 */
export interface AccountLowBalanceClosureTransactionRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof AccountLowBalanceClosureTransactionRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof AccountLowBalanceClosureTransactionRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof AccountLowBalanceClosureTransactionRelationships
     */
    'customers'?: CustomersRelationship;
    /**
     * 
     * @type {ReceiverAccountRelationship}
     * @memberof AccountLowBalanceClosureTransactionRelationships
     */
    'receiverAccount': ReceiverAccountRelationship;
}
/**
 * 
 * @export
 * @interface AccountRelationship
 */
export interface AccountRelationship {
    /**
     * 
     * @type {AccountRelationshipData}
     * @memberof AccountRelationship
     */
    'data': AccountRelationshipData;
}
/**
 * 
 * @export
 * @interface AccountRelationshipData
 */
export interface AccountRelationshipData {
    /**
     * 
     * @type {string}
     * @memberof AccountRelationshipData
     */
    'type': AccountRelationshipDataTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AccountRelationshipData
     */
    'id': string;
}

export const AccountRelationshipDataTypeEnum = {
    Account: 'account',
    DepositAccount: 'depositAccount',
    CreditAccount: 'creditAccount',
    BatchAccount: 'batchAccount'
} as const;

export type AccountRelationshipDataTypeEnum = typeof AccountRelationshipDataTypeEnum[keyof typeof AccountRelationshipDataTypeEnum];

/**
 * 
 * @export
 * @interface AchPayment
 */
export interface AchPayment extends Payment {
    /**
     * 
     * @type {AchPaymentAllOfAttributes}
     * @memberof AchPayment
     */
    'attributes': AchPaymentAllOfAttributes;
    /**
     * 
     * @type {AchPaymentRelationships}
     * @memberof AchPayment
     */
    'relationships': AchPaymentRelationships;
}


/**
 * 
 * @export
 * @interface AchPaymentAllOfAttributes
 */
export interface AchPaymentAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof AchPaymentAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {number}
     * @memberof AchPaymentAllOfAttributes
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof AchPaymentAllOfAttributes
     */
    'direction': AchPaymentAllOfAttributesDirectionEnum;
    /**
     * 
     * @type {string}
     * @memberof AchPaymentAllOfAttributes
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof AchPaymentAllOfAttributes
     */
    'addenda'?: string;
    /**
     * 
     * @type {PaymentCounterparty}
     * @memberof AchPaymentAllOfAttributes
     */
    'counterparty'?: PaymentCounterparty;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AchPaymentAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof AchPaymentAllOfAttributes
     */
    'status': AchPaymentAllOfAttributesStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof AchPaymentAllOfAttributes
     */
    'settlementDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof AchPaymentAllOfAttributes
     */
    'reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof AchPaymentAllOfAttributes
     */
    'expectedCompletionDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof AchPaymentAllOfAttributes
     */
    'secCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof AchPaymentAllOfAttributes
     */
    'traceNumber'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AchPaymentAllOfAttributes
     */
    'sameDay'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AchPaymentAllOfAttributes
     */
    'counterpartyVerificationMethod'?: string;
    /**
     * 
     * @type {number}
     * @memberof AchPaymentAllOfAttributes
     */
    'clearingDaysOverride'?: number;
}

export const AchPaymentAllOfAttributesDirectionEnum = {
    Credit: 'Credit',
    Debit: 'Debit'
} as const;

export type AchPaymentAllOfAttributesDirectionEnum = typeof AchPaymentAllOfAttributesDirectionEnum[keyof typeof AchPaymentAllOfAttributesDirectionEnum];
export const AchPaymentAllOfAttributesStatusEnum = {
    Pending: 'Pending',
    Rejected: 'Rejected',
    Clearing: 'Clearing',
    Sent: 'Sent',
    Canceled: 'Canceled',
    Returned: 'Returned'
} as const;

export type AchPaymentAllOfAttributesStatusEnum = typeof AchPaymentAllOfAttributesStatusEnum[keyof typeof AchPaymentAllOfAttributesStatusEnum];

/**
 * 
 * @export
 * @interface AchPaymentRelationships
 */
export interface AchPaymentRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof AchPaymentRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof AchPaymentRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof AchPaymentRelationships
     */
    'customers'?: CustomersRelationship;
    /**
     * 
     * @type {CounterpartyRelationship}
     * @memberof AchPaymentRelationships
     */
    'counterparty': CounterpartyRelationship;
    /**
     * 
     * @type {TransactionRelationship}
     * @memberof AchPaymentRelationships
     */
    'transaction': TransactionRelationship;
    /**
     * 
     * @type {RecurringPaymentRelationship}
     * @memberof AchPaymentRelationships
     */
    'recurringPayment'?: RecurringPaymentRelationship;
}
/**
 * 
 * @export
 * @interface AchRepayment
 */
export interface AchRepayment extends Repayment {
    /**
     * 
     * @type {AchRepaymentAllOfAttributes}
     * @memberof AchRepayment
     */
    'attributes': AchRepaymentAllOfAttributes;
    /**
     * 
     * @type {AchRepaymentRelationships}
     * @memberof AchRepayment
     */
    'relationships': AchRepaymentRelationships;
}


/**
 * 
 * @export
 * @interface AchRepaymentAllOfAttributes
 */
export interface AchRepaymentAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof AchRepaymentAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof AchRepaymentAllOfAttributes
     */
    'updatedAt': string;
    /**
     * 
     * @type {number}
     * @memberof AchRepaymentAllOfAttributes
     */
    'amount': number;
    /**
     * 
     * @type {AchRepaymentStatus}
     * @memberof AchRepaymentAllOfAttributes
     */
    'status': AchRepaymentStatus;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AchRepaymentAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
}


/**
 * 
 * @export
 * @interface AchRepaymentRelationships
 */
export interface AchRepaymentRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof AchRepaymentRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CreditAccountRelationship}
     * @memberof AchRepaymentRelationships
     */
    'creditAccount': CreditAccountRelationship;
    /**
     * 
     * @type {OrgRelationship}
     * @memberof AchRepaymentRelationships
     */
    'org': OrgRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof AchRepaymentRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CounterpartyRelationship}
     * @memberof AchRepaymentRelationships
     */
    'counterparty': CounterpartyRelationship;
    /**
     * 
     * @type {PaymentRelationship}
     * @memberof AchRepaymentRelationships
     */
    'payment': PaymentRelationship;
    /**
     * 
     * @type {RecurringRepaymentRelationship}
     * @memberof AchRepaymentRelationships
     */
    'recurringRepayment'?: RecurringRepaymentRelationship;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AchRepaymentStatus = {
    Pending: 'Pending',
    PendingReview: 'PendingReview',
    Clearing: 'Clearing',
    Returned: 'Returned',
    Sent: 'Sent',
    Rejected: 'Rejected',
    Canceled: 'Canceled'
} as const;

export type AchRepaymentStatus = typeof AchRepaymentStatus[keyof typeof AchRepaymentStatus];


/**
 * 
 * @export
 * @interface AchStopPayment
 */
export interface AchStopPayment {
    /**
     * 
     * @type {AchStopPaymentAttributes}
     * @memberof AchStopPayment
     */
    'attributes'?: AchStopPaymentAttributes;
    /**
     * 
     * @type {AchStopPaymentRelationships}
     * @memberof AchStopPayment
     */
    'relationships'?: AchStopPaymentRelationships;
}
/**
 * 
 * @export
 * @interface AchStopPaymentAttributes
 */
export interface AchStopPaymentAttributes {
    /**
     * 
     * @type {string}
     * @memberof AchStopPaymentAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof AchStopPaymentAttributes
     */
    'updatedAt': string;
    /**
     * 
     * @type {number}
     * @memberof AchStopPaymentAttributes
     */
    'minAmount'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof AchStopPaymentAttributes
     */
    'originatorName'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AchStopPaymentAttributes
     */
    'direction': string;
    /**
     * 
     * @type {string}
     * @memberof AchStopPaymentAttributes
     */
    'expiration': string;
    /**
     * 
     * @type {boolean}
     * @memberof AchStopPaymentAttributes
     */
    'isMultiUse': boolean;
    /**
     * 
     * @type {string}
     * @memberof AchStopPaymentAttributes
     */
    'description': string;
    /**
     * 
     * @type {AchStopPaymentDisableReason}
     * @memberof AchStopPaymentAttributes
     */
    'disableReason'?: AchStopPaymentDisableReason;
    /**
     * 
     * @type {string}
     * @memberof AchStopPaymentAttributes
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AchStopPaymentAttributes
     */
    'tags': { [key: string]: string; };
}


/**
 * 
 * @export
 * @enum {string}
 */

export const AchStopPaymentDisableReason = {
    Expired: 'Expired',
    Requested: 'Requested',
    PaymentStopped: 'PaymentStopped'
} as const;

export type AchStopPaymentDisableReason = typeof AchStopPaymentDisableReason[keyof typeof AchStopPaymentDisableReason];


/**
 * 
 * @export
 * @interface AchStopPaymentRelationships
 */
export interface AchStopPaymentRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof AchStopPaymentRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof AchStopPaymentRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof AchStopPaymentRelationships
     */
    'customers'?: CustomersRelationship;
}
/**
 * 
 * @export
 * @interface AddAuthorizedUsersRequest
 */
export interface AddAuthorizedUsersRequest {
    /**
     * 
     * @type {AddAuthorizedUsersRequestData}
     * @memberof AddAuthorizedUsersRequest
     */
    'data'?: AddAuthorizedUsersRequestData;
}
/**
 * 
 * @export
 * @interface AddAuthorizedUsersRequestData
 */
export interface AddAuthorizedUsersRequestData {
    /**
     * 
     * @type {string}
     * @memberof AddAuthorizedUsersRequestData
     */
    'type'?: AddAuthorizedUsersRequestDataTypeEnum;
    /**
     * 
     * @type {AddAuthorizedUsersRequestDataAttributes}
     * @memberof AddAuthorizedUsersRequestData
     */
    'attributes'?: AddAuthorizedUsersRequestDataAttributes;
}

export const AddAuthorizedUsersRequestDataTypeEnum = {
    AddAuthorizedUsers: 'addAuthorizedUsers'
} as const;

export type AddAuthorizedUsersRequestDataTypeEnum = typeof AddAuthorizedUsersRequestDataTypeEnum[keyof typeof AddAuthorizedUsersRequestDataTypeEnum];

/**
 * 
 * @export
 * @interface AddAuthorizedUsersRequestDataAttributes
 */
export interface AddAuthorizedUsersRequestDataAttributes {
    /**
     * 
     * @type {Array<AuthorizedUser>}
     * @memberof AddAuthorizedUsersRequestDataAttributes
     */
    'authorizedUsers'?: Array<AuthorizedUser>;
}
/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'street': string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'street2'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'postalCode': string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'country': string;
}
/**
 * 
 * @export
 * @interface AdjustmentTransaction
 */
export interface AdjustmentTransaction extends Transaction {
    /**
     * 
     * @type {AdjustmentTransactionAllOfAttributes}
     * @memberof AdjustmentTransaction
     */
    'attributes': AdjustmentTransactionAllOfAttributes;
    /**
     * 
     * @type {AdjustmentTransactionRelationships}
     * @memberof AdjustmentTransaction
     */
    'relationships': AdjustmentTransactionRelationships;
}


/**
 * 
 * @export
 * @interface AdjustmentTransactionAllOfAttributes
 */
export interface AdjustmentTransactionAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof AdjustmentTransactionAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof AdjustmentTransactionAllOfAttributes
     */
    'direction': AdjustmentTransactionAllOfAttributesDirectionEnum;
    /**
     * 
     * @type {number}
     * @memberof AdjustmentTransactionAllOfAttributes
     */
    'amount': number;
    /**
     * 
     * @type {number}
     * @memberof AdjustmentTransactionAllOfAttributes
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof AdjustmentTransactionAllOfAttributes
     */
    'summary': string;
    /**
     * 
     * @type {string}
     * @memberof AdjustmentTransactionAllOfAttributes
     */
    'description'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AdjustmentTransactionAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
}

export const AdjustmentTransactionAllOfAttributesDirectionEnum = {
    Credit: 'Credit',
    Debit: 'Debit'
} as const;

export type AdjustmentTransactionAllOfAttributesDirectionEnum = typeof AdjustmentTransactionAllOfAttributesDirectionEnum[keyof typeof AdjustmentTransactionAllOfAttributesDirectionEnum];

/**
 * 
 * @export
 * @interface AdjustmentTransactionRelationships
 */
export interface AdjustmentTransactionRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof AdjustmentTransactionRelationships
     */
    'account': AccountRelationship;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AnnualIncome = {
    UpTo10k: 'UpTo10k',
    Between10kAnd25k: 'Between10kAnd25k',
    Between25kAnd50k: 'Between25kAnd50k',
    Between50kAnd100k: 'Between50kAnd100k',
    Between100kAnd250k: 'Between100kAnd250k',
    Over250k: 'Over250k'
} as const;

export type AnnualIncome = typeof AnnualIncome[keyof typeof AnnualIncome];


/**
 * 
 * @export
 * @interface ApiToken
 */
export interface ApiToken {
    /**
     * 
     * @type {string}
     * @memberof ApiToken
     */
    'type'?: ApiTokenTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiToken
     */
    'id'?: string;
    /**
     * 
     * @type {ApiTokenAttributes}
     * @memberof ApiToken
     */
    'attributes'?: ApiTokenAttributes;
}

export const ApiTokenTypeEnum = {
    ApiToken: 'apiToken'
} as const;

export type ApiTokenTypeEnum = typeof ApiTokenTypeEnum[keyof typeof ApiTokenTypeEnum];

/**
 * 
 * @export
 * @interface ApiTokenAttributes
 */
export interface ApiTokenAttributes {
    /**
     * 
     * @type {string}
     * @memberof ApiTokenAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ApiTokenAttributes
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiTokenAttributes
     */
    'expiration'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiTokenAttributes
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiTokenAttributes
     */
    'sourceIp'?: string;
}
/**
 * 
 * @export
 * @interface Application
 */
export interface Application {
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'type'?: ApplicationTypeEnum;
}

export const ApplicationTypeEnum = {
    IndividualApplication: 'individualApplication',
    BusinessApplication: 'businessApplication'
} as const;

export type ApplicationTypeEnum = typeof ApplicationTypeEnum[keyof typeof ApplicationTypeEnum];

/**
 * 
 * @export
 * @interface ApplicationDocument
 */
export interface ApplicationDocument {
    /**
     * 
     * @type {string}
     * @memberof ApplicationDocument
     */
    'type': ApplicationDocumentTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDocument
     */
    'id': string;
    /**
     * 
     * @type {ApplicationDocumentAttributes}
     * @memberof ApplicationDocument
     */
    'attributes': ApplicationDocumentAttributes;
}

export const ApplicationDocumentTypeEnum = {
    Document: 'document'
} as const;

export type ApplicationDocumentTypeEnum = typeof ApplicationDocumentTypeEnum[keyof typeof ApplicationDocumentTypeEnum];

/**
 * 
 * @export
 * @interface ApplicationDocumentAttributes
 */
export interface ApplicationDocumentAttributes {
    /**
     * 
     * @type {string}
     * @memberof ApplicationDocumentAttributes
     */
    'documentType'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDocumentAttributes
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDocumentAttributes
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDocumentAttributes
     */
    'nationality'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDocumentAttributes
     */
    'ssn'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDocumentAttributes
     */
    'passport'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDocumentAttributes
     */
    'matriculaConsular'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDocumentAttributes
     */
    'name'?: string;
    /**
     * 
     * @type {Address}
     * @memberof ApplicationDocumentAttributes
     */
    'address'?: Address;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDocumentAttributes
     */
    'dateOfIncorporation'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDocumentAttributes
     */
    'stateOfIncorporation'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDocumentAttributes
     */
    'dateOfBirth'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDocumentAttributes
     */
    'ein'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDocumentAttributes
     */
    'reasonCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDocumentAttributes
     */
    'reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDocumentAttributes
     */
    'evaluationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDocumentAttributes
     */
    'frontDocumentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDocumentAttributes
     */
    'backDocumentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDocumentAttributes
     */
    'frontDocumentStoreId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDocumentAttributes
     */
    'backDocumentStoreId'?: string;
}
/**
 * 
 * @export
 * @interface ApplicationForm
 */
export interface ApplicationForm {
    /**
     * 
     * @type {string}
     * @memberof ApplicationForm
     */
    'type': ApplicationFormTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ApplicationForm
     */
    'id': string;
    /**
     * 
     * @type {ApplicationFormAttributes}
     * @memberof ApplicationForm
     */
    'attributes': ApplicationFormAttributes;
    /**
     * 
     * @type {ApplicationFormRelationships}
     * @memberof ApplicationForm
     */
    'relationships'?: ApplicationFormRelationships;
}

export const ApplicationFormTypeEnum = {
    ApplicationForm: 'applicationForm'
} as const;

export type ApplicationFormTypeEnum = typeof ApplicationFormTypeEnum[keyof typeof ApplicationFormTypeEnum];

/**
 * 
 * @export
 * @interface ApplicationFormAdditionalDisclosuresInner
 */
export interface ApplicationFormAdditionalDisclosuresInner {
    /**
     * 
     * @type {string}
     * @memberof ApplicationFormAdditionalDisclosuresInner
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFormAdditionalDisclosuresInner
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface ApplicationFormAttributes
 */
export interface ApplicationFormAttributes {
    /**
     * 
     * @type {string}
     * @memberof ApplicationFormAttributes
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFormAttributes
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFormAttributes
     */
    'stage'?: ApplicationFormAttributesStageEnum;
    /**
     * 
     * @type {ApplicationFormPrefill}
     * @memberof ApplicationFormAttributes
     */
    'applicantDetails'?: ApplicationFormPrefill;
    /**
     * 
     * @type {ApplicationFormSettingsOverride}
     * @memberof ApplicationFormAttributes
     */
    'settingsOverride'?: ApplicationFormSettingsOverride;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationFormAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<string>}
     * @memberof ApplicationFormAttributes
     */
    'allowedApplicationTypes'?: Array<ApplicationFormAttributesAllowedApplicationTypesEnum>;
}

export const ApplicationFormAttributesStageEnum = {
    ChooseBusinessOrIndividual: 'ChooseBusinessOrIndividual',
    EnterIndividualInformation: 'EnterIndividualInformation',
    IndividualPhoneVerification: 'IndividualPhoneVerification',
    IndividualApplicationCreated: 'IndividualApplicationCreated',
    EnterBusinessInformation: 'EnterBusinessInformation',
    EnterBusinessAdditionalInformation: 'EnterBusinessAdditionalInformation',
    EnterOfficerInformation: 'EnterOfficerInformation',
    BusinessPhoneVerification: 'BusinessPhoneVerification',
    EnterBeneficialOwnersInformation: 'EnterBeneficialOwnersInformation',
    BusinessApplicationCreated: 'businessApplicationCreated',
    EnterSoleProprietorshipInformation: 'EnterSoleProprietorshipInformation',
    EnterSoleProprietorshipBusinessInformation: 'EnterSoleProprietorshipBusinessInformation',
    SoleProprietorshipPhoneVerification: 'SoleProprietorshipPhoneVerification',
    SoleProprietorshipApplicationCreated: 'SoleProprietorshipApplicationCreated'
} as const;

export type ApplicationFormAttributesStageEnum = typeof ApplicationFormAttributesStageEnum[keyof typeof ApplicationFormAttributesStageEnum];
export const ApplicationFormAttributesAllowedApplicationTypesEnum = {
    Individual: 'Individual',
    Business: 'Business',
    SoleProprietorship: 'SoleProprietorship'
} as const;

export type ApplicationFormAttributesAllowedApplicationTypesEnum = typeof ApplicationFormAttributesAllowedApplicationTypesEnum[keyof typeof ApplicationFormAttributesAllowedApplicationTypesEnum];

/**
 * 
 * @export
 * @interface ApplicationFormPrefill
 */
export interface ApplicationFormPrefill {
    /**
     * 
     * @type {string}
     * @memberof ApplicationFormPrefill
     */
    'applicationType'?: ApplicationFormPrefillApplicationTypeEnum;
    /**
     * 
     * @type {FullName}
     * @memberof ApplicationFormPrefill
     */
    'fullName'?: FullName;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFormPrefill
     */
    'ssn'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFormPrefill
     */
    'passport'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFormPrefill
     */
    'nationality'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFormPrefill
     */
    'dateOfBirth'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFormPrefill
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFormPrefill
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFormPrefill
     */
    'stateOfIncorporation'?: string;
    /**
     * 
     * @type {EntityType}
     * @memberof ApplicationFormPrefill
     */
    'entityType'?: EntityType;
    /**
     * 
     * @type {Contact}
     * @memberof ApplicationFormPrefill
     */
    'contact'?: Contact;
    /**
     * 
     * @type {CreateOfficer}
     * @memberof ApplicationFormPrefill
     */
    'officer'?: CreateOfficer;
    /**
     * 
     * @type {Array<CreateBeneficialOwner>}
     * @memberof ApplicationFormPrefill
     */
    'beneficialOwners'?: Array<CreateBeneficialOwner>;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFormPrefill
     */
    'website'?: string;
    /**
     * 
     * @type {Phone}
     * @memberof ApplicationFormPrefill
     */
    'phone'?: Phone;
    /**
     * 
     * @type {Address}
     * @memberof ApplicationFormPrefill
     */
    'address'?: Address;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFormPrefill
     */
    'dba'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFormPrefill
     */
    'ein'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFormPrefill
     */
    'jwtSubject'?: string | null;
    /**
     * 
     * @type {Industry}
     * @memberof ApplicationFormPrefill
     */
    'industry'?: Industry;
    /**
     * 
     * @type {BusinessVertical}
     * @memberof ApplicationFormPrefill
     */
    'businessVertical'?: BusinessVertical;
    /**
     * 
     * @type {Occupation}
     * @memberof ApplicationFormPrefill
     */
    'occupation'?: Occupation;
}

export const ApplicationFormPrefillApplicationTypeEnum = {
    Individual: 'Individual',
    Business: 'Business',
    SoleProprietorship: 'SoleProprietorship'
} as const;

export type ApplicationFormPrefillApplicationTypeEnum = typeof ApplicationFormPrefillApplicationTypeEnum[keyof typeof ApplicationFormPrefillApplicationTypeEnum];

/**
 * 
 * @export
 * @interface ApplicationFormRelationships
 */
export interface ApplicationFormRelationships {
    /**
     * 
     * @type {ApplicationRelationship}
     * @memberof ApplicationFormRelationships
     */
    'application'?: ApplicationRelationship;
}
/**
 * 
 * @export
 * @interface ApplicationFormSettingsOverride
 */
export interface ApplicationFormSettingsOverride {
    /**
     * 
     * @type {string}
     * @memberof ApplicationFormSettingsOverride
     */
    'redirectUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFormSettingsOverride
     */
    'privacyPolicyUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFormSettingsOverride
     */
    'electronicDisclosuresUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFormSettingsOverride
     */
    'depositTermsUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFormSettingsOverride
     */
    'clientTermsUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFormSettingsOverride
     */
    'cardholderTermsUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFormSettingsOverride
     */
    'cashAdvancedTermsUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFormSettingsOverride
     */
    'debitCardDisclosureUrl'?: string;
    /**
     * 
     * @type {Array<ApplicationFormAdditionalDisclosuresInner>}
     * @memberof ApplicationFormSettingsOverride
     */
    'additionalDisclosures'?: Array<ApplicationFormAdditionalDisclosuresInner>;
}
/**
 * 
 * @export
 * @interface ApplicationRelationship
 */
export interface ApplicationRelationship {
    /**
     * 
     * @type {ApplicationRelationshipData}
     * @memberof ApplicationRelationship
     */
    'data': ApplicationRelationshipData;
}
/**
 * 
 * @export
 * @interface ApplicationRelationshipData
 */
export interface ApplicationRelationshipData {
    /**
     * 
     * @type {string}
     * @memberof ApplicationRelationshipData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationRelationshipData
     */
    'type': ApplicationRelationshipDataTypeEnum;
}

export const ApplicationRelationshipDataTypeEnum = {
    BusinessApplication: 'businessApplication',
    IndividualApplication: 'individualApplication',
    Application: 'application'
} as const;

export type ApplicationRelationshipDataTypeEnum = typeof ApplicationRelationshipDataTypeEnum[keyof typeof ApplicationRelationshipDataTypeEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const ApplicationStatus = {
    AwaitingDocuments: 'AwaitingDocuments',
    PendingReview: 'PendingReview',
    Approved: 'Approved',
    Denied: 'Denied',
    Pending: 'Pending',
    Canceled: 'Canceled'
} as const;

export type ApplicationStatus = typeof ApplicationStatus[keyof typeof ApplicationStatus];


/**
 * 
 * @export
 * @interface ApproveAuthorizationRequest
 */
export interface ApproveAuthorizationRequest {
    /**
     * 
     * @type {ApproveAuthorizationRequest}
     * @memberof ApproveAuthorizationRequest
     */
    'data'?: ApproveAuthorizationRequest;
}
/**
 * 
 * @export
 * @interface ApproveAuthorizationRequestAttributes
 */
export interface ApproveAuthorizationRequestAttributes {
    /**
     * 
     * @type {number}
     * @memberof ApproveAuthorizationRequestAttributes
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApproveAuthorizationRequestAttributes
     */
    'fundingAccount'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApproveAuthorizationRequestAttributes
     */
    'tags'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface ApproveCheckPaymentRequest
 */
export interface ApproveCheckPaymentRequest {
    /**
     * 
     * @type {ApproveCheckPaymentRequestData}
     * @memberof ApproveCheckPaymentRequest
     */
    'data'?: ApproveCheckPaymentRequestData;
}
/**
 * 
 * @export
 * @interface ApproveCheckPaymentRequestData
 */
export interface ApproveCheckPaymentRequestData {
    /**
     * 
     * @type {string}
     * @memberof ApproveCheckPaymentRequestData
     */
    'type'?: ApproveCheckPaymentRequestDataTypeEnum;
}

export const ApproveCheckPaymentRequestDataTypeEnum = {
    AdditionalVerification: 'additionalVerification'
} as const;

export type ApproveCheckPaymentRequestDataTypeEnum = typeof ApproveCheckPaymentRequestDataTypeEnum[keyof typeof ApproveCheckPaymentRequestDataTypeEnum];

/**
 * 
 * @export
 * @interface ArchiveCustomerRequest
 */
export interface ArchiveCustomerRequest {
    /**
     * 
     * @type {ArchiveCustomerRequestData}
     * @memberof ArchiveCustomerRequest
     */
    'data'?: ArchiveCustomerRequestData;
}
/**
 * 
 * @export
 * @interface ArchiveCustomerRequestData
 */
export interface ArchiveCustomerRequestData {
    /**
     * 
     * @type {string}
     * @memberof ArchiveCustomerRequestData
     */
    'type'?: ArchiveCustomerRequestDataTypeEnum;
    /**
     * 
     * @type {ArchiveCustomerRequestDataAttributes}
     * @memberof ArchiveCustomerRequestData
     */
    'attributes'?: ArchiveCustomerRequestDataAttributes;
}

export const ArchiveCustomerRequestDataTypeEnum = {
    ArchiveCustomer: 'archiveCustomer'
} as const;

export type ArchiveCustomerRequestDataTypeEnum = typeof ArchiveCustomerRequestDataTypeEnum[keyof typeof ArchiveCustomerRequestDataTypeEnum];

/**
 * 
 * @export
 * @interface ArchiveCustomerRequestDataAttributes
 */
export interface ArchiveCustomerRequestDataAttributes {
    /**
     * 
     * @type {string}
     * @memberof ArchiveCustomerRequestDataAttributes
     */
    'reason'?: ArchiveCustomerRequestDataAttributesReasonEnum;
}

export const ArchiveCustomerRequestDataAttributesReasonEnum = {
    Inactive: 'Inactive',
    FraudAchActivity: 'FraudACHActivity',
    FraudCardActivity: 'FraudCardActivity',
    FraudCheckActivity: 'FraudCheckActivity',
    FraudApplicationHistory: 'FraudApplicationHistory',
    FraudAccountActivity: 'FraudAccountActivity',
    FraudClientIdentified: 'FraudClientIdentified',
    FraudLinkedToFraudulentCustomer: 'FraudLinkedToFraudulentCustomer'
} as const;

export type ArchiveCustomerRequestDataAttributesReasonEnum = typeof ArchiveCustomerRequestDataAttributesReasonEnum[keyof typeof ArchiveCustomerRequestDataAttributesReasonEnum];

/**
 * 
 * @export
 * @interface Astra
 */
export interface Astra {
    /**
     * 
     * @type {string}
     * @memberof Astra
     */
    'authToken'?: string;
    /**
     * 
     * @type {number}
     * @memberof Astra
     */
    'debitFeePercent': number;
    /**
     * 
     * @type {string}
     * @memberof Astra
     */
    'institutionId': string;
    /**
     * 
     * @type {string}
     * @memberof Astra
     */
    'destinationCardId': string;
    /**
     * 
     * @type {string}
     * @memberof Astra
     */
    'routingNumber': string;
    /**
     * 
     * @type {string}
     * @memberof Astra
     */
    'accountNumber': string;
    /**
     * 
     * @type {string}
     * @memberof Astra
     */
    'accountName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Astra
     */
    'referenceId': string;
}
/**
 * 
 * @export
 * @interface AtmAuthorization
 */
export interface AtmAuthorization extends AuthorizationRequest {
    /**
     * 
     * @type {AtmAuthorizationAllOfAttributes}
     * @memberof AtmAuthorization
     */
    'attributes'?: AtmAuthorizationAllOfAttributes;
    /**
     * 
     * @type {AuthorizationRequestRelationships}
     * @memberof AtmAuthorization
     */
    'relationships': AuthorizationRequestRelationships;
}


/**
 * 
 * @export
 * @interface AtmAuthorizationAllOfAttributes
 */
export interface AtmAuthorizationAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof AtmAuthorizationAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {number}
     * @memberof AtmAuthorizationAllOfAttributes
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof AtmAuthorizationAllOfAttributes
     */
    'status': string;
    /**
     * 
     * @type {boolean}
     * @memberof AtmAuthorizationAllOfAttributes
     */
    'partialApprovalAllowed': boolean;
    /**
     * 
     * @type {number}
     * @memberof AtmAuthorizationAllOfAttributes
     */
    'approvedAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof AtmAuthorizationAllOfAttributes
     */
    'declineReason'?: string;
    /**
     * 
     * @type {string}
     * @memberof AtmAuthorizationAllOfAttributes
     */
    'direction': string;
    /**
     * 
     * @type {string}
     * @memberof AtmAuthorizationAllOfAttributes
     */
    'atmName': string;
    /**
     * 
     * @type {string}
     * @memberof AtmAuthorizationAllOfAttributes
     */
    'atmLocation'?: string;
    /**
     * 
     * @type {number}
     * @memberof AtmAuthorizationAllOfAttributes
     */
    'surcharge': number;
    /**
     * 
     * @type {number}
     * @memberof AtmAuthorizationAllOfAttributes
     */
    'internationalServiceFee'?: number | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AtmAuthorizationAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof AtmAuthorizationAllOfAttributes
     */
    'cardNetwork'?: string;
}
/**
 * 
 * @export
 * @interface AtmLocation
 */
export interface AtmLocation {
    /**
     * 
     * @type {string}
     * @memberof AtmLocation
     */
    'type': AtmLocationTypeEnum;
    /**
     * 
     * @type {AtmLocationAttributes}
     * @memberof AtmLocation
     */
    'attributes': AtmLocationAttributes;
}

export const AtmLocationTypeEnum = {
    AtmLocation: 'atmLocation'
} as const;

export type AtmLocationTypeEnum = typeof AtmLocationTypeEnum[keyof typeof AtmLocationTypeEnum];

/**
 * 
 * @export
 * @interface AtmLocationAttributes
 */
export interface AtmLocationAttributes {
    /**
     * 
     * @type {string}
     * @memberof AtmLocationAttributes
     */
    'network'?: string;
    /**
     * 
     * @type {string}
     * @memberof AtmLocationAttributes
     */
    'locationName'?: string;
    /**
     * 
     * @type {Coordinates}
     * @memberof AtmLocationAttributes
     */
    'coordinates'?: Coordinates;
    /**
     * 
     * @type {Address}
     * @memberof AtmLocationAttributes
     */
    'address'?: Address;
    /**
     * 
     * @type {number}
     * @memberof AtmLocationAttributes
     */
    'distance'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof AtmLocationAttributes
     */
    'surchargeFree'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AtmLocationAttributes
     */
    'acceptDeposits'?: boolean;
}
/**
 * 
 * @export
 * @interface AtmTransaction
 */
export interface AtmTransaction extends Transaction {
    /**
     * 
     * @type {AtmTransactionAllOfAttributes}
     * @memberof AtmTransaction
     */
    'attributes': AtmTransactionAllOfAttributes;
    /**
     * 
     * @type {AtmTransactionRelationship}
     * @memberof AtmTransaction
     */
    'relationships': AtmTransactionRelationship;
}


/**
 * 
 * @export
 * @interface AtmTransactionAllOfAttributes
 */
export interface AtmTransactionAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof AtmTransactionAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof AtmTransactionAllOfAttributes
     */
    'direction': AtmTransactionAllOfAttributesDirectionEnum;
    /**
     * 
     * @type {number}
     * @memberof AtmTransactionAllOfAttributes
     */
    'amount': number;
    /**
     * 
     * @type {number}
     * @memberof AtmTransactionAllOfAttributes
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof AtmTransactionAllOfAttributes
     */
    'summary': string;
    /**
     * 
     * @type {string}
     * @memberof AtmTransactionAllOfAttributes
     */
    'cardLast4Digits': string;
    /**
     * 
     * @type {string}
     * @memberof AtmTransactionAllOfAttributes
     */
    'atmName': string;
    /**
     * 
     * @type {string}
     * @memberof AtmTransactionAllOfAttributes
     */
    'atmLocation'?: string;
    /**
     * 
     * @type {number}
     * @memberof AtmTransactionAllOfAttributes
     */
    'surcharge': number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AtmTransactionAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof AtmTransactionAllOfAttributes
     */
    'networkTransactionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AtmTransactionAllOfAttributes
     */
    'interchange'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AtmTransactionAllOfAttributes
     */
    'internationalServiceFee'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AtmTransactionAllOfAttributes
     */
    'cardNetwork'?: string;
}

export const AtmTransactionAllOfAttributesDirectionEnum = {
    Credit: 'Credit',
    Debit: 'Debit'
} as const;

export type AtmTransactionAllOfAttributesDirectionEnum = typeof AtmTransactionAllOfAttributesDirectionEnum[keyof typeof AtmTransactionAllOfAttributesDirectionEnum];

/**
 * 
 * @export
 * @interface AtmTransactionRelationship
 */
export interface AtmTransactionRelationship {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof AtmTransactionRelationship
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof AtmTransactionRelationship
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof AtmTransactionRelationship
     */
    'customers'?: CustomersRelationship;
    /**
     * 
     * @type {CardRelationship}
     * @memberof AtmTransactionRelationship
     */
    'card': CardRelationship;
}
/**
 * 
 * @export
 * @interface Attributes
 */
export interface Attributes {
    /**
     * 
     * @type {string}
     * @memberof Attributes
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof Attributes
     */
    'balance': number;
    /**
     * 
     * @type {number}
     * @memberof Attributes
     */
    'hold': number;
    /**
     * 
     * @type {number}
     * @memberof Attributes
     */
    'available': number;
    /**
     * 
     * @type {number}
     * @memberof Attributes
     */
    'overdraftLimit'?: number;
}
/**
 * 
 * @export
 * @interface Authorization
 */
export interface Authorization {
    /**
     * 
     * @type {string}
     * @memberof Authorization
     */
    'type': AuthorizationTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Authorization
     */
    'id': string;
    /**
     * 
     * @type {AuthorizationAttributes}
     * @memberof Authorization
     */
    'attributes'?: AuthorizationAttributes;
    /**
     * 
     * @type {AuthorizationRelationships}
     * @memberof Authorization
     */
    'relationships': AuthorizationRelationships;
}

export const AuthorizationTypeEnum = {
    Authorization: 'authorization'
} as const;

export type AuthorizationTypeEnum = typeof AuthorizationTypeEnum[keyof typeof AuthorizationTypeEnum];

/**
 * 
 * @export
 * @interface AuthorizationAttributes
 */
export interface AuthorizationAttributes {
    /**
     * 
     * @type {string}
     * @memberof AuthorizationAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {number}
     * @memberof AuthorizationAttributes
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof AuthorizationAttributes
     */
    'cardLast4Digits': string;
    /**
     * 
     * @type {Merchant}
     * @memberof AuthorizationAttributes
     */
    'merchant': Merchant;
    /**
     * 
     * @type {boolean}
     * @memberof AuthorizationAttributes
     */
    'recurring': boolean;
    /**
     * 
     * @type {string}
     * @memberof AuthorizationAttributes
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof AuthorizationAttributes
     */
    'declineReason'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AuthorizationAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof AuthorizationAttributes
     */
    'paymentMethod'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorizationAttributes
     */
    'digitalWallet'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorizationAttributes
     */
    'summary'?: string;
    /**
     * 
     * @type {CardVerificationData}
     * @memberof AuthorizationAttributes
     */
    'cardVerificationData'?: CardVerificationData;
    /**
     * 
     * @type {string}
     * @memberof AuthorizationAttributes
     */
    'cardNetwork'?: string;
    /**
     * 
     * @type {number}
     * @memberof AuthorizationAttributes
     */
    'cashWithdrawalAmount'?: number;
}
/**
 * 
 * @export
 * @interface AuthorizationRelationship
 */
export interface AuthorizationRelationship {
    /**
     * 
     * @type {Array<AuthorizationRelationshipDataInner>}
     * @memberof AuthorizationRelationship
     */
    'data'?: Array<AuthorizationRelationshipDataInner>;
}
/**
 * 
 * @export
 * @interface AuthorizationRelationshipDataInner
 */
export interface AuthorizationRelationshipDataInner {
    /**
     * 
     * @type {string}
     * @memberof AuthorizationRelationshipDataInner
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorizationRelationshipDataInner
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface AuthorizationRelationships
 */
export interface AuthorizationRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof AuthorizationRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CardRelationship}
     * @memberof AuthorizationRelationships
     */
    'card': CardRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof AuthorizationRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {AuthorizationRequestRelationship}
     * @memberof AuthorizationRelationships
     */
    'authorizationRequest'?: AuthorizationRequestRelationship;
}
/**
 * 
 * @export
 * @interface AuthorizationRequest
 */
export interface AuthorizationRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthorizationRequest
     */
    'type'?: AuthorizationRequestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AuthorizationRequest
     */
    'id'?: string;
}

export const AuthorizationRequestTypeEnum = {
    PurchaseAuthorizationRequest: 'purchaseAuthorizationRequest',
    CardTransactionAuthorizationRequest: 'cardTransactionAuthorizationRequest',
    AtmAuthorizationRequest: 'atmAuthorizationRequest'
} as const;

export type AuthorizationRequestTypeEnum = typeof AuthorizationRequestTypeEnum[keyof typeof AuthorizationRequestTypeEnum];

/**
 * 
 * @export
 * @interface AuthorizationRequestRelationship
 */
export interface AuthorizationRequestRelationship {
    /**
     * 
     * @type {Array<AuthorizationRequestRelationshipDataInner>}
     * @memberof AuthorizationRequestRelationship
     */
    'data'?: Array<AuthorizationRequestRelationshipDataInner>;
}
/**
 * 
 * @export
 * @interface AuthorizationRequestRelationshipDataInner
 */
export interface AuthorizationRequestRelationshipDataInner {
    /**
     * 
     * @type {string}
     * @memberof AuthorizationRequestRelationshipDataInner
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorizationRequestRelationshipDataInner
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface AuthorizationRequestRelationships
 */
export interface AuthorizationRequestRelationships {
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof AuthorizationRequestRelationships
     */
    'customer': CustomerRelationship;
    /**
     * 
     * @type {AccountRelationship}
     * @memberof AuthorizationRequestRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {FundingAccountRelationship}
     * @memberof AuthorizationRequestRelationships
     */
    'fundingAccount'?: FundingAccountRelationship;
    /**
     * 
     * @type {CardRelationship}
     * @memberof AuthorizationRequestRelationships
     */
    'card': CardRelationship;
}
/**
 * 
 * @export
 * @interface AuthorizedUser
 */
export interface AuthorizedUser {
    /**
     * 
     * @type {FullName}
     * @memberof AuthorizedUser
     */
    'fullName': FullName;
    /**
     * 
     * @type {string}
     * @memberof AuthorizedUser
     */
    'email': string;
    /**
     * 
     * @type {Phone}
     * @memberof AuthorizedUser
     */
    'phone': Phone;
    /**
     * 
     * @type {string}
     * @memberof AuthorizedUser
     */
    'jwtSubject'?: string | null;
}
/**
 * 
 * @export
 * @interface BankRepaymentTransaction
 */
export interface BankRepaymentTransaction extends Transaction {
    /**
     * 
     * @type {BankRepaymentTransactionAllOfAttributes}
     * @memberof BankRepaymentTransaction
     */
    'attributes': BankRepaymentTransactionAllOfAttributes;
    /**
     * 
     * @type {BankRepaymentTransactionRelationships}
     * @memberof BankRepaymentTransaction
     */
    'relationships': BankRepaymentTransactionRelationships;
}


/**
 * 
 * @export
 * @interface BankRepaymentTransactionAllOfAttributes
 */
export interface BankRepaymentTransactionAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof BankRepaymentTransactionAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BankRepaymentTransactionAllOfAttributes
     */
    'direction': BankRepaymentTransactionAllOfAttributesDirectionEnum;
    /**
     * 
     * @type {number}
     * @memberof BankRepaymentTransactionAllOfAttributes
     */
    'amount': number;
    /**
     * 
     * @type {number}
     * @memberof BankRepaymentTransactionAllOfAttributes
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof BankRepaymentTransactionAllOfAttributes
     */
    'summary': string;
    /**
     * 
     * @type {string}
     * @memberof BankRepaymentTransactionAllOfAttributes
     */
    'paidForDate': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof BankRepaymentTransactionAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
}

export const BankRepaymentTransactionAllOfAttributesDirectionEnum = {
    Credit: 'Credit',
    Debit: 'Debit'
} as const;

export type BankRepaymentTransactionAllOfAttributesDirectionEnum = typeof BankRepaymentTransactionAllOfAttributesDirectionEnum[keyof typeof BankRepaymentTransactionAllOfAttributesDirectionEnum];

/**
 * 
 * @export
 * @interface BankRepaymentTransactionRelationships
 */
export interface BankRepaymentTransactionRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof BankRepaymentTransactionRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof BankRepaymentTransactionRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof BankRepaymentTransactionRelationships
     */
    'customers'?: CustomersRelationship;
    /**
     * 
     * @type {OrgRelationship}
     * @memberof BankRepaymentTransactionRelationships
     */
    'org'?: OrgRelationship;
    /**
     * 
     * @type {ReceivingAccountRelationship}
     * @memberof BankRepaymentTransactionRelationships
     */
    'receivingAccount': ReceivingAccountRelationship;
}
/**
 * 
 * @export
 * @interface BaseMonthlySchedule
 */
export interface BaseMonthlySchedule {
    /**
     * 
     * @type {string}
     * @memberof BaseMonthlySchedule
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseMonthlySchedule
     */
    'endTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof BaseMonthlySchedule
     */
    'dayOfMonth'?: number;
    /**
     * 
     * @type {string}
     * @memberof BaseMonthlySchedule
     */
    'dayOfWeek'?: BaseMonthlyScheduleDayOfWeekEnum;
    /**
     * 
     * @type {number}
     * @memberof BaseMonthlySchedule
     */
    'totalNumberOfPayments'?: number;
}

export const BaseMonthlyScheduleDayOfWeekEnum = {
    Sunday: 'Sunday',
    Monday: 'Monday',
    Tuesday: 'Tuesday',
    Wednesday: 'Wednesday',
    Thursday: 'Thursday',
    Friday: 'Friday',
    Saturday: 'Saturday'
} as const;

export type BaseMonthlyScheduleDayOfWeekEnum = typeof BaseMonthlyScheduleDayOfWeekEnum[keyof typeof BaseMonthlyScheduleDayOfWeekEnum];

/**
 * 
 * @export
 * @interface BaseWeeklySchedule
 */
export interface BaseWeeklySchedule {
    /**
     * 
     * @type {string}
     * @memberof BaseWeeklySchedule
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseWeeklySchedule
     */
    'endTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof BaseWeeklySchedule
     */
    'dayOfMonth'?: number;
    /**
     * 
     * @type {string}
     * @memberof BaseWeeklySchedule
     */
    'nextScheduledAction': string;
    /**
     * 
     * @type {number}
     * @memberof BaseWeeklySchedule
     */
    'totalNumberOfPayments'?: number;
}
/**
 * 
 * @export
 * @interface BeneficialOwner
 */
export interface BeneficialOwner {
    /**
     * 
     * @type {string}
     * @memberof BeneficialOwner
     */
    'status'?: string;
    /**
     * 
     * @type {FullName}
     * @memberof BeneficialOwner
     */
    'fullName'?: FullName;
    /**
     * 
     * @type {string}
     * @memberof BeneficialOwner
     */
    'email'?: string;
    /**
     * 
     * @type {Phone}
     * @memberof BeneficialOwner
     */
    'phone'?: Phone;
    /**
     * 
     * @type {string}
     * @memberof BeneficialOwner
     */
    'ssn'?: string;
    /**
     * 
     * @type {string}
     * @memberof BeneficialOwner
     */
    'passport'?: string;
    /**
     * 
     * @type {string}
     * @memberof BeneficialOwner
     */
    'nationality'?: string;
    /**
     * 
     * @type {string}
     * @memberof BeneficialOwner
     */
    'matriculaConsular'?: string;
    /**
     * 
     * @type {Address}
     * @memberof BeneficialOwner
     */
    'address'?: Address;
    /**
     * 
     * @type {string}
     * @memberof BeneficialOwner
     */
    'dateOfBirth'?: string;
    /**
     * 
     * @type {string}
     * @memberof BeneficialOwner
     */
    'evaluationId'?: string;
    /**
     * 
     * @type {number}
     * @memberof BeneficialOwner
     */
    'percentage'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof BeneficialOwner
     */
    'evaluationFlags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BeneficialOwner
     */
    'maskedSSN'?: string;
    /**
     * 
     * @type {string}
     * @memberof BeneficialOwner
     */
    'maskedPassport'?: string;
    /**
     * 
     * @type {string}
     * @memberof BeneficialOwner
     */
    'maskedMatriculaConsular'?: string;
    /**
     * 
     * @type {number}
     * @memberof BeneficialOwner
     */
    'idTheftScore'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof BeneficialOwner
     */
    'evaluationCodes'?: Array<string>;
    /**
     * 
     * @type {Occupation}
     * @memberof BeneficialOwner
     */
    'occupation'?: Occupation;
    /**
     * 
     * @type {AnnualIncome}
     * @memberof BeneficialOwner
     */
    'annualIncome'?: AnnualIncome;
    /**
     * 
     * @type {SourceOfIncome}
     * @memberof BeneficialOwner
     */
    'sourceOfIncome'?: SourceOfIncome;
}


/**
 * 
 * @export
 * @interface BeneficialOwnersRelationship
 */
export interface BeneficialOwnersRelationship {
    /**
     * 
     * @type {Array<BeneficialOwnersRelationshipDataInner>}
     * @memberof BeneficialOwnersRelationship
     */
    'data'?: Array<BeneficialOwnersRelationshipDataInner>;
}
/**
 * 
 * @export
 * @interface BeneficialOwnersRelationshipDataInner
 */
export interface BeneficialOwnersRelationshipDataInner {
    /**
     * 
     * @type {string}
     * @memberof BeneficialOwnersRelationshipDataInner
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof BeneficialOwnersRelationshipDataInner
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface Bin
 */
export interface Bin {
    /**
     * 
     * @type {string}
     * @memberof Bin
     */
    'bin': string;
    /**
     * 
     * @type {string}
     * @memberof Bin
     */
    'institutionId': string;
}
/**
 * 
 * @export
 * @interface BookPayment
 */
export interface BookPayment extends Payment {
    /**
     * 
     * @type {BookPaymentAllOfAttributes}
     * @memberof BookPayment
     */
    'attributes': BookPaymentAllOfAttributes;
    /**
     * 
     * @type {BookPaymentRelationships}
     * @memberof BookPayment
     */
    'relationships': BookPaymentRelationships;
}


/**
 * 
 * @export
 * @interface BookPaymentAllOfAttributes
 */
export interface BookPaymentAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof BookPaymentAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {number}
     * @memberof BookPaymentAllOfAttributes
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof BookPaymentAllOfAttributes
     */
    'direction': BookPaymentAllOfAttributesDirectionEnum;
    /**
     * 
     * @type {string}
     * @memberof BookPaymentAllOfAttributes
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof BookPaymentAllOfAttributes
     */
    'status': BookPaymentAllOfAttributesStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof BookPaymentAllOfAttributes
     */
    'transactionSummaryOverride'?: string;
    /**
     * 
     * @type {string}
     * @memberof BookPaymentAllOfAttributes
     */
    'reason'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof BookPaymentAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
}

export const BookPaymentAllOfAttributesDirectionEnum = {
    Credit: 'Credit',
    Debit: 'Debit'
} as const;

export type BookPaymentAllOfAttributesDirectionEnum = typeof BookPaymentAllOfAttributesDirectionEnum[keyof typeof BookPaymentAllOfAttributesDirectionEnum];
export const BookPaymentAllOfAttributesStatusEnum = {
    Pending: 'Pending',
    Rejected: 'Rejected',
    Clearing: 'Clearing',
    Sent: 'Sent',
    Canceled: 'Canceled',
    Returned: 'Returned'
} as const;

export type BookPaymentAllOfAttributesStatusEnum = typeof BookPaymentAllOfAttributesStatusEnum[keyof typeof BookPaymentAllOfAttributesStatusEnum];

/**
 * 
 * @export
 * @interface BookPaymentRelationships
 */
export interface BookPaymentRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof BookPaymentRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof BookPaymentRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof BookPaymentRelationships
     */
    'customers'?: CustomersRelationship;
    /**
     * 
     * @type {CounterpartyAccountRelationship}
     * @memberof BookPaymentRelationships
     */
    'counterpartyAccount': CounterpartyAccountRelationship;
    /**
     * 
     * @type {CounterpartyCustomerRelationship}
     * @memberof BookPaymentRelationships
     */
    'counterpartyCustomer': CounterpartyCustomerRelationship;
    /**
     * 
     * @type {TransactionRelationship}
     * @memberof BookPaymentRelationships
     */
    'transaction': TransactionRelationship;
    /**
     * 
     * @type {RecurringPaymentRelationship}
     * @memberof BookPaymentRelationships
     */
    'recurringPayment'?: RecurringPaymentRelationship;
}
/**
 * 
 * @export
 * @interface BookRepayment
 */
export interface BookRepayment extends Repayment {
    /**
     * 
     * @type {BookRepaymentAllOfAttributes}
     * @memberof BookRepayment
     */
    'attributes': BookRepaymentAllOfAttributes;
    /**
     * 
     * @type {BookRepaymentRelationships}
     * @memberof BookRepayment
     */
    'relationships': BookRepaymentRelationships;
}


/**
 * 
 * @export
 * @interface BookRepaymentAllOfAttributes
 */
export interface BookRepaymentAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof BookRepaymentAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BookRepaymentAllOfAttributes
     */
    'updatedAt': string;
    /**
     * 
     * @type {number}
     * @memberof BookRepaymentAllOfAttributes
     */
    'amount': number;
    /**
     * 
     * @type {BookRepaymentStatus}
     * @memberof BookRepaymentAllOfAttributes
     */
    'status': BookRepaymentStatus;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof BookRepaymentAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
}


/**
 * 
 * @export
 * @interface BookRepaymentRelationships
 */
export interface BookRepaymentRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof BookRepaymentRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CreditAccountRelationship}
     * @memberof BookRepaymentRelationships
     */
    'creditAccount': CreditAccountRelationship;
    /**
     * 
     * @type {OrgRelationship}
     * @memberof BookRepaymentRelationships
     */
    'org': OrgRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof BookRepaymentRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CounterpartyAccountRelationship}
     * @memberof BookRepaymentRelationships
     */
    'counterpartyAccount': CounterpartyAccountRelationship;
    /**
     * 
     * @type {PaymentRelationship}
     * @memberof BookRepaymentRelationships
     */
    'payment': PaymentRelationship;
    /**
     * 
     * @type {RecurringRepaymentRelationship}
     * @memberof BookRepaymentRelationships
     */
    'recurringRepayment'?: RecurringRepaymentRelationship;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const BookRepaymentStatus = {
    Sent: 'Sent',
    Rejected: 'Rejected'
} as const;

export type BookRepaymentStatus = typeof BookRepaymentStatus[keyof typeof BookRepaymentStatus];


/**
 * 
 * @export
 * @interface BookTransaction
 */
export interface BookTransaction extends Transaction {
    /**
     * 
     * @type {BookTransactionAllOfAttributes}
     * @memberof BookTransaction
     */
    'attributes': BookTransactionAllOfAttributes;
    /**
     * 
     * @type {BookTransactionRelationships}
     * @memberof BookTransaction
     */
    'relationships': BookTransactionRelationships;
}


/**
 * 
 * @export
 * @interface BookTransactionAllOfAttributes
 */
export interface BookTransactionAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof BookTransactionAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BookTransactionAllOfAttributes
     */
    'direction': BookTransactionAllOfAttributesDirectionEnum;
    /**
     * 
     * @type {number}
     * @memberof BookTransactionAllOfAttributes
     */
    'amount': number;
    /**
     * 
     * @type {number}
     * @memberof BookTransactionAllOfAttributes
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof BookTransactionAllOfAttributes
     */
    'summary': string;
    /**
     * 
     * @type {PaymentCounterparty}
     * @memberof BookTransactionAllOfAttributes
     */
    'counterparty': PaymentCounterparty;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof BookTransactionAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
}

export const BookTransactionAllOfAttributesDirectionEnum = {
    Credit: 'Credit',
    Debit: 'Debit'
} as const;

export type BookTransactionAllOfAttributesDirectionEnum = typeof BookTransactionAllOfAttributesDirectionEnum[keyof typeof BookTransactionAllOfAttributesDirectionEnum];

/**
 * 
 * @export
 * @interface BookTransactionRelationships
 */
export interface BookTransactionRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof BookTransactionRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof BookTransactionRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof BookTransactionRelationships
     */
    'customers'?: CustomersRelationship;
    /**
     * 
     * @type {CounterpartyAccountRelationship}
     * @memberof BookTransactionRelationships
     */
    'counterpartyAccount': CounterpartyAccountRelationship;
    /**
     * 
     * @type {CounterpartyCustomerRelationship}
     * @memberof BookTransactionRelationships
     */
    'counterpartyCustomer': CounterpartyCustomerRelationship;
    /**
     * 
     * @type {PaymentRelationship}
     * @memberof BookTransactionRelationships
     */
    'payment'?: PaymentRelationship;
    /**
     * 
     * @type {RecurringPaymentRelationship}
     * @memberof BookTransactionRelationships
     */
    'recurringPayment'?: RecurringPaymentRelationship;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const BusinessAnnualRevenue = {
    UpTo250k: 'UpTo250k',
    Between250kAnd500k: 'Between250kAnd500k',
    Between500kAnd1m: 'Between500kAnd1m',
    Between1mAnd5m: 'Between1mAnd5m',
    Over5m: 'Over5m'
} as const;

export type BusinessAnnualRevenue = typeof BusinessAnnualRevenue[keyof typeof BusinessAnnualRevenue];


/**
 * 
 * @export
 * @interface BusinessApplication
 */
export interface BusinessApplication extends Application {
    /**
     * 
     * @type {BusinessApplicationAllOfAttributes}
     * @memberof BusinessApplication
     */
    'attributes': BusinessApplicationAllOfAttributes;
    /**
     * 
     * @type {BusinessApplicationRelationships}
     * @memberof BusinessApplication
     */
    'relationships'?: BusinessApplicationRelationships;
}


/**
 * 
 * @export
 * @interface BusinessApplicationAllOfAttributes
 */
export interface BusinessApplicationAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {ApplicationStatus}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'status': ApplicationStatus;
    /**
     * 
     * @type {string}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'evaluationOutcome'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'evaluationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'evaluationEntityId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'dba'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'ein'?: string;
    /**
     * 
     * @type {EntityType}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'entityType': EntityType;
    /**
     * 
     * @type {string}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'dateOfIncorporation'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'stateOfIncorporation': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'purpose'?: string;
    /**
     * 
     * @type {Phone}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'phone'?: Phone;
    /**
     * 
     * @type {Address}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'address'?: Address;
    /**
     * 
     * @type {Contact}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'contact': Contact;
    /**
     * 
     * @type {Officer}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'officer': Officer;
    /**
     * 
     * @type {string}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'ip'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'website'?: string;
    /**
     * 
     * @type {Array<BeneficialOwner>}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'beneficialOwners': Array<BeneficialOwner>;
    /**
     * 
     * @type {string}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'decisionMethod'?: BusinessApplicationAllOfAttributesDecisionMethodEnum;
    /**
     * 
     * @type {string}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'decisionUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'decisionReason'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'decisionDateTime'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'riskRate'?: BusinessApplicationAllOfAttributesRiskRateEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'evaluationFlags'?: Array<string>;
    /**
     * 
     * @type {object}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'ipLocationDetails'?: object;
    /**
     * 
     * @type {object}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'phoneLocationDetails'?: object;
    /**
     * 
     * @type {boolean}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'archived'?: boolean;
    /**
     * 
     * @type {Industry}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'industry'?: Industry;
    /**
     * 
     * @type {BusinessAnnualRevenue}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'annualRevenue'?: BusinessAnnualRevenue;
    /**
     * 
     * @type {BusinessNumberOfEmployees}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'numberOfEmployees'?: BusinessNumberOfEmployees;
    /**
     * 
     * @type {CashFlow}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'cashFlow'?: CashFlow;
    /**
     * 
     * @type {string}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'yearOfIncorporation'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'countriesOfOperation'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'stockSymbol'?: string;
    /**
     * 
     * @type {BusinessVertical}
     * @memberof BusinessApplicationAllOfAttributes
     */
    'businessVertical'?: BusinessVertical;
}

export const BusinessApplicationAllOfAttributesDecisionMethodEnum = {
    Manually: 'Manually',
    Automatically: 'Automatically'
} as const;

export type BusinessApplicationAllOfAttributesDecisionMethodEnum = typeof BusinessApplicationAllOfAttributesDecisionMethodEnum[keyof typeof BusinessApplicationAllOfAttributesDecisionMethodEnum];
export const BusinessApplicationAllOfAttributesRiskRateEnum = {
    Low: 'low',
    Medium: 'medium',
    High: 'high'
} as const;

export type BusinessApplicationAllOfAttributesRiskRateEnum = typeof BusinessApplicationAllOfAttributesRiskRateEnum[keyof typeof BusinessApplicationAllOfAttributesRiskRateEnum];

/**
 * 
 * @export
 * @interface BusinessApplicationRelationships
 */
export interface BusinessApplicationRelationships {
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof BusinessApplicationRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {DocumentsRelationship}
     * @memberof BusinessApplicationRelationships
     */
    'documents'?: DocumentsRelationship;
    /**
     * 
     * @type {BeneficialOwnersRelationship}
     * @memberof BusinessApplicationRelationships
     */
    'beneficialOwners'?: BeneficialOwnersRelationship;
    /**
     * 
     * @type {OrgRelationship}
     * @memberof BusinessApplicationRelationships
     */
    'org'?: OrgRelationship;
    /**
     * 
     * @type {Relationship}
     * @memberof BusinessApplicationRelationships
     */
    'applicationForm'?: Relationship;
}
/**
 * 
 * @export
 * @interface BusinessCreditCard
 */
export interface BusinessCreditCard extends Card {
    /**
     * 
     * @type {BusinessDebitCardAllOfAttributes}
     * @memberof BusinessCreditCard
     */
    'attributes': BusinessDebitCardAllOfAttributes;
    /**
     * 
     * @type {CardRelationships}
     * @memberof BusinessCreditCard
     */
    'relationships': CardRelationships;
}


/**
 * 
 * @export
 * @interface BusinessCustomer
 */
export interface BusinessCustomer extends Customer {
    /**
     * 
     * @type {BusinessCustomerAllOfAttributes}
     * @memberof BusinessCustomer
     */
    'attributes'?: BusinessCustomerAllOfAttributes;
    /**
     * 
     * @type {CustomerRelationships}
     * @memberof BusinessCustomer
     */
    'relationships'?: CustomerRelationships;
}


/**
 * 
 * @export
 * @interface BusinessCustomerAllOfAttributes
 */
export interface BusinessCustomerAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof BusinessCustomerAllOfAttributes
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessCustomerAllOfAttributes
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessCustomerAllOfAttributes
     */
    'dba'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessCustomerAllOfAttributes
     */
    'ein'?: string;
    /**
     * 
     * @type {EntityType}
     * @memberof BusinessCustomerAllOfAttributes
     */
    'entityType': EntityType;
    /**
     * 
     * @type {string}
     * @memberof BusinessCustomerAllOfAttributes
     */
    'dateOfIncorporation'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessCustomerAllOfAttributes
     */
    'stateOfIncorporation': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessCustomerAllOfAttributes
     */
    'purpose'?: string;
    /**
     * 
     * @type {Phone}
     * @memberof BusinessCustomerAllOfAttributes
     */
    'phone'?: Phone;
    /**
     * 
     * @type {Address}
     * @memberof BusinessCustomerAllOfAttributes
     */
    'address'?: Address;
    /**
     * 
     * @type {Contact}
     * @memberof BusinessCustomerAllOfAttributes
     */
    'contact': Contact;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof BusinessCustomerAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof BusinessCustomerAllOfAttributes
     */
    'riskRate'?: BusinessCustomerAllOfAttributesRiskRateEnum;
    /**
     * 
     * @type {Array<AuthorizedUser>}
     * @memberof BusinessCustomerAllOfAttributes
     */
    'authorizedUsers'?: Array<AuthorizedUser>;
    /**
     * 
     * @type {string}
     * @memberof BusinessCustomerAllOfAttributes
     */
    'status': BusinessCustomerAllOfAttributesStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof BusinessCustomerAllOfAttributes
     */
    'archiveReason'?: BusinessCustomerAllOfAttributesArchiveReasonEnum;
}

export const BusinessCustomerAllOfAttributesRiskRateEnum = {
    Low: 'low',
    Medium: 'medium',
    High: 'high'
} as const;

export type BusinessCustomerAllOfAttributesRiskRateEnum = typeof BusinessCustomerAllOfAttributesRiskRateEnum[keyof typeof BusinessCustomerAllOfAttributesRiskRateEnum];
export const BusinessCustomerAllOfAttributesStatusEnum = {
    Active: 'Active',
    Archived: 'Archived'
} as const;

export type BusinessCustomerAllOfAttributesStatusEnum = typeof BusinessCustomerAllOfAttributesStatusEnum[keyof typeof BusinessCustomerAllOfAttributesStatusEnum];
export const BusinessCustomerAllOfAttributesArchiveReasonEnum = {
    Inactive: 'Inactive',
    FraudAchActivity: 'FraudACHActivity',
    FraudCardActivity: 'FraudCardActivity',
    FraudCheckActivity: 'FraudCheckActivity',
    FraudApplicationHistory: 'FraudApplicationHistory',
    FraudAccountActivity: 'FraudAccountActivity',
    FraudClientIdentified: 'FraudClientIdentified',
    FraudLinkedToFraudulentCustomer: 'FraudLinkedToFraudulentCustomer'
} as const;

export type BusinessCustomerAllOfAttributesArchiveReasonEnum = typeof BusinessCustomerAllOfAttributesArchiveReasonEnum[keyof typeof BusinessCustomerAllOfAttributesArchiveReasonEnum];

/**
 * 
 * @export
 * @interface BusinessDebitCard
 */
export interface BusinessDebitCard extends Card {
    /**
     * 
     * @type {BusinessDebitCardAllOfAttributes}
     * @memberof BusinessDebitCard
     */
    'attributes': BusinessDebitCardAllOfAttributes;
    /**
     * 
     * @type {CardRelationships}
     * @memberof BusinessDebitCard
     */
    'relationships': CardRelationships;
}


/**
 * 
 * @export
 * @interface BusinessDebitCardAllOfAttributes
 */
export interface BusinessDebitCardAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof BusinessDebitCardAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessDebitCardAllOfAttributes
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessDebitCardAllOfAttributes
     */
    'last4Digits': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessDebitCardAllOfAttributes
     */
    'expirationDate': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessDebitCardAllOfAttributes
     */
    'nextExpirationDate'?: string;
    /**
     * 
     * @type {Address}
     * @memberof BusinessDebitCardAllOfAttributes
     */
    'shippingAddress'?: Address;
    /**
     * 
     * @type {Address}
     * @memberof BusinessDebitCardAllOfAttributes
     */
    'address': Address;
    /**
     * 
     * @type {FullName}
     * @memberof BusinessDebitCardAllOfAttributes
     */
    'fullName': FullName;
    /**
     * 
     * @type {Phone}
     * @memberof BusinessDebitCardAllOfAttributes
     */
    'phone': Phone;
    /**
     * 
     * @type {string}
     * @memberof BusinessDebitCardAllOfAttributes
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessDebitCardAllOfAttributes
     */
    'dateOfBirth': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessDebitCardAllOfAttributes
     */
    'nationality'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessDebitCardAllOfAttributes
     */
    'ssn'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessDebitCardAllOfAttributes
     */
    'passport'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessDebitCardAllOfAttributes
     */
    'bin'?: string;
    /**
     * 
     * @type {PhysicalCardStatus}
     * @memberof BusinessDebitCardAllOfAttributes
     */
    'status'?: PhysicalCardStatus;
    /**
     * 
     * @type {string}
     * @memberof BusinessDebitCardAllOfAttributes
     */
    'design'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof BusinessDebitCardAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof BusinessDebitCardAllOfAttributes
     */
    'freezeReason'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const BusinessNumberOfEmployees = {
    UpTo10: 'UpTo10',
    Between10And50: 'Between10And50',
    Between50And100: 'Between50And100',
    Between100And500: 'Between100And500',
    Over500: 'Over500'
} as const;

export type BusinessNumberOfEmployees = typeof BusinessNumberOfEmployees[keyof typeof BusinessNumberOfEmployees];


/**
 * 
 * @export
 * @interface BusinessOfficer
 */
export interface BusinessOfficer {
    /**
     * 
     * @type {Occupation}
     * @memberof BusinessOfficer
     */
    'occupation'?: Occupation;
    /**
     * 
     * @type {AnnualIncome}
     * @memberof BusinessOfficer
     */
    'annualIncome'?: AnnualIncome;
    /**
     * 
     * @type {SourceOfIncome}
     * @memberof BusinessOfficer
     */
    'sourceOfIncome'?: SourceOfIncome;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const BusinessVertical = {
    AdultEntertainmentDatingOrEscortServices: 'AdultEntertainmentDatingOrEscortServices',
    AgricultureForestryFishingOrHunting: 'AgricultureForestryFishingOrHunting',
    ArtsEntertainmentAndRecreation: 'ArtsEntertainmentAndRecreation',
    BusinessSupportOrBuildingServices: 'BusinessSupportOrBuildingServices',
    Cannabis: 'Cannabis',
    Construction: 'Construction',
    DirectMarketingOrTelemarketing: 'DirectMarketingOrTelemarketing',
    EducationalServices: 'EducationalServices',
    FinancialServicesCryptocurrency: 'FinancialServicesCryptocurrency',
    FinancialServicesDebitCollectionOrConsolidation: 'FinancialServicesDebitCollectionOrConsolidation',
    FinancialServicesMoneyServicesBusinessOrCurrencyExchange: 'FinancialServicesMoneyServicesBusinessOrCurrencyExchange',
    FinancialServicesOther: 'FinancialServicesOther',
    FinancialServicesPaydayLending: 'FinancialServicesPaydayLending',
    GamingOrGambling: 'GamingOrGambling',
    HealthCareAndSocialAssistance: 'HealthCareAndSocialAssistance',
    HospitalityAccommodationOrFoodServices: 'HospitalityAccommodationOrFoodServices',
    LegalAccountingConsultingOrComputerProgramming: 'LegalAccountingConsultingOrComputerProgramming',
    Manufacturing: 'Manufacturing',
    Mining: 'Mining',
    Nutraceuticals: 'Nutraceuticals',
    PersonalCareServices: 'PersonalCareServices',
    PublicAdministration: 'PublicAdministration',
    RealEstate: 'RealEstate',
    ReligiousCivicAndSocialOrganizations: 'ReligiousCivicAndSocialOrganizations',
    RepairAndMaintenance: 'RepairAndMaintenance',
    RetailTrade: 'RetailTrade',
    TechnologyMediaOrTelecom: 'TechnologyMediaOrTelecom',
    TransportationOrWarehousing: 'TransportationOrWarehousing',
    Utilities: 'Utilities',
    WholesaleTrade: 'WholesaleTrade'
} as const;

export type BusinessVertical = typeof BusinessVertical[keyof typeof BusinessVertical];


/**
 * 
 * @export
 * @interface BusinessVirtualCreditCard
 */
export interface BusinessVirtualCreditCard extends Card {
    /**
     * 
     * @type {BusinessVirtualDebitCardAllOfAttributes}
     * @memberof BusinessVirtualCreditCard
     */
    'attributes': BusinessVirtualDebitCardAllOfAttributes;
    /**
     * 
     * @type {CardRelationships}
     * @memberof BusinessVirtualCreditCard
     */
    'relationships': CardRelationships;
}


/**
 * 
 * @export
 * @interface BusinessVirtualDebitCard
 */
export interface BusinessVirtualDebitCard extends Card {
    /**
     * 
     * @type {BusinessVirtualDebitCardAllOfAttributes}
     * @memberof BusinessVirtualDebitCard
     */
    'attributes': BusinessVirtualDebitCardAllOfAttributes;
    /**
     * 
     * @type {CardRelationships}
     * @memberof BusinessVirtualDebitCard
     */
    'relationships': CardRelationships;
}


/**
 * 
 * @export
 * @interface BusinessVirtualDebitCardAllOfAttributes
 */
export interface BusinessVirtualDebitCardAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof BusinessVirtualDebitCardAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessVirtualDebitCardAllOfAttributes
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessVirtualDebitCardAllOfAttributes
     */
    'last4Digits': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessVirtualDebitCardAllOfAttributes
     */
    'expirationDate': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessVirtualDebitCardAllOfAttributes
     */
    'nextExpirationDate'?: string;
    /**
     * 
     * @type {Address}
     * @memberof BusinessVirtualDebitCardAllOfAttributes
     */
    'address': Address;
    /**
     * 
     * @type {FullName}
     * @memberof BusinessVirtualDebitCardAllOfAttributes
     */
    'fullName': FullName;
    /**
     * 
     * @type {Phone}
     * @memberof BusinessVirtualDebitCardAllOfAttributes
     */
    'phone': Phone;
    /**
     * 
     * @type {string}
     * @memberof BusinessVirtualDebitCardAllOfAttributes
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessVirtualDebitCardAllOfAttributes
     */
    'dateOfBirth': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessVirtualDebitCardAllOfAttributes
     */
    'nationality'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessVirtualDebitCardAllOfAttributes
     */
    'ssn'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessVirtualDebitCardAllOfAttributes
     */
    'passport'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessVirtualDebitCardAllOfAttributes
     */
    'bin'?: string;
    /**
     * 
     * @type {VirtualCardStatus}
     * @memberof BusinessVirtualDebitCardAllOfAttributes
     */
    'status'?: VirtualCardStatus;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof BusinessVirtualDebitCardAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof BusinessVirtualDebitCardAllOfAttributes
     */
    'freezeReason'?: string;
}


/**
 * 
 * @export
 * @interface BusinessWalletCustomer
 */
export interface BusinessWalletCustomer extends Customer {
    /**
     * 
     * @type {BusinessWalletCustomerAllOfAttributes}
     * @memberof BusinessWalletCustomer
     */
    'attributes'?: BusinessWalletCustomerAllOfAttributes;
    /**
     * 
     * @type {OrgRelationship}
     * @memberof BusinessWalletCustomer
     */
    'relationships'?: OrgRelationship;
}


/**
 * 
 * @export
 * @interface BusinessWalletCustomerAllOfAttributes
 */
export interface BusinessWalletCustomerAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof BusinessWalletCustomerAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessWalletCustomerAllOfAttributes
     */
    'bankName': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessWalletCustomerAllOfAttributes
     */
    'businessName': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessWalletCustomerAllOfAttributes
     */
    'name': string;
    /**
     * 
     * @type {Address}
     * @memberof BusinessWalletCustomerAllOfAttributes
     */
    'address': Address;
    /**
     * 
     * @type {string}
     * @memberof BusinessWalletCustomerAllOfAttributes
     */
    'ein': string;
    /**
     * 
     * @type {BusinessVertical}
     * @memberof BusinessWalletCustomerAllOfAttributes
     */
    'businessVertical': BusinessVertical;
    /**
     * 
     * @type {BusinessNumberOfEmployees}
     * @memberof BusinessWalletCustomerAllOfAttributes
     */
    'numberOfEmployees': BusinessNumberOfEmployees;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof BusinessWalletCustomerAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
}


/**
 * 
 * @export
 * @interface CancelApplicationRequest
 */
export interface CancelApplicationRequest {
    /**
     * 
     * @type {CancelApplicationRequestData}
     * @memberof CancelApplicationRequest
     */
    'data'?: CancelApplicationRequestData;
}
/**
 * 
 * @export
 * @interface CancelApplicationRequestData
 */
export interface CancelApplicationRequestData {
    /**
     * 
     * @type {string}
     * @memberof CancelApplicationRequestData
     */
    'type'?: CancelApplicationRequestDataTypeEnum;
    /**
     * 
     * @type {CancelApplicationRequestDataAttributes}
     * @memberof CancelApplicationRequestData
     */
    'attributes'?: CancelApplicationRequestDataAttributes;
}

export const CancelApplicationRequestDataTypeEnum = {
    ApplicationCancel: 'applicationCancel'
} as const;

export type CancelApplicationRequestDataTypeEnum = typeof CancelApplicationRequestDataTypeEnum[keyof typeof CancelApplicationRequestDataTypeEnum];

/**
 * 
 * @export
 * @interface CancelApplicationRequestDataAttributes
 */
export interface CancelApplicationRequestDataAttributes {
    /**
     * 
     * @type {string}
     * @memberof CancelApplicationRequestDataAttributes
     */
    'reason'?: string;
}
/**
 * 
 * @export
 * @interface CapitalPartnerAchRepayment
 */
export interface CapitalPartnerAchRepayment extends Repayment {
    /**
     * 
     * @type {AchRepaymentAllOfAttributes}
     * @memberof CapitalPartnerAchRepayment
     */
    'attributes': AchRepaymentAllOfAttributes;
    /**
     * 
     * @type {CapitalPartnerAchRepaymentRelationships}
     * @memberof CapitalPartnerAchRepayment
     */
    'relationships': CapitalPartnerAchRepaymentRelationships;
}


/**
 * 
 * @export
 * @interface CapitalPartnerAchRepaymentRelationships
 */
export interface CapitalPartnerAchRepaymentRelationships {
    /**
     * 
     * @type {CreditAccountRelationship}
     * @memberof CapitalPartnerAchRepaymentRelationships
     */
    'creditAccount': CreditAccountRelationship;
    /**
     * 
     * @type {OrgRelationship}
     * @memberof CapitalPartnerAchRepaymentRelationships
     */
    'org': OrgRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof CapitalPartnerAchRepaymentRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CounterpartyRelationship}
     * @memberof CapitalPartnerAchRepaymentRelationships
     */
    'counterparty': CounterpartyRelationship;
    /**
     * 
     * @type {PaymentRelationship}
     * @memberof CapitalPartnerAchRepaymentRelationships
     */
    'payment': PaymentRelationship;
    /**
     * 
     * @type {RecurringRepaymentRelationship}
     * @memberof CapitalPartnerAchRepaymentRelationships
     */
    'recurringRepayment'?: RecurringRepaymentRelationship;
}
/**
 * 
 * @export
 * @interface CapitalPartnerBookRepayment
 */
export interface CapitalPartnerBookRepayment extends Repayment {
    /**
     * 
     * @type {BookRepaymentAllOfAttributes}
     * @memberof CapitalPartnerBookRepayment
     */
    'attributes': BookRepaymentAllOfAttributes;
    /**
     * 
     * @type {CapitalPartnerBookRepaymentRelationships}
     * @memberof CapitalPartnerBookRepayment
     */
    'relationships': CapitalPartnerBookRepaymentRelationships;
}


/**
 * 
 * @export
 * @interface CapitalPartnerBookRepaymentRelationships
 */
export interface CapitalPartnerBookRepaymentRelationships {
    /**
     * 
     * @type {CreditAccountRelationship}
     * @memberof CapitalPartnerBookRepaymentRelationships
     */
    'creditAccount': CreditAccountRelationship;
    /**
     * 
     * @type {OrgRelationship}
     * @memberof CapitalPartnerBookRepaymentRelationships
     */
    'org': OrgRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof CapitalPartnerBookRepaymentRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CounterpartyAccountRelationship}
     * @memberof CapitalPartnerBookRepaymentRelationships
     */
    'counterpartyAccount': CounterpartyAccountRelationship;
    /**
     * 
     * @type {PaymentRelationship}
     * @memberof CapitalPartnerBookRepaymentRelationships
     */
    'payment': PaymentRelationship;
    /**
     * 
     * @type {RecurringRepaymentRelationship}
     * @memberof CapitalPartnerBookRepaymentRelationships
     */
    'recurringRepayment'?: RecurringRepaymentRelationship;
}
/**
 * 
 * @export
 * @interface Card
 */
export interface Card {
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    'type'?: CardTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    'id'?: string;
}

export const CardTypeEnum = {
    BusinessDebitCard: 'businessDebitCard',
    IndividualDebitCard: 'individualDebitCard',
    BusinessVirtualDebitCard: 'businessVirtualDebitCard',
    IndividualVirtualDebitCard: 'individualVirtualDebitCard',
    BusinessCreditCard: 'businessCreditCard',
    BusinessVirtualCreditCard: 'businessVirtualCreditCard'
} as const;

export type CardTypeEnum = typeof CardTypeEnum[keyof typeof CardTypeEnum];

/**
 * 
 * @export
 * @interface CardLevelLimits
 */
export interface CardLevelLimits {
    /**
     * 
     * @type {number}
     * @memberof CardLevelLimits
     */
    'dailyWithdrawal'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardLevelLimits
     */
    'dailyPurchase'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardLevelLimits
     */
    'monthlyWithdrawal'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardLevelLimits
     */
    'monthlyPurchase'?: number;
}
/**
 * 
 * @export
 * @interface CardRelationship
 */
export interface CardRelationship {
    /**
     * 
     * @type {CardRelationshipData}
     * @memberof CardRelationship
     */
    'data': CardRelationshipData;
}
/**
 * 
 * @export
 * @interface CardRelationshipData
 */
export interface CardRelationshipData {
    /**
     * 
     * @type {string}
     * @memberof CardRelationshipData
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof CardRelationshipData
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface CardRelationships
 */
export interface CardRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof CardRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof CardRelationships
     */
    'customer'?: CustomerRelationship;
}
/**
 * 
 * @export
 * @interface CardReversalTransaction
 */
export interface CardReversalTransaction extends Transaction {
    /**
     * 
     * @type {CardReversalTransactionAllOfAttributes}
     * @memberof CardReversalTransaction
     */
    'attributes': CardReversalTransactionAllOfAttributes;
    /**
     * 
     * @type {CardReversalTransactionRelationships}
     * @memberof CardReversalTransaction
     */
    'relationships': CardReversalTransactionRelationships;
}


/**
 * 
 * @export
 * @interface CardReversalTransactionAllOfAttributes
 */
export interface CardReversalTransactionAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof CardReversalTransactionAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CardReversalTransactionAllOfAttributes
     */
    'direction': CardReversalTransactionAllOfAttributesDirectionEnum;
    /**
     * 
     * @type {number}
     * @memberof CardReversalTransactionAllOfAttributes
     */
    'amount': number;
    /**
     * 
     * @type {number}
     * @memberof CardReversalTransactionAllOfAttributes
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof CardReversalTransactionAllOfAttributes
     */
    'summary': string;
    /**
     * 
     * @type {string}
     * @memberof CardReversalTransactionAllOfAttributes
     */
    'cardLast4Digits': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CardReversalTransactionAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
}

export const CardReversalTransactionAllOfAttributesDirectionEnum = {
    Credit: 'Credit',
    Debit: 'Debit'
} as const;

export type CardReversalTransactionAllOfAttributesDirectionEnum = typeof CardReversalTransactionAllOfAttributesDirectionEnum[keyof typeof CardReversalTransactionAllOfAttributesDirectionEnum];

/**
 * 
 * @export
 * @interface CardReversalTransactionRelationships
 */
export interface CardReversalTransactionRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof CardReversalTransactionRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof CardReversalTransactionRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof CardReversalTransactionRelationships
     */
    'customers'?: CustomersRelationship;
    /**
     * 
     * @type {CardRelationship}
     * @memberof CardReversalTransactionRelationships
     */
    'card': CardRelationship;
    /**
     * 
     * @type {TransactionRelationshipData}
     * @memberof CardReversalTransactionRelationships
     */
    'data': TransactionRelationshipData;
}
/**
 * 
 * @export
 * @interface CardTotals
 */
export interface CardTotals {
    /**
     * 
     * @type {number}
     * @memberof CardTotals
     */
    'withdrawals': number;
    /**
     * 
     * @type {number}
     * @memberof CardTotals
     */
    'deposits': number;
    /**
     * 
     * @type {number}
     * @memberof CardTotals
     */
    'purchases': number;
    /**
     * 
     * @type {number}
     * @memberof CardTotals
     */
    'cardTransactions': number;
}
/**
 * 
 * @export
 * @interface CardTransaction
 */
export interface CardTransaction extends Transaction {
    /**
     * 
     * @type {CardTransactionAllOfAttributes}
     * @memberof CardTransaction
     */
    'attributes': CardTransactionAllOfAttributes;
    /**
     * 
     * @type {CardReversalTransactionRelationships}
     * @memberof CardTransaction
     */
    'relationships': CardReversalTransactionRelationships;
}


/**
 * 
 * @export
 * @interface CardTransactionAllOfAttributes
 */
export interface CardTransactionAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof CardTransactionAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CardTransactionAllOfAttributes
     */
    'direction': CardTransactionAllOfAttributesDirectionEnum;
    /**
     * 
     * @type {number}
     * @memberof CardTransactionAllOfAttributes
     */
    'amount': number;
    /**
     * 
     * @type {number}
     * @memberof CardTransactionAllOfAttributes
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof CardTransactionAllOfAttributes
     */
    'summary': string;
    /**
     * 
     * @type {string}
     * @memberof CardTransactionAllOfAttributes
     */
    'cardLast4Digits': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CardTransactionAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof CardTransactionAllOfAttributes
     */
    'networkTransactionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardTransactionAllOfAttributes
     */
    'interchange'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CardTransactionAllOfAttributes
     */
    'internationalServiceFee'?: number | null;
    /**
     * 
     * @type {Merchant}
     * @memberof CardTransactionAllOfAttributes
     */
    'merchant': Merchant;
    /**
     * 
     * @type {boolean}
     * @memberof CardTransactionAllOfAttributes
     */
    'recurring': boolean;
    /**
     * 
     * @type {string}
     * @memberof CardTransactionAllOfAttributes
     */
    'paymentMethod'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardTransactionAllOfAttributes
     */
    'digitalWallet'?: string;
    /**
     * 
     * @type {CardVerificationData}
     * @memberof CardTransactionAllOfAttributes
     */
    'cardVerificationData'?: CardVerificationData;
    /**
     * 
     * @type {string}
     * @memberof CardTransactionAllOfAttributes
     */
    'cardNetwork'?: string;
}

export const CardTransactionAllOfAttributesDirectionEnum = {
    Credit: 'Credit',
    Debit: 'Debit'
} as const;

export type CardTransactionAllOfAttributesDirectionEnum = typeof CardTransactionAllOfAttributesDirectionEnum[keyof typeof CardTransactionAllOfAttributesDirectionEnum];

/**
 * 
 * @export
 * @interface CardTransactionAuthorization
 */
export interface CardTransactionAuthorization extends AuthorizationRequest {
    /**
     * 
     * @type {CardTransactionAuthorizationAllOfAttributes}
     * @memberof CardTransactionAuthorization
     */
    'attributes'?: CardTransactionAuthorizationAllOfAttributes;
    /**
     * 
     * @type {AuthorizationRequestRelationships}
     * @memberof CardTransactionAuthorization
     */
    'relationships': AuthorizationRequestRelationships;
}


/**
 * 
 * @export
 * @interface CardTransactionAuthorizationAllOfAttributes
 */
export interface CardTransactionAuthorizationAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof CardTransactionAuthorizationAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {number}
     * @memberof CardTransactionAuthorizationAllOfAttributes
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof CardTransactionAuthorizationAllOfAttributes
     */
    'status': string;
    /**
     * 
     * @type {boolean}
     * @memberof CardTransactionAuthorizationAllOfAttributes
     */
    'partialApprovalAllowed': boolean;
    /**
     * 
     * @type {number}
     * @memberof CardTransactionAuthorizationAllOfAttributes
     */
    'approvedAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof CardTransactionAuthorizationAllOfAttributes
     */
    'declineReason'?: string;
    /**
     * 
     * @type {Merchant}
     * @memberof CardTransactionAuthorizationAllOfAttributes
     */
    'merchant': Merchant;
    /**
     * 
     * @type {boolean}
     * @memberof CardTransactionAuthorizationAllOfAttributes
     */
    'recurring': boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CardTransactionAuthorizationAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof CardTransactionAuthorizationAllOfAttributes
     */
    'paymentMethod'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardTransactionAuthorizationAllOfAttributes
     */
    'digitalWallet'?: string;
    /**
     * 
     * @type {CardVerificationData}
     * @memberof CardTransactionAuthorizationAllOfAttributes
     */
    'cardVerificationData'?: CardVerificationData;
    /**
     * 
     * @type {string}
     * @memberof CardTransactionAuthorizationAllOfAttributes
     */
    'cardNetwork'?: string;
}
/**
 * 
 * @export
 * @interface CardVerificationData
 */
export interface CardVerificationData {
    /**
     * 
     * @type {string}
     * @memberof CardVerificationData
     */
    'verificationMethod': string;
}
/**
 * 
 * @export
 * @interface CashDepositTransaction
 */
export interface CashDepositTransaction extends Transaction {
    /**
     * 
     * @type {CashDepositTransactionAllOfAttributes}
     * @memberof CashDepositTransaction
     */
    'attributes': CashDepositTransactionAllOfAttributes;
    /**
     * 
     * @type {CashDepositTransactionRelationships}
     * @memberof CashDepositTransaction
     */
    'relationships': CashDepositTransactionRelationships;
}


/**
 * 
 * @export
 * @interface CashDepositTransactionAllOfAttributes
 */
export interface CashDepositTransactionAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof CashDepositTransactionAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CashDepositTransactionAllOfAttributes
     */
    'direction': CashDepositTransactionAllOfAttributesDirectionEnum;
    /**
     * 
     * @type {number}
     * @memberof CashDepositTransactionAllOfAttributes
     */
    'amount': number;
    /**
     * 
     * @type {number}
     * @memberof CashDepositTransactionAllOfAttributes
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof CashDepositTransactionAllOfAttributes
     */
    'summary': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CashDepositTransactionAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof CashDepositTransactionAllOfAttributes
     */
    'recurring': boolean;
}

export const CashDepositTransactionAllOfAttributesDirectionEnum = {
    Credit: 'Credit',
    Debit: 'Debit'
} as const;

export type CashDepositTransactionAllOfAttributesDirectionEnum = typeof CashDepositTransactionAllOfAttributesDirectionEnum[keyof typeof CashDepositTransactionAllOfAttributesDirectionEnum];

/**
 * 
 * @export
 * @interface CashDepositTransactionRelationships
 */
export interface CashDepositTransactionRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof CashDepositTransactionRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof CashDepositTransactionRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof CashDepositTransactionRelationships
     */
    'customers'?: CustomersRelationship;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CashFlow = {
    Unpredictable: 'Unpredictable',
    Predictable: 'Predictable'
} as const;

export type CashFlow = typeof CashFlow[keyof typeof CashFlow];


/**
 * 
 * @export
 * @interface ChargebackRelationship
 */
export interface ChargebackRelationship {
    /**
     * 
     * @type {ChargebackRelationshipData}
     * @memberof ChargebackRelationship
     */
    'data': ChargebackRelationshipData;
}
/**
 * 
 * @export
 * @interface ChargebackRelationshipData
 */
export interface ChargebackRelationshipData {
    /**
     * 
     * @type {string}
     * @memberof ChargebackRelationshipData
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ChargebackRelationshipData
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ChargebackTransaction
 */
export interface ChargebackTransaction extends Transaction {
    /**
     * 
     * @type {ChargebackTransactionAllOfAttributes}
     * @memberof ChargebackTransaction
     */
    'attributes': ChargebackTransactionAllOfAttributes;
    /**
     * 
     * @type {ChargebackTransactionRelationships}
     * @memberof ChargebackTransaction
     */
    'relationships': ChargebackTransactionRelationships;
}


/**
 * 
 * @export
 * @interface ChargebackTransactionAllOfAttributes
 */
export interface ChargebackTransactionAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof ChargebackTransactionAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ChargebackTransactionAllOfAttributes
     */
    'direction': ChargebackTransactionAllOfAttributesDirectionEnum;
    /**
     * 
     * @type {PaymentCounterparty}
     * @memberof ChargebackTransactionAllOfAttributes
     */
    'counterparty'?: PaymentCounterparty;
    /**
     * 
     * @type {number}
     * @memberof ChargebackTransactionAllOfAttributes
     */
    'amount': number;
    /**
     * 
     * @type {number}
     * @memberof ChargebackTransactionAllOfAttributes
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof ChargebackTransactionAllOfAttributes
     */
    'summary': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ChargebackTransactionAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
}

export const ChargebackTransactionAllOfAttributesDirectionEnum = {
    Credit: 'Credit',
    Debit: 'Debit'
} as const;

export type ChargebackTransactionAllOfAttributesDirectionEnum = typeof ChargebackTransactionAllOfAttributesDirectionEnum[keyof typeof ChargebackTransactionAllOfAttributesDirectionEnum];

/**
 * 
 * @export
 * @interface ChargebackTransactionRelationships
 */
export interface ChargebackTransactionRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof ChargebackTransactionRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof ChargebackTransactionRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof ChargebackTransactionRelationships
     */
    'customers'?: CustomersRelationship;
    /**
     * 
     * @type {CounterpartyAccountRelationship}
     * @memberof ChargebackTransactionRelationships
     */
    'counterpartyAccount': CounterpartyAccountRelationship;
    /**
     * 
     * @type {ChargebackRelationship}
     * @memberof ChargebackTransactionRelationships
     */
    'chargeback': ChargebackRelationship;
}
/**
 * 
 * @export
 * @interface CheckDeposit
 */
export interface CheckDeposit {
    /**
     * 
     * @type {string}
     * @memberof CheckDeposit
     */
    'type': CheckDepositTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CheckDeposit
     */
    'id': string;
    /**
     * 
     * @type {CheckDepositAttributes}
     * @memberof CheckDeposit
     */
    'attributes': CheckDepositAttributes;
    /**
     * 
     * @type {CheckDepositRelationships}
     * @memberof CheckDeposit
     */
    'relationships': CheckDepositRelationships;
}

export const CheckDepositTypeEnum = {
    CheckDeposit: 'checkDeposit'
} as const;

export type CheckDepositTypeEnum = typeof CheckDepositTypeEnum[keyof typeof CheckDepositTypeEnum];

/**
 * 
 * @export
 * @interface CheckDepositAttributes
 */
export interface CheckDepositAttributes {
    /**
     * 
     * @type {string}
     * @memberof CheckDepositAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CheckDepositAttributes
     */
    'settlementDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof CheckDepositAttributes
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof CheckDepositAttributes
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CheckDepositAttributes
     */
    'status': CheckDepositAttributesStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CheckDepositAttributes
     */
    'reason'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CheckDepositAttributes
     */
    'statusCreatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckDepositAttributes
     */
    'statusSetBy'?: string;
    /**
     * 
     * @type {Array<StatusEvent>}
     * @memberof CheckDepositAttributes
     */
    'statusHistory'?: Array<StatusEvent>;
    /**
     * 
     * @type {string}
     * @memberof CheckDepositAttributes
     */
    'reasonText'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckDepositAttributes
     */
    'checkNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckDepositAttributes
     */
    'vendor'?: string;
    /**
     * 
     * @type {CheckDepositCounterparty}
     * @memberof CheckDepositAttributes
     */
    'counterparty'?: CheckDepositCounterparty;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CheckDepositAttributes
     */
    'tags'?: { [key: string]: string; };
}

export const CheckDepositAttributesStatusEnum = {
    AwaitingImages: 'AwaitingImages',
    AwaitingFrontImage: 'AwaitingFrontImage',
    AwaitingBackImage: 'AwaitingBackImage',
    Pending: 'Pending',
    PendingReview: 'PendingReview',
    AwaitingCustomerConfirmation: 'AwaitingCustomerConfirmation',
    Rejected: 'Rejected',
    Clearing: 'Clearing',
    Sent: 'Sent',
    Canceled: 'Canceled',
    Returned: 'Returned'
} as const;

export type CheckDepositAttributesStatusEnum = typeof CheckDepositAttributesStatusEnum[keyof typeof CheckDepositAttributesStatusEnum];

/**
 * 
 * @export
 * @interface CheckDepositCounterparty
 */
export interface CheckDepositCounterparty {
    /**
     * 
     * @type {string}
     * @memberof CheckDepositCounterparty
     */
    'routingNumber': string;
    /**
     * 
     * @type {string}
     * @memberof CheckDepositCounterparty
     */
    'accountNumber': string;
    /**
     * 
     * @type {string}
     * @memberof CheckDepositCounterparty
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CheckDepositRelationship
 */
export interface CheckDepositRelationship {
    /**
     * 
     * @type {CheckDepositRelationshipData}
     * @memberof CheckDepositRelationship
     */
    'data': CheckDepositRelationshipData;
}
/**
 * 
 * @export
 * @interface CheckDepositRelationshipData
 */
export interface CheckDepositRelationshipData {
    /**
     * 
     * @type {string}
     * @memberof CheckDepositRelationshipData
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof CheckDepositRelationshipData
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface CheckDepositRelationships
 */
export interface CheckDepositRelationships {
    /**
     * 
     * @type {OrgRelationship}
     * @memberof CheckDepositRelationships
     */
    'org'?: OrgRelationship;
    /**
     * 
     * @type {AccountRelationship}
     * @memberof CheckDepositRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof CheckDepositRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {TransactionRelationship}
     * @memberof CheckDepositRelationships
     */
    'transaction'?: TransactionRelationship;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CheckDepositStatus = {
    AwaitingImages: 'AwaitingImages',
    AwaitingFrontImage: 'AwaitingFrontImage',
    AwaitingBackImage: 'AwaitingBackImage',
    AwaitingCustomerConfirmation: 'AwaitingCustomerConfirmation',
    Pending: 'Pending',
    PendingReview: 'PendingReview',
    Rejected: 'Rejected',
    Clearing: 'Clearing',
    Sent: 'Sent',
    Canceled: 'Canceled',
    Returned: 'Returned'
} as const;

export type CheckDepositStatus = typeof CheckDepositStatus[keyof typeof CheckDepositStatus];


/**
 * 
 * @export
 * @interface CheckDepositTransaction
 */
export interface CheckDepositTransaction extends Transaction {
    /**
     * 
     * @type {CheckDepositTransactionAllOfAttributes}
     * @memberof CheckDepositTransaction
     */
    'attributes': CheckDepositTransactionAllOfAttributes;
    /**
     * 
     * @type {CheckDepositTransactionRelationships}
     * @memberof CheckDepositTransaction
     */
    'relationships': CheckDepositTransactionRelationships;
}


/**
 * 
 * @export
 * @interface CheckDepositTransactionAllOfAttributes
 */
export interface CheckDepositTransactionAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof CheckDepositTransactionAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {number}
     * @memberof CheckDepositTransactionAllOfAttributes
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof CheckDepositTransactionAllOfAttributes
     */
    'direction': CheckDepositTransactionAllOfAttributesDirectionEnum;
    /**
     * 
     * @type {number}
     * @memberof CheckDepositTransactionAllOfAttributes
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof CheckDepositTransactionAllOfAttributes
     */
    'summary': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CheckDepositTransactionAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
}

export const CheckDepositTransactionAllOfAttributesDirectionEnum = {
    Credit: 'Credit',
    Debit: 'Debit'
} as const;

export type CheckDepositTransactionAllOfAttributesDirectionEnum = typeof CheckDepositTransactionAllOfAttributesDirectionEnum[keyof typeof CheckDepositTransactionAllOfAttributesDirectionEnum];

/**
 * 
 * @export
 * @interface CheckDepositTransactionRelationships
 */
export interface CheckDepositTransactionRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof CheckDepositTransactionRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof CheckDepositTransactionRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof CheckDepositTransactionRelationships
     */
    'customers'?: CustomersRelationship;
    /**
     * 
     * @type {CheckDepositRelationship}
     * @memberof CheckDepositTransactionRelationships
     */
    'checkDeposit': CheckDepositRelationship;
}
/**
 * 
 * @export
 * @interface CheckPayment
 */
export interface CheckPayment {
    /**
     * 
     * @type {string}
     * @memberof CheckPayment
     */
    'type': CheckPaymentTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CheckPayment
     */
    'id': string;
    /**
     * 
     * @type {CheckPaymentAttributes}
     * @memberof CheckPayment
     */
    'attributes': CheckPaymentAttributes;
    /**
     * 
     * @type {CheckPaymentRelationships}
     * @memberof CheckPayment
     */
    'relationships': CheckPaymentRelationships;
}

export const CheckPaymentTypeEnum = {
    CheckPayment: 'checkPayment'
} as const;

export type CheckPaymentTypeEnum = typeof CheckPaymentTypeEnum[keyof typeof CheckPaymentTypeEnum];

/**
 * 
 * @export
 * @interface CheckPaymentAttributes
 */
export interface CheckPaymentAttributes {
    /**
     * 
     * @type {string}
     * @memberof CheckPaymentAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CheckPaymentAttributes
     */
    'updatedAt': string;
    /**
     * 
     * @type {number}
     * @memberof CheckPaymentAttributes
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof CheckPaymentAttributes
     */
    'returnCutoffTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckPaymentAttributes
     */
    'status': CheckPaymentAttributesStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CheckPaymentAttributes
     */
    'memo'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckPaymentAttributes
     */
    'deliveryStatus'?: CheckPaymentAttributesDeliveryStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CheckPaymentAttributes
     */
    'sendAt'?: string;
    /**
     * 
     * @type {CheckPaymentCounterparty}
     * @memberof CheckPaymentAttributes
     */
    'counterparty'?: CheckPaymentCounterparty;
    /**
     * 
     * @type {string}
     * @memberof CheckPaymentAttributes
     */
    'trackedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckPaymentAttributes
     */
    'postalCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckPaymentAttributes
     */
    'expectedDelivery'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CheckPaymentAttributes
     */
    'originated': boolean;
    /**
     * 
     * @type {string}
     * @memberof CheckPaymentAttributes
     */
    'expirationDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckPaymentAttributes
     */
    'rejectReason'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CheckPaymentAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof CheckPaymentAttributes
     */
    'description'?: string;
    /**
     * 
     * @type {ReturnReason}
     * @memberof CheckPaymentAttributes
     */
    'returnReason'?: ReturnReason;
    /**
     * 
     * @type {Array<string>}
     * @memberof CheckPaymentAttributes
     */
    'pendingReviewReasons'?: Array<CheckPaymentAttributesPendingReviewReasonsEnum>;
    /**
     * 
     * @type {string}
     * @memberof CheckPaymentAttributes
     */
    'checkNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckPaymentAttributes
     */
    'onUsAuxiliary'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckPaymentAttributes
     */
    'onUs'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckPaymentAttributes
     */
    'counterpartyRoutingNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckPaymentAttributes
     */
    'additionalVerificationStatus'?: CheckPaymentAttributesAdditionalVerificationStatusEnum;
}

export const CheckPaymentAttributesStatusEnum = {
    MarkedForReturn: 'MarkedForReturn',
    Returned: 'Returned',
    Processed: 'Processed',
    PendingReview: 'PendingReview'
} as const;

export type CheckPaymentAttributesStatusEnum = typeof CheckPaymentAttributesStatusEnum[keyof typeof CheckPaymentAttributesStatusEnum];
export const CheckPaymentAttributesDeliveryStatusEnum = {
    Mailed: 'Mailed',
    InLocalArea: 'InLocalArea',
    Delivered: 'Delivered',
    Rerouted: 'Rerouted',
    ReturnedToSender: 'ReturnedToSender'
} as const;

export type CheckPaymentAttributesDeliveryStatusEnum = typeof CheckPaymentAttributesDeliveryStatusEnum[keyof typeof CheckPaymentAttributesDeliveryStatusEnum];
export const CheckPaymentAttributesPendingReviewReasonsEnum = {
    NameMissMatch: 'NameMissMatch',
    SoftLimit: 'SoftLimit'
} as const;

export type CheckPaymentAttributesPendingReviewReasonsEnum = typeof CheckPaymentAttributesPendingReviewReasonsEnum[keyof typeof CheckPaymentAttributesPendingReviewReasonsEnum];
export const CheckPaymentAttributesAdditionalVerificationStatusEnum = {
    Required: 'Required',
    NotRequired: 'NotRequired',
    Approved: 'Approved'
} as const;

export type CheckPaymentAttributesAdditionalVerificationStatusEnum = typeof CheckPaymentAttributesAdditionalVerificationStatusEnum[keyof typeof CheckPaymentAttributesAdditionalVerificationStatusEnum];

/**
 * 
 * @export
 * @interface CheckPaymentCounterparty
 */
export interface CheckPaymentCounterparty {
    /**
     * 
     * @type {string}
     * @memberof CheckPaymentCounterparty
     */
    'name'?: string;
    /**
     * 
     * @type {Address}
     * @memberof CheckPaymentCounterparty
     */
    'address'?: Address;
    /**
     * 
     * @type {boolean}
     * @memberof CheckPaymentCounterparty
     */
    'counterpartyMoved'?: boolean;
}
/**
 * 
 * @export
 * @interface CheckPaymentRelationship
 */
export interface CheckPaymentRelationship {
    /**
     * 
     * @type {CheckPaymentRelationshipData}
     * @memberof CheckPaymentRelationship
     */
    'data': CheckPaymentRelationshipData;
}
/**
 * 
 * @export
 * @interface CheckPaymentRelationshipData
 */
export interface CheckPaymentRelationshipData {
    /**
     * 
     * @type {string}
     * @memberof CheckPaymentRelationshipData
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof CheckPaymentRelationshipData
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface CheckPaymentRelationships
 */
export interface CheckPaymentRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof CheckPaymentRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof CheckPaymentRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof CheckPaymentRelationships
     */
    'customers'?: CustomersRelationship;
    /**
     * 
     * @type {TransactionRelationship}
     * @memberof CheckPaymentRelationships
     */
    'transaction'?: TransactionRelationship;
}
/**
 * 
 * @export
 * @interface CheckPaymentTransaction
 */
export interface CheckPaymentTransaction extends Transaction {
    /**
     * 
     * @type {CheckDepositTransactionAllOfAttributes}
     * @memberof CheckPaymentTransaction
     */
    'attributes': CheckDepositTransactionAllOfAttributes;
    /**
     * 
     * @type {CheckPaymentTransactionRelationships}
     * @memberof CheckPaymentTransaction
     */
    'relationships': CheckPaymentTransactionRelationships;
}


/**
 * 
 * @export
 * @interface CheckPaymentTransactionRelationships
 */
export interface CheckPaymentTransactionRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof CheckPaymentTransactionRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof CheckPaymentTransactionRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof CheckPaymentTransactionRelationships
     */
    'customers'?: CustomersRelationship;
    /**
     * 
     * @type {CheckPaymentRelationship}
     * @memberof CheckPaymentTransactionRelationships
     */
    'checkPayment': CheckPaymentRelationship;
}
/**
 * 
 * @export
 * @interface CheckStopPayment
 */
export interface CheckStopPayment {
    /**
     * 
     * @type {CheckStopPaymentAttributes}
     * @memberof CheckStopPayment
     */
    'attributes'?: CheckStopPaymentAttributes;
    /**
     * 
     * @type {CheckStopPaymentRelationships}
     * @memberof CheckStopPayment
     */
    'relationships'?: CheckStopPaymentRelationships;
}
/**
 * 
 * @export
 * @interface CheckStopPaymentAttributes
 */
export interface CheckStopPaymentAttributes {
    /**
     * 
     * @type {string}
     * @memberof CheckStopPaymentAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CheckStopPaymentAttributes
     */
    'updatedAt': string;
    /**
     * 
     * @type {number}
     * @memberof CheckStopPaymentAttributes
     */
    'amount'?: number;
    /**
     * 
     * @type {CheckStopPaymentStatus}
     * @memberof CheckStopPaymentAttributes
     */
    'status': CheckStopPaymentStatus;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CheckStopPaymentAttributes
     */
    'tags': { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof CheckStopPaymentAttributes
     */
    'checkNumber': string;
}


/**
 * 
 * @export
 * @interface CheckStopPaymentRelationships
 */
export interface CheckStopPaymentRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof CheckStopPaymentRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof CheckStopPaymentRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof CheckStopPaymentRelationships
     */
    'customers'?: CustomersRelationship;
    /**
     * 
     * @type {CheckStopPaymentRelationshipsAllOfStoppedPayments}
     * @memberof CheckStopPaymentRelationships
     */
    'stoppedPayments'?: CheckStopPaymentRelationshipsAllOfStoppedPayments;
}
/**
 * 
 * @export
 * @interface CheckStopPaymentRelationshipsAllOfStoppedPayments
 */
export interface CheckStopPaymentRelationshipsAllOfStoppedPayments {
    /**
     * 
     * @type {Array<CheckPayment>}
     * @memberof CheckStopPaymentRelationshipsAllOfStoppedPayments
     */
    'data'?: Array<CheckPayment>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CheckStopPaymentStatus = {
    Active: 'Active',
    Disabled: 'Disabled'
} as const;

export type CheckStopPaymentStatus = typeof CheckStopPaymentStatus[keyof typeof CheckStopPaymentStatus];


/**
 * 
 * @export
 * @interface CloseAccountRequest
 */
export interface CloseAccountRequest {
    /**
     * 
     * @type {CloseAccountRequest}
     * @memberof CloseAccountRequest
     */
    'data'?: CloseAccountRequest;
}
/**
 * 
 * @export
 * @interface CloseAccountRequestAttributes
 */
export interface CloseAccountRequestAttributes {
    /**
     * 
     * @type {string}
     * @memberof CloseAccountRequestAttributes
     */
    'reason'?: CloseAccountRequestAttributesReasonEnum;
    /**
     * 
     * @type {string}
     * @memberof CloseAccountRequestAttributes
     */
    'fraudReason'?: CloseAccountRequestAttributesFraudReasonEnum | null;
}

export const CloseAccountRequestAttributesReasonEnum = {
    ByCustomer: 'ByCustomer',
    Fraud: 'Fraud'
} as const;

export type CloseAccountRequestAttributesReasonEnum = typeof CloseAccountRequestAttributesReasonEnum[keyof typeof CloseAccountRequestAttributesReasonEnum];
export const CloseAccountRequestAttributesFraudReasonEnum = {
    AchActivity: 'ACHActivity',
    CardActivity: 'CardActivity',
    CheckActivity: 'CheckActivity',
    ApplicationHistory: 'ApplicationHistory',
    AccountActivity: 'AccountActivity',
    ClientIdentified: 'ClientIdentified',
    IdentityTheft: 'IdentityTheft',
    LinkedToFraudulentCustomer: 'LinkedToFraudulentCustomer'
} as const;

export type CloseAccountRequestAttributesFraudReasonEnum = typeof CloseAccountRequestAttributesFraudReasonEnum[keyof typeof CloseAccountRequestAttributesFraudReasonEnum];

/**
 * 
 * @export
 * @interface Contact
 */
export interface Contact {
    /**
     * 
     * @type {FullName}
     * @memberof Contact
     */
    'fullName': FullName;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'email': string;
    /**
     * 
     * @type {Phone}
     * @memberof Contact
     */
    'phone': Phone;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'jwtSubject'?: string | null;
}
/**
 * 
 * @export
 * @interface Coordinates
 */
export interface Coordinates {
    /**
     * 
     * @type {number}
     * @memberof Coordinates
     */
    'longitude': number;
    /**
     * 
     * @type {number}
     * @memberof Coordinates
     */
    'latitude': number;
}
/**
 * 
 * @export
 * @interface Counterparty
 */
export interface Counterparty {
    /**
     * 
     * @type {string}
     * @memberof Counterparty
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Counterparty
     */
    'id'?: string;
    /**
     * 
     * @type {CounterpartyAttributes}
     * @memberof Counterparty
     */
    'attributes'?: CounterpartyAttributes;
    /**
     * 
     * @type {CounterpartyRelationships}
     * @memberof Counterparty
     */
    'relationships'?: CounterpartyRelationships;
}
/**
 * 
 * @export
 * @interface CounterpartyAccountRelationship
 */
export interface CounterpartyAccountRelationship {
    /**
     * 
     * @type {CounterpartyAccountRelationshipData}
     * @memberof CounterpartyAccountRelationship
     */
    'data': CounterpartyAccountRelationshipData;
}
/**
 * 
 * @export
 * @interface CounterpartyAccountRelationshipData
 */
export interface CounterpartyAccountRelationshipData {
    /**
     * 
     * @type {string}
     * @memberof CounterpartyAccountRelationshipData
     */
    'type': CounterpartyAccountRelationshipDataTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CounterpartyAccountRelationshipData
     */
    'id': string;
}

export const CounterpartyAccountRelationshipDataTypeEnum = {
    Account: 'account',
    DepositAccount: 'depositAccount'
} as const;

export type CounterpartyAccountRelationshipDataTypeEnum = typeof CounterpartyAccountRelationshipDataTypeEnum[keyof typeof CounterpartyAccountRelationshipDataTypeEnum];

/**
 * 
 * @export
 * @interface CounterpartyAttributes
 */
export interface CounterpartyAttributes {
    /**
     * 
     * @type {string}
     * @memberof CounterpartyAttributes
     */
    'routingNumber': string;
    /**
     * 
     * @type {string}
     * @memberof CounterpartyAttributes
     */
    'accountNumber': string;
    /**
     * 
     * @type {string}
     * @memberof CounterpartyAttributes
     */
    'accountType': CounterpartyAttributesAccountTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CounterpartyAttributes
     */
    'type': CounterpartyAttributesTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CounterpartyAttributes
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CounterpartyAttributes
     */
    'bank'?: string;
    /**
     * 
     * @type {string}
     * @memberof CounterpartyAttributes
     */
    'permissions': CounterpartyAttributesPermissionsEnum;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CounterpartyAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof CounterpartyAttributes
     */
    'createdAt': string;
}

export const CounterpartyAttributesAccountTypeEnum = {
    Checking: 'Checking',
    Savings: 'Savings',
    Loan: 'Loan'
} as const;

export type CounterpartyAttributesAccountTypeEnum = typeof CounterpartyAttributesAccountTypeEnum[keyof typeof CounterpartyAttributesAccountTypeEnum];
export const CounterpartyAttributesTypeEnum = {
    Business: 'Business',
    Person: 'Person',
    Unknown: 'Unknown'
} as const;

export type CounterpartyAttributesTypeEnum = typeof CounterpartyAttributesTypeEnum[keyof typeof CounterpartyAttributesTypeEnum];
export const CounterpartyAttributesPermissionsEnum = {
    CreditOnly: 'CreditOnly',
    DebitOnly: 'DebitOnly',
    CreditAndDebit: 'CreditAndDebit'
} as const;

export type CounterpartyAttributesPermissionsEnum = typeof CounterpartyAttributesPermissionsEnum[keyof typeof CounterpartyAttributesPermissionsEnum];

/**
 * 
 * @export
 * @interface CounterpartyBalance
 */
export interface CounterpartyBalance {
    /**
     * 
     * @type {string}
     * @memberof CounterpartyBalance
     */
    'type': CounterpartyBalanceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CounterpartyBalance
     */
    'id': string;
    /**
     * 
     * @type {CounterpartyBalanceAttributes}
     * @memberof CounterpartyBalance
     */
    'attributes'?: CounterpartyBalanceAttributes;
    /**
     * 
     * @type {CounterpartyBalanceRelationships}
     * @memberof CounterpartyBalance
     */
    'relationships': CounterpartyBalanceRelationships;
}

export const CounterpartyBalanceTypeEnum = {
    CounterpartyBalance: 'counterpartyBalance'
} as const;

export type CounterpartyBalanceTypeEnum = typeof CounterpartyBalanceTypeEnum[keyof typeof CounterpartyBalanceTypeEnum];

/**
 * 
 * @export
 * @interface CounterpartyBalanceAttributes
 */
export interface CounterpartyBalanceAttributes {
    /**
     * 
     * @type {number}
     * @memberof CounterpartyBalanceAttributes
     */
    'balance': number;
    /**
     * 
     * @type {number}
     * @memberof CounterpartyBalanceAttributes
     */
    'available'?: number;
}
/**
 * 
 * @export
 * @interface CounterpartyBalanceRelationships
 */
export interface CounterpartyBalanceRelationships {
    /**
     * 
     * @type {CounterpartyRelationship}
     * @memberof CounterpartyBalanceRelationships
     */
    'counterparty': CounterpartyRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof CounterpartyBalanceRelationships
     */
    'customer': CustomerRelationship;
}
/**
 * 
 * @export
 * @interface CounterpartyCustomerRelationship
 */
export interface CounterpartyCustomerRelationship {
    /**
     * 
     * @type {CounterpartyCustomerRelationshipData}
     * @memberof CounterpartyCustomerRelationship
     */
    'data': CounterpartyCustomerRelationshipData;
}
/**
 * 
 * @export
 * @interface CounterpartyCustomerRelationshipData
 */
export interface CounterpartyCustomerRelationshipData {
    /**
     * 
     * @type {string}
     * @memberof CounterpartyCustomerRelationshipData
     */
    'type': CounterpartyCustomerRelationshipDataTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CounterpartyCustomerRelationshipData
     */
    'id': string;
}

export const CounterpartyCustomerRelationshipDataTypeEnum = {
    Customer: 'customer',
    BusinessCustomer: 'businessCustomer',
    IndividualCustomer: 'individualCustomer'
} as const;

export type CounterpartyCustomerRelationshipDataTypeEnum = typeof CounterpartyCustomerRelationshipDataTypeEnum[keyof typeof CounterpartyCustomerRelationshipDataTypeEnum];

/**
 * 
 * @export
 * @interface CounterpartyRelationship
 */
export interface CounterpartyRelationship {
    /**
     * 
     * @type {CounterpartyRelationshipData}
     * @memberof CounterpartyRelationship
     */
    'data': CounterpartyRelationshipData;
}
/**
 * 
 * @export
 * @interface CounterpartyRelationshipData
 */
export interface CounterpartyRelationshipData {
    /**
     * 
     * @type {string}
     * @memberof CounterpartyRelationshipData
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof CounterpartyRelationshipData
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface CounterpartyRelationships
 */
export interface CounterpartyRelationships {
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof CounterpartyRelationships
     */
    'customer': CustomerRelationship;
}
/**
 * 
 * @export
 * @interface CreateAccountRequest
 */
export interface CreateAccountRequest {
    /**
     * 
     * @type {CreateAccountRequestData}
     * @memberof CreateAccountRequest
     */
    'data': CreateAccountRequestData;
}
/**
 * @type CreateAccountRequestData
 * @export
 */
export type CreateAccountRequestData = CreateCreditAccount | CreateDepositAccount;

/**
 * 
 * @export
 * @interface CreateAchCounterparty
 */
export interface CreateAchCounterparty {
    /**
     * 
     * @type {string}
     * @memberof CreateAchCounterparty
     */
    'type': string;
    /**
     * 
     * @type {CreateAchCounterpartyAttributes}
     * @memberof CreateAchCounterparty
     */
    'attributes': CreateAchCounterpartyAttributes;
    /**
     * 
     * @type {CreateCounterpartyRelationships}
     * @memberof CreateAchCounterparty
     */
    'relationships': CreateCounterpartyRelationships;
}
/**
 * 
 * @export
 * @interface CreateAchCounterpartyAttributes
 */
export interface CreateAchCounterpartyAttributes {
    /**
     * 
     * @type {string}
     * @memberof CreateAchCounterpartyAttributes
     */
    'routingNumber': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAchCounterpartyAttributes
     */
    'accountNumber': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAchCounterpartyAttributes
     */
    'accountType': CreateAchCounterpartyAttributesAccountTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateAchCounterpartyAttributes
     */
    'permissions'?: CreateAchCounterpartyAttributesPermissionsEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateAchCounterpartyAttributes
     */
    'type': CreateAchCounterpartyAttributesTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateAchCounterpartyAttributes
     */
    'name': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateAchCounterpartyAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof CreateAchCounterpartyAttributes
     */
    'idempotencyKey'?: string;
}

export const CreateAchCounterpartyAttributesAccountTypeEnum = {
    Checking: 'Checking',
    Savings: 'Savings',
    Loan: 'Loan'
} as const;

export type CreateAchCounterpartyAttributesAccountTypeEnum = typeof CreateAchCounterpartyAttributesAccountTypeEnum[keyof typeof CreateAchCounterpartyAttributesAccountTypeEnum];
export const CreateAchCounterpartyAttributesPermissionsEnum = {
    CreditOnly: 'CreditOnly',
    DebitOnly: 'DebitOnly',
    CreditAndDebit: 'CreditAndDebit'
} as const;

export type CreateAchCounterpartyAttributesPermissionsEnum = typeof CreateAchCounterpartyAttributesPermissionsEnum[keyof typeof CreateAchCounterpartyAttributesPermissionsEnum];
export const CreateAchCounterpartyAttributesTypeEnum = {
    Business: 'Business',
    Person: 'Person',
    Unknown: 'Unknown'
} as const;

export type CreateAchCounterpartyAttributesTypeEnum = typeof CreateAchCounterpartyAttributesTypeEnum[keyof typeof CreateAchCounterpartyAttributesTypeEnum];

/**
 * 
 * @export
 * @interface CreateAchPayment
 */
export interface CreateAchPayment {
    /**
     * 
     * @type {string}
     * @memberof CreateAchPayment
     */
    'type'?: CreateAchPaymentTypeEnum;
    /**
     * 
     * @type {CreateAchPaymentAttributes}
     * @memberof CreateAchPayment
     */
    'attributes': CreateAchPaymentAttributes;
    /**
     * 
     * @type {CreateAchPaymentRelationships}
     * @memberof CreateAchPayment
     */
    'relationships': CreateAchPaymentRelationships;
}

export const CreateAchPaymentTypeEnum = {
    AchPayment: 'achPayment'
} as const;

export type CreateAchPaymentTypeEnum = typeof CreateAchPaymentTypeEnum[keyof typeof CreateAchPaymentTypeEnum];

/**
 * 
 * @export
 * @interface CreateAchPaymentAttributes
 */
export interface CreateAchPaymentAttributes {
    /**
     * 
     * @type {number}
     * @memberof CreateAchPaymentAttributes
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof CreateAchPaymentAttributes
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAchPaymentAttributes
     */
    'addenda'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAchPaymentAttributes
     */
    'direction': CreateAchPaymentAttributesDirectionEnum;
    /**
     * 
     * @type {PaymentCounterparty}
     * @memberof CreateAchPaymentAttributes
     */
    'counterparty': PaymentCounterparty;
    /**
     * 
     * @type {string}
     * @memberof CreateAchPaymentAttributes
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAchPaymentAttributes
     */
    'sameDay'?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateAchPaymentAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof CreateAchPaymentAttributes
     */
    'secCode'?: CreateAchPaymentAttributesSecCodeEnum;
}

export const CreateAchPaymentAttributesDirectionEnum = {
    Debit: 'Debit',
    Credit: 'Credit'
} as const;

export type CreateAchPaymentAttributesDirectionEnum = typeof CreateAchPaymentAttributesDirectionEnum[keyof typeof CreateAchPaymentAttributesDirectionEnum];
export const CreateAchPaymentAttributesSecCodeEnum = {
    Web: 'WEB',
    Ccd: 'CCD',
    Ppd: 'PPD'
} as const;

export type CreateAchPaymentAttributesSecCodeEnum = typeof CreateAchPaymentAttributesSecCodeEnum[keyof typeof CreateAchPaymentAttributesSecCodeEnum];

/**
 * 
 * @export
 * @interface CreateAchPaymentCounterparty
 */
export interface CreateAchPaymentCounterparty {
    /**
     * 
     * @type {string}
     * @memberof CreateAchPaymentCounterparty
     */
    'type'?: CreateAchPaymentCounterpartyTypeEnum;
    /**
     * 
     * @type {CreateAchPaymentCounterpartyAttributes}
     * @memberof CreateAchPaymentCounterparty
     */
    'attributes': CreateAchPaymentCounterpartyAttributes;
    /**
     * 
     * @type {CreateAchPaymentCounterpartyRelationships}
     * @memberof CreateAchPaymentCounterparty
     */
    'relationships': CreateAchPaymentCounterpartyRelationships;
}

export const CreateAchPaymentCounterpartyTypeEnum = {
    AchPayment: 'achPayment'
} as const;

export type CreateAchPaymentCounterpartyTypeEnum = typeof CreateAchPaymentCounterpartyTypeEnum[keyof typeof CreateAchPaymentCounterpartyTypeEnum];

/**
 * 
 * @export
 * @interface CreateAchPaymentCounterpartyAttributes
 */
export interface CreateAchPaymentCounterpartyAttributes {
    /**
     * 
     * @type {number}
     * @memberof CreateAchPaymentCounterpartyAttributes
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof CreateAchPaymentCounterpartyAttributes
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAchPaymentCounterpartyAttributes
     */
    'addenda'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAchPaymentCounterpartyAttributes
     */
    'direction': CreateAchPaymentCounterpartyAttributesDirectionEnum;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAchPaymentCounterpartyAttributes
     */
    'sameDay'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateAchPaymentCounterpartyAttributes
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateAchPaymentCounterpartyAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof CreateAchPaymentCounterpartyAttributes
     */
    'verifyCounterpartyBalance'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateAchPaymentCounterpartyAttributes
     */
    'secCode'?: CreateAchPaymentCounterpartyAttributesSecCodeEnum;
}

export const CreateAchPaymentCounterpartyAttributesDirectionEnum = {
    Debit: 'Debit',
    Credit: 'Credit'
} as const;

export type CreateAchPaymentCounterpartyAttributesDirectionEnum = typeof CreateAchPaymentCounterpartyAttributesDirectionEnum[keyof typeof CreateAchPaymentCounterpartyAttributesDirectionEnum];
export const CreateAchPaymentCounterpartyAttributesSecCodeEnum = {
    Web: 'WEB',
    Ccd: 'CCD',
    Ppd: 'PPD'
} as const;

export type CreateAchPaymentCounterpartyAttributesSecCodeEnum = typeof CreateAchPaymentCounterpartyAttributesSecCodeEnum[keyof typeof CreateAchPaymentCounterpartyAttributesSecCodeEnum];

/**
 * 
 * @export
 * @interface CreateAchPaymentCounterpartyRelationships
 */
export interface CreateAchPaymentCounterpartyRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof CreateAchPaymentCounterpartyRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CounterpartyRelationship}
     * @memberof CreateAchPaymentCounterpartyRelationships
     */
    'counterparty': CounterpartyRelationship;
}
/**
 * 
 * @export
 * @interface CreateAchPaymentPlaid
 */
export interface CreateAchPaymentPlaid {
    /**
     * 
     * @type {string}
     * @memberof CreateAchPaymentPlaid
     */
    'type'?: CreateAchPaymentPlaidTypeEnum;
    /**
     * 
     * @type {CreateAchPaymentPlaidAttributes}
     * @memberof CreateAchPaymentPlaid
     */
    'attributes': CreateAchPaymentPlaidAttributes;
    /**
     * 
     * @type {CreateAchPaymentPlaidRelationships}
     * @memberof CreateAchPaymentPlaid
     */
    'relationships': CreateAchPaymentPlaidRelationships;
}

export const CreateAchPaymentPlaidTypeEnum = {
    AchPayment: 'achPayment'
} as const;

export type CreateAchPaymentPlaidTypeEnum = typeof CreateAchPaymentPlaidTypeEnum[keyof typeof CreateAchPaymentPlaidTypeEnum];

/**
 * 
 * @export
 * @interface CreateAchPaymentPlaidAttributes
 */
export interface CreateAchPaymentPlaidAttributes {
    /**
     * 
     * @type {number}
     * @memberof CreateAchPaymentPlaidAttributes
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof CreateAchPaymentPlaidAttributes
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAchPaymentPlaidAttributes
     */
    'addenda'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAchPaymentPlaidAttributes
     */
    'direction': CreateAchPaymentPlaidAttributesDirectionEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateAchPaymentPlaidAttributes
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateAchPaymentPlaidAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof CreateAchPaymentPlaidAttributes
     */
    'plaidProcessorToken': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAchPaymentPlaidAttributes
     */
    'counterpartyName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAchPaymentPlaidAttributes
     */
    'sameDay'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAchPaymentPlaidAttributes
     */
    'verifyCounterpartyBalance'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateAchPaymentPlaidAttributes
     */
    'secCode'?: CreateAchPaymentPlaidAttributesSecCodeEnum;
}

export const CreateAchPaymentPlaidAttributesDirectionEnum = {
    Debit: 'Debit',
    Credit: 'Credit'
} as const;

export type CreateAchPaymentPlaidAttributesDirectionEnum = typeof CreateAchPaymentPlaidAttributesDirectionEnum[keyof typeof CreateAchPaymentPlaidAttributesDirectionEnum];
export const CreateAchPaymentPlaidAttributesSecCodeEnum = {
    Web: 'WEB',
    Ccd: 'CCD',
    Ppd: 'PPD'
} as const;

export type CreateAchPaymentPlaidAttributesSecCodeEnum = typeof CreateAchPaymentPlaidAttributesSecCodeEnum[keyof typeof CreateAchPaymentPlaidAttributesSecCodeEnum];

/**
 * 
 * @export
 * @interface CreateAchPaymentPlaidRelationships
 */
export interface CreateAchPaymentPlaidRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof CreateAchPaymentPlaidRelationships
     */
    'account': AccountRelationship;
}
/**
 * 
 * @export
 * @interface CreateAchPaymentRelationships
 */
export interface CreateAchPaymentRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof CreateAchPaymentRelationships
     */
    'account': AccountRelationship;
}
/**
 * 
 * @export
 * @interface CreateAchRepayment
 */
export interface CreateAchRepayment {
    /**
     * 
     * @type {string}
     * @memberof CreateAchRepayment
     */
    'type': CreateAchRepaymentTypeEnum;
    /**
     * 
     * @type {CreateAchRepaymentAttributes}
     * @memberof CreateAchRepayment
     */
    'attributes': CreateAchRepaymentAttributes;
    /**
     * 
     * @type {CreateAchRepaymentRelationships}
     * @memberof CreateAchRepayment
     */
    'relationships': CreateAchRepaymentRelationships;
}

export const CreateAchRepaymentTypeEnum = {
    AchRepayment: 'achRepayment'
} as const;

export type CreateAchRepaymentTypeEnum = typeof CreateAchRepaymentTypeEnum[keyof typeof CreateAchRepaymentTypeEnum];

/**
 * 
 * @export
 * @interface CreateAchRepaymentAttributes
 */
export interface CreateAchRepaymentAttributes {
    /**
     * 
     * @type {string}
     * @memberof CreateAchRepaymentAttributes
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof CreateAchRepaymentAttributes
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof CreateAchRepaymentAttributes
     */
    'addenda'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAchRepaymentAttributes
     */
    'sameDay'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateAchRepaymentAttributes
     */
    'secCode'?: string;
}
/**
 * 
 * @export
 * @interface CreateAchRepaymentRelationships
 */
export interface CreateAchRepaymentRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof CreateAchRepaymentRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CreditAccountRelationship}
     * @memberof CreateAchRepaymentRelationships
     */
    'creditAccount': CreditAccountRelationship;
    /**
     * 
     * @type {CounterpartyRelationship}
     * @memberof CreateAchRepaymentRelationships
     */
    'counterparty': CounterpartyRelationship;
}
/**
 * 
 * @export
 * @interface CreateAchStopPayment
 */
export interface CreateAchStopPayment {
    /**
     * 
     * @type {string}
     * @memberof CreateAchStopPayment
     */
    'type': CreateAchStopPaymentTypeEnum;
    /**
     * 
     * @type {CreateAchStopPaymentAttributes}
     * @memberof CreateAchStopPayment
     */
    'attributes': CreateAchStopPaymentAttributes;
    /**
     * 
     * @type {CreateAchStopPaymentRelationships}
     * @memberof CreateAchStopPayment
     */
    'relationships': CreateAchStopPaymentRelationships;
}

export const CreateAchStopPaymentTypeEnum = {
    AchStopPayment: 'achStopPayment'
} as const;

export type CreateAchStopPaymentTypeEnum = typeof CreateAchStopPaymentTypeEnum[keyof typeof CreateAchStopPaymentTypeEnum];

/**
 * 
 * @export
 * @interface CreateAchStopPaymentAttributes
 */
export interface CreateAchStopPaymentAttributes {
    /**
     * 
     * @type {number}
     * @memberof CreateAchStopPaymentAttributes
     */
    'minAmount'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateAchStopPaymentAttributes
     */
    'originatorName'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateAchStopPaymentAttributes
     */
    'direction': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAchStopPaymentAttributes
     */
    'expiration'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAchStopPaymentAttributes
     */
    'isMultiUse'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateAchStopPaymentAttributes
     */
    'description': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateAchStopPaymentAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof CreateAchStopPaymentAttributes
     */
    'idempotencyKey'?: string;
}
/**
 * 
 * @export
 * @interface CreateAchStopPaymentRelationships
 */
export interface CreateAchStopPaymentRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof CreateAchStopPaymentRelationships
     */
    'account': AccountRelationship;
}
/**
 * 
 * @export
 * @interface CreateApiTokenRequest
 */
export interface CreateApiTokenRequest {
    /**
     * 
     * @type {CreateApiTokenRequestData}
     * @memberof CreateApiTokenRequest
     */
    'data'?: CreateApiTokenRequestData;
}
/**
 * 
 * @export
 * @interface CreateApiTokenRequestData
 */
export interface CreateApiTokenRequestData {
    /**
     * 
     * @type {string}
     * @memberof CreateApiTokenRequestData
     */
    'type': CreateApiTokenRequestDataTypeEnum;
    /**
     * 
     * @type {CreateApiTokenRequestDataAttributes}
     * @memberof CreateApiTokenRequestData
     */
    'attributes': CreateApiTokenRequestDataAttributes;
}

export const CreateApiTokenRequestDataTypeEnum = {
    ApiToken: 'apiToken'
} as const;

export type CreateApiTokenRequestDataTypeEnum = typeof CreateApiTokenRequestDataTypeEnum[keyof typeof CreateApiTokenRequestDataTypeEnum];

/**
 * 
 * @export
 * @interface CreateApiTokenRequestDataAttributes
 */
export interface CreateApiTokenRequestDataAttributes {
    /**
     * 
     * @type {string}
     * @memberof CreateApiTokenRequestDataAttributes
     */
    'scope'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateApiTokenRequestDataAttributes
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CreateApiTokenRequestDataAttributes
     */
    'expiration': string;
    /**
     * 
     * @type {string}
     * @memberof CreateApiTokenRequestDataAttributes
     */
    'sourceIp'?: string;
    /**
     * 
     * @type {Array<CreateApiTokenRequestDataAttributesResourcesInner>}
     * @memberof CreateApiTokenRequestDataAttributes
     */
    'resources'?: Array<CreateApiTokenRequestDataAttributesResourcesInner>;
}
/**
 * 
 * @export
 * @interface CreateApiTokenRequestDataAttributesResourcesInner
 */
export interface CreateApiTokenRequestDataAttributesResourcesInner {
    /**
     * 
     * @type {string}
     * @memberof CreateApiTokenRequestDataAttributesResourcesInner
     */
    'type'?: CreateApiTokenRequestDataAttributesResourcesInnerTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateApiTokenRequestDataAttributesResourcesInner
     */
    'ids'?: Array<string>;
}

export const CreateApiTokenRequestDataAttributesResourcesInnerTypeEnum = {
    Card: 'card',
    Account: 'account'
} as const;

export type CreateApiTokenRequestDataAttributesResourcesInnerTypeEnum = typeof CreateApiTokenRequestDataAttributesResourcesInnerTypeEnum[keyof typeof CreateApiTokenRequestDataAttributesResourcesInnerTypeEnum];

/**
 * 
 * @export
 * @interface CreateApplicationFormRequest
 */
export interface CreateApplicationFormRequest {
    /**
     * 
     * @type {CreateApplicationFormRequestData}
     * @memberof CreateApplicationFormRequest
     */
    'data'?: CreateApplicationFormRequestData;
}
/**
 * 
 * @export
 * @interface CreateApplicationFormRequestData
 */
export interface CreateApplicationFormRequestData {
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationFormRequestData
     */
    'type': CreateApplicationFormRequestDataTypeEnum;
    /**
     * 
     * @type {CreateApplicationFormRequestDataAttributes}
     * @memberof CreateApplicationFormRequestData
     */
    'attributes'?: CreateApplicationFormRequestDataAttributes;
    /**
     * 
     * @type {CreateApplicationFormRequestDataRelationships}
     * @memberof CreateApplicationFormRequestData
     */
    'relationships'?: CreateApplicationFormRequestDataRelationships;
}

export const CreateApplicationFormRequestDataTypeEnum = {
    ApplicationForm: 'applicationForm'
} as const;

export type CreateApplicationFormRequestDataTypeEnum = typeof CreateApplicationFormRequestDataTypeEnum[keyof typeof CreateApplicationFormRequestDataTypeEnum];

/**
 * 
 * @export
 * @interface CreateApplicationFormRequestDataAttributes
 */
export interface CreateApplicationFormRequestDataAttributes {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateApplicationFormRequestDataAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {ApplicationFormPrefill}
     * @memberof CreateApplicationFormRequestDataAttributes
     */
    'applicantDetails'?: ApplicationFormPrefill;
    /**
     * 
     * @type {ApplicationFormSettingsOverride}
     * @memberof CreateApplicationFormRequestDataAttributes
     */
    'settingsOverride'?: ApplicationFormSettingsOverride;
    /**
     * 
     * @type {RequireIdVerification}
     * @memberof CreateApplicationFormRequestDataAttributes
     */
    'requireIdVerification'?: RequireIdVerification;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateApplicationFormRequestDataAttributes
     */
    'allowedApplicationTypes'?: Array<CreateApplicationFormRequestDataAttributesAllowedApplicationTypesEnum>;
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationFormRequestDataAttributes
     */
    'lang'?: CreateApplicationFormRequestDataAttributesLangEnum;
    /**
     * 
     * @type {boolean}
     * @memberof CreateApplicationFormRequestDataAttributes
     */
    'hideApplicationProgressTracker'?: boolean;
}

export const CreateApplicationFormRequestDataAttributesAllowedApplicationTypesEnum = {
    Individual: 'Individual',
    Business: 'Business',
    SoleProprietorship: 'SoleProprietorship'
} as const;

export type CreateApplicationFormRequestDataAttributesAllowedApplicationTypesEnum = typeof CreateApplicationFormRequestDataAttributesAllowedApplicationTypesEnum[keyof typeof CreateApplicationFormRequestDataAttributesAllowedApplicationTypesEnum];
export const CreateApplicationFormRequestDataAttributesLangEnum = {
    En: 'en',
    Es: 'es'
} as const;

export type CreateApplicationFormRequestDataAttributesLangEnum = typeof CreateApplicationFormRequestDataAttributesLangEnum[keyof typeof CreateApplicationFormRequestDataAttributesLangEnum];

/**
 * 
 * @export
 * @interface CreateApplicationFormRequestDataRelationships
 */
export interface CreateApplicationFormRequestDataRelationships {
    /**
     * 
     * @type {ApplicationRelationship}
     * @memberof CreateApplicationFormRequestDataRelationships
     */
    'application': ApplicationRelationship;
}
/**
 * 
 * @export
 * @interface CreateApplicationRequest
 */
export interface CreateApplicationRequest {
    /**
     * 
     * @type {CreateApplicationRequestData}
     * @memberof CreateApplicationRequest
     */
    'data': CreateApplicationRequestData;
}
/**
 * @type CreateApplicationRequestData
 * @export
 */
export type CreateApplicationRequestData = CreateBusinessApplication | CreateIndividualApplication | CreateSoleProprietorApplication;

/**
 * 
 * @export
 * @interface CreateBeneficialOwner
 */
export interface CreateBeneficialOwner {
    /**
     * 
     * @type {FullName}
     * @memberof CreateBeneficialOwner
     */
    'fullName': FullName;
    /**
     * 
     * @type {string}
     * @memberof CreateBeneficialOwner
     */
    'email': string;
    /**
     * 
     * @type {Phone}
     * @memberof CreateBeneficialOwner
     */
    'phone': Phone;
    /**
     * 
     * @type {string}
     * @memberof CreateBeneficialOwner
     */
    'ssn'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBeneficialOwner
     */
    'passport'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBeneficialOwner
     */
    'nationality'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBeneficialOwner
     */
    'matriculaConsular'?: string;
    /**
     * 
     * @type {Address}
     * @memberof CreateBeneficialOwner
     */
    'address': Address;
    /**
     * 
     * @type {string}
     * @memberof CreateBeneficialOwner
     */
    'dateOfBirth': string;
    /**
     * 
     * @type {number}
     * @memberof CreateBeneficialOwner
     */
    'percentage'?: number;
    /**
     * 
     * @type {EvaluationParams}
     * @memberof CreateBeneficialOwner
     */
    'EvaluationParams'?: EvaluationParams;
    /**
     * 
     * @type {Occupation}
     * @memberof CreateBeneficialOwner
     */
    'occupation'?: Occupation;
    /**
     * 
     * @type {AnnualIncome}
     * @memberof CreateBeneficialOwner
     */
    'annualIncome'?: AnnualIncome;
    /**
     * 
     * @type {SourceOfIncome}
     * @memberof CreateBeneficialOwner
     */
    'sourceOfIncome'?: SourceOfIncome;
}


/**
 * 
 * @export
 * @interface CreateBookPayment
 */
export interface CreateBookPayment {
    /**
     * 
     * @type {string}
     * @memberof CreateBookPayment
     */
    'type'?: CreateBookPaymentTypeEnum;
    /**
     * 
     * @type {CreateBookPaymentAttributes}
     * @memberof CreateBookPayment
     */
    'attributes': CreateBookPaymentAttributes;
    /**
     * 
     * @type {CreateBookPaymentRelationships}
     * @memberof CreateBookPayment
     */
    'relationships': CreateBookPaymentRelationships;
}

export const CreateBookPaymentTypeEnum = {
    BookPayment: 'bookPayment'
} as const;

export type CreateBookPaymentTypeEnum = typeof CreateBookPaymentTypeEnum[keyof typeof CreateBookPaymentTypeEnum];

/**
 * 
 * @export
 * @interface CreateBookPaymentAttributes
 */
export interface CreateBookPaymentAttributes {
    /**
     * 
     * @type {number}
     * @memberof CreateBookPaymentAttributes
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof CreateBookPaymentAttributes
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CreateBookPaymentAttributes
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateBookPaymentAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof CreateBookPaymentAttributes
     */
    'transactionSummaryOverride'?: string;
}
/**
 * 
 * @export
 * @interface CreateBookPaymentRelationships
 */
export interface CreateBookPaymentRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof CreateBookPaymentRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CounterpartyAccountRelationship}
     * @memberof CreateBookPaymentRelationships
     */
    'counterpartyAccount': CounterpartyAccountRelationship;
}
/**
 * 
 * @export
 * @interface CreateBookRepayment
 */
export interface CreateBookRepayment {
    /**
     * 
     * @type {string}
     * @memberof CreateBookRepayment
     */
    'type': CreateBookRepaymentTypeEnum;
    /**
     * 
     * @type {CreateBookRepaymentAttributes}
     * @memberof CreateBookRepayment
     */
    'attributes': CreateBookRepaymentAttributes;
    /**
     * 
     * @type {CreateBookRepaymentRelationships}
     * @memberof CreateBookRepayment
     */
    'relationships': CreateBookRepaymentRelationships;
}

export const CreateBookRepaymentTypeEnum = {
    BookRepayment: 'bookRepayment'
} as const;

export type CreateBookRepaymentTypeEnum = typeof CreateBookRepaymentTypeEnum[keyof typeof CreateBookRepaymentTypeEnum];

/**
 * 
 * @export
 * @interface CreateBookRepaymentAttributes
 */
export interface CreateBookRepaymentAttributes {
    /**
     * 
     * @type {string}
     * @memberof CreateBookRepaymentAttributes
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof CreateBookRepaymentAttributes
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof CreateBookRepaymentAttributes
     */
    'transactionSummaryOverride'?: string;
}
/**
 * 
 * @export
 * @interface CreateBookRepaymentRelationships
 */
export interface CreateBookRepaymentRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof CreateBookRepaymentRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CreditAccountRelationship}
     * @memberof CreateBookRepaymentRelationships
     */
    'creditAccount': CreditAccountRelationship;
    /**
     * 
     * @type {CounterpartyAccountRelationship}
     * @memberof CreateBookRepaymentRelationships
     */
    'counterpartyAccount': CounterpartyAccountRelationship;
}
/**
 * 
 * @export
 * @interface CreateBusinessApplication
 */
export interface CreateBusinessApplication {
    /**
     * 
     * @type {string}
     * @memberof CreateBusinessApplication
     */
    'type': CreateBusinessApplicationTypeEnum;
    /**
     * 
     * @type {CreateBusinessApplicationAttributes}
     * @memberof CreateBusinessApplication
     */
    'attributes': CreateBusinessApplicationAttributes;
}

export const CreateBusinessApplicationTypeEnum = {
    BusinessApplication: 'businessApplication'
} as const;

export type CreateBusinessApplicationTypeEnum = typeof CreateBusinessApplicationTypeEnum[keyof typeof CreateBusinessApplicationTypeEnum];

/**
 * 
 * @export
 * @interface CreateBusinessApplicationAttributes
 */
export interface CreateBusinessApplicationAttributes {
    /**
     * 
     * @type {string}
     * @memberof CreateBusinessApplicationAttributes
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateBusinessApplicationAttributes
     */
    'dba'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBusinessApplicationAttributes
     */
    'ein': string;
    /**
     * 
     * @type {EntityType}
     * @memberof CreateBusinessApplicationAttributes
     */
    'entityType': EntityType;
    /**
     * 
     * @type {string}
     * @memberof CreateBusinessApplicationAttributes
     */
    'dateOfIncorporation'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBusinessApplicationAttributes
     */
    'stateOfIncorporation': string;
    /**
     * 
     * @type {string}
     * @memberof CreateBusinessApplicationAttributes
     */
    'purpose'?: string;
    /**
     * 
     * @type {Phone}
     * @memberof CreateBusinessApplicationAttributes
     */
    'phone': Phone;
    /**
     * 
     * @type {Address}
     * @memberof CreateBusinessApplicationAttributes
     */
    'address': Address;
    /**
     * 
     * @type {Contact}
     * @memberof CreateBusinessApplicationAttributes
     */
    'contact': Contact;
    /**
     * 
     * @type {CreateOfficer}
     * @memberof CreateBusinessApplicationAttributes
     */
    'officer': CreateOfficer;
    /**
     * 
     * @type {string}
     * @memberof CreateBusinessApplicationAttributes
     */
    'ip'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBusinessApplicationAttributes
     */
    'website'?: string;
    /**
     * 
     * @type {Array<CreateBeneficialOwner>}
     * @memberof CreateBusinessApplicationAttributes
     */
    'beneficialOwners': Array<CreateBeneficialOwner>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateBusinessApplicationAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof CreateBusinessApplicationAttributes
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {Array<DeviceFingerprint>}
     * @memberof CreateBusinessApplicationAttributes
     */
    'deviceFingerprints'?: Array<DeviceFingerprint>;
    /**
     * 
     * @type {Industry}
     * @memberof CreateBusinessApplicationAttributes
     */
    'industry'?: Industry;
    /**
     * 
     * @type {BusinessAnnualRevenue}
     * @memberof CreateBusinessApplicationAttributes
     */
    'annualRevenue'?: BusinessAnnualRevenue;
    /**
     * 
     * @type {BusinessNumberOfEmployees}
     * @memberof CreateBusinessApplicationAttributes
     */
    'numberOfEmployees'?: BusinessNumberOfEmployees;
    /**
     * 
     * @type {CashFlow}
     * @memberof CreateBusinessApplicationAttributes
     */
    'cashFlow'?: CashFlow;
    /**
     * 
     * @type {string}
     * @memberof CreateBusinessApplicationAttributes
     */
    'yearOfIncorporation'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateBusinessApplicationAttributes
     */
    'countriesOfOperation'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateBusinessApplicationAttributes
     */
    'stockSymbol'?: string;
    /**
     * 
     * @type {BusinessVertical}
     * @memberof CreateBusinessApplicationAttributes
     */
    'businessVertical'?: BusinessVertical;
}


/**
 * 
 * @export
 * @interface CreateBusinessCreditCardRequest
 */
export interface CreateBusinessCreditCardRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateBusinessCreditCardRequest
     */
    'type': CreateBusinessCreditCardRequestTypeEnum;
    /**
     * 
     * @type {CreateBusinessDebitCardRequestAttributes}
     * @memberof CreateBusinessCreditCardRequest
     */
    'attributes': CreateBusinessDebitCardRequestAttributes;
    /**
     * 
     * @type {CreateCardRelationships}
     * @memberof CreateBusinessCreditCardRequest
     */
    'relationships': CreateCardRelationships;
}

export const CreateBusinessCreditCardRequestTypeEnum = {
    BusinessCreditCard: 'businessCreditCard'
} as const;

export type CreateBusinessCreditCardRequestTypeEnum = typeof CreateBusinessCreditCardRequestTypeEnum[keyof typeof CreateBusinessCreditCardRequestTypeEnum];

/**
 * 
 * @export
 * @interface CreateBusinessDebitCardRequest
 */
export interface CreateBusinessDebitCardRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateBusinessDebitCardRequest
     */
    'type': CreateBusinessDebitCardRequestTypeEnum;
    /**
     * 
     * @type {CreateBusinessDebitCardRequestAttributes}
     * @memberof CreateBusinessDebitCardRequest
     */
    'attributes': CreateBusinessDebitCardRequestAttributes;
    /**
     * 
     * @type {CreateCardRelationships}
     * @memberof CreateBusinessDebitCardRequest
     */
    'relationships': CreateCardRelationships;
}

export const CreateBusinessDebitCardRequestTypeEnum = {
    BusinessDebitCard: 'businessDebitCard'
} as const;

export type CreateBusinessDebitCardRequestTypeEnum = typeof CreateBusinessDebitCardRequestTypeEnum[keyof typeof CreateBusinessDebitCardRequestTypeEnum];

/**
 * 
 * @export
 * @interface CreateBusinessDebitCardRequestAttributes
 */
export interface CreateBusinessDebitCardRequestAttributes {
    /**
     * 
     * @type {Address}
     * @memberof CreateBusinessDebitCardRequestAttributes
     */
    'shippingAddress'?: Address;
    /**
     * 
     * @type {Address}
     * @memberof CreateBusinessDebitCardRequestAttributes
     */
    'address': Address;
    /**
     * 
     * @type {FullName}
     * @memberof CreateBusinessDebitCardRequestAttributes
     */
    'fullName': FullName;
    /**
     * 
     * @type {Phone}
     * @memberof CreateBusinessDebitCardRequestAttributes
     */
    'phone': Phone;
    /**
     * 
     * @type {string}
     * @memberof CreateBusinessDebitCardRequestAttributes
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CreateBusinessDebitCardRequestAttributes
     */
    'dateOfBirth': string;
    /**
     * 
     * @type {string}
     * @memberof CreateBusinessDebitCardRequestAttributes
     */
    'nationality'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBusinessDebitCardRequestAttributes
     */
    'ssn'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBusinessDebitCardRequestAttributes
     */
    'passport'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBusinessDebitCardRequestAttributes
     */
    'design'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBusinessDebitCardRequestAttributes
     */
    'additionalEmbossedText'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateBusinessDebitCardRequestAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {CardLevelLimits}
     * @memberof CreateBusinessDebitCardRequestAttributes
     */
    'limits'?: CardLevelLimits;
    /**
     * 
     * @type {string}
     * @memberof CreateBusinessDebitCardRequestAttributes
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateBusinessDebitCardRequestAttributes
     */
    'activeForOnlineUse'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateBusinessDebitCardRequestAttributes
     */
    'printOnlyBusinessName'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateBusinessDebitCardRequestAttributes
     */
    'expiryDate'?: string;
}
/**
 * 
 * @export
 * @interface CreateBusinessVirtualCreditCardRequest
 */
export interface CreateBusinessVirtualCreditCardRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateBusinessVirtualCreditCardRequest
     */
    'type': CreateBusinessVirtualCreditCardRequestTypeEnum;
    /**
     * 
     * @type {CreateBusinessVirtualDebitCardRequestAttributes}
     * @memberof CreateBusinessVirtualCreditCardRequest
     */
    'attributes': CreateBusinessVirtualDebitCardRequestAttributes;
    /**
     * 
     * @type {CreateCardRelationships}
     * @memberof CreateBusinessVirtualCreditCardRequest
     */
    'relationships': CreateCardRelationships;
}

export const CreateBusinessVirtualCreditCardRequestTypeEnum = {
    BusinessVirtualCreditCard: 'businessVirtualCreditCard'
} as const;

export type CreateBusinessVirtualCreditCardRequestTypeEnum = typeof CreateBusinessVirtualCreditCardRequestTypeEnum[keyof typeof CreateBusinessVirtualCreditCardRequestTypeEnum];

/**
 * 
 * @export
 * @interface CreateBusinessVirtualDebitCardRequest
 */
export interface CreateBusinessVirtualDebitCardRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateBusinessVirtualDebitCardRequest
     */
    'type': CreateBusinessVirtualDebitCardRequestTypeEnum;
    /**
     * 
     * @type {CreateBusinessVirtualDebitCardRequestAttributes}
     * @memberof CreateBusinessVirtualDebitCardRequest
     */
    'attributes': CreateBusinessVirtualDebitCardRequestAttributes;
    /**
     * 
     * @type {CreateCardRelationships}
     * @memberof CreateBusinessVirtualDebitCardRequest
     */
    'relationships': CreateCardRelationships;
}

export const CreateBusinessVirtualDebitCardRequestTypeEnum = {
    BusinessVirtualDebitCard: 'businessVirtualDebitCard'
} as const;

export type CreateBusinessVirtualDebitCardRequestTypeEnum = typeof CreateBusinessVirtualDebitCardRequestTypeEnum[keyof typeof CreateBusinessVirtualDebitCardRequestTypeEnum];

/**
 * 
 * @export
 * @interface CreateBusinessVirtualDebitCardRequestAttributes
 */
export interface CreateBusinessVirtualDebitCardRequestAttributes {
    /**
     * 
     * @type {Address}
     * @memberof CreateBusinessVirtualDebitCardRequestAttributes
     */
    'address': Address;
    /**
     * 
     * @type {FullName}
     * @memberof CreateBusinessVirtualDebitCardRequestAttributes
     */
    'fullName': FullName;
    /**
     * 
     * @type {Phone}
     * @memberof CreateBusinessVirtualDebitCardRequestAttributes
     */
    'phone': Phone;
    /**
     * 
     * @type {string}
     * @memberof CreateBusinessVirtualDebitCardRequestAttributes
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CreateBusinessVirtualDebitCardRequestAttributes
     */
    'dateOfBirth': string;
    /**
     * 
     * @type {string}
     * @memberof CreateBusinessVirtualDebitCardRequestAttributes
     */
    'nationality'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBusinessVirtualDebitCardRequestAttributes
     */
    'ssn'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBusinessVirtualDebitCardRequestAttributes
     */
    'passport'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateBusinessVirtualDebitCardRequestAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {CardLevelLimits}
     * @memberof CreateBusinessVirtualDebitCardRequestAttributes
     */
    'limits'?: CardLevelLimits;
    /**
     * 
     * @type {string}
     * @memberof CreateBusinessVirtualDebitCardRequestAttributes
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBusinessVirtualDebitCardRequestAttributes
     */
    'expiryDate'?: string;
}
/**
 * 
 * @export
 * @interface CreateCapitalPartnerAchRepayment
 */
export interface CreateCapitalPartnerAchRepayment {
    /**
     * 
     * @type {string}
     * @memberof CreateCapitalPartnerAchRepayment
     */
    'type': CreateCapitalPartnerAchRepaymentTypeEnum;
    /**
     * 
     * @type {CreateAchRepaymentAttributes}
     * @memberof CreateCapitalPartnerAchRepayment
     */
    'attributes': CreateAchRepaymentAttributes;
    /**
     * 
     * @type {CreateCapitalPartnerAchRepaymentRelationships}
     * @memberof CreateCapitalPartnerAchRepayment
     */
    'relationships': CreateCapitalPartnerAchRepaymentRelationships;
}

export const CreateCapitalPartnerAchRepaymentTypeEnum = {
    CapitalPartnerAchRepayment: 'capitalPartnerAchRepayment'
} as const;

export type CreateCapitalPartnerAchRepaymentTypeEnum = typeof CreateCapitalPartnerAchRepaymentTypeEnum[keyof typeof CreateCapitalPartnerAchRepaymentTypeEnum];

/**
 * 
 * @export
 * @interface CreateCapitalPartnerAchRepaymentRelationships
 */
export interface CreateCapitalPartnerAchRepaymentRelationships {
    /**
     * 
     * @type {CreditAccountRelationship}
     * @memberof CreateCapitalPartnerAchRepaymentRelationships
     */
    'creditAccount': CreditAccountRelationship;
    /**
     * 
     * @type {CounterpartyRelationship}
     * @memberof CreateCapitalPartnerAchRepaymentRelationships
     */
    'counterparty': CounterpartyRelationship;
}
/**
 * 
 * @export
 * @interface CreateCapitalPartnerBookRepayment
 */
export interface CreateCapitalPartnerBookRepayment {
    /**
     * 
     * @type {string}
     * @memberof CreateCapitalPartnerBookRepayment
     */
    'type': CreateCapitalPartnerBookRepaymentTypeEnum;
    /**
     * 
     * @type {CreateBookRepaymentAttributes}
     * @memberof CreateCapitalPartnerBookRepayment
     */
    'attributes': CreateBookRepaymentAttributes;
    /**
     * 
     * @type {CreateCapitalPartnerBookRepaymentRelationships}
     * @memberof CreateCapitalPartnerBookRepayment
     */
    'relationships': CreateCapitalPartnerBookRepaymentRelationships;
}

export const CreateCapitalPartnerBookRepaymentTypeEnum = {
    CapitalPartnerBookRepayment: 'capitalPartnerBookRepayment'
} as const;

export type CreateCapitalPartnerBookRepaymentTypeEnum = typeof CreateCapitalPartnerBookRepaymentTypeEnum[keyof typeof CreateCapitalPartnerBookRepaymentTypeEnum];

/**
 * 
 * @export
 * @interface CreateCapitalPartnerBookRepaymentRelationships
 */
export interface CreateCapitalPartnerBookRepaymentRelationships {
    /**
     * 
     * @type {CreditAccountRelationship}
     * @memberof CreateCapitalPartnerBookRepaymentRelationships
     */
    'creditAccount': CreditAccountRelationship;
    /**
     * 
     * @type {CounterpartyAccountRelationship}
     * @memberof CreateCapitalPartnerBookRepaymentRelationships
     */
    'counterpartyAccount': CounterpartyAccountRelationship;
}
/**
 * 
 * @export
 * @interface CreateCardRelationships
 */
export interface CreateCardRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof CreateCardRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof CreateCardRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {Relationship}
     * @memberof CreateCardRelationships
     */
    'defaultFundingAccount'?: Relationship;
}
/**
 * 
 * @export
 * @interface CreateCardRequest
 */
export interface CreateCardRequest {
    /**
     * 
     * @type {CreateCardRequestData}
     * @memberof CreateCardRequest
     */
    'data'?: CreateCardRequestData;
}
/**
 * @type CreateCardRequestData
 * @export
 */
export type CreateCardRequestData = CreateBusinessCreditCardRequest | CreateBusinessDebitCardRequest | CreateBusinessVirtualCreditCardRequest | CreateBusinessVirtualDebitCardRequest | CreateIndividualDebitCardRequest | CreateIndividualVirtualDebitCardRequest;

/**
 * 
 * @export
 * @interface CreateCheckDepositRelationships
 */
export interface CreateCheckDepositRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof CreateCheckDepositRelationships
     */
    'account': AccountRelationship;
}
/**
 * 
 * @export
 * @interface CreateCheckDepositRequest
 */
export interface CreateCheckDepositRequest {
    /**
     * 
     * @type {CreateCheckDepositRequestData}
     * @memberof CreateCheckDepositRequest
     */
    'data'?: CreateCheckDepositRequestData;
}
/**
 * 
 * @export
 * @interface CreateCheckDepositRequestData
 */
export interface CreateCheckDepositRequestData {
    /**
     * 
     * @type {string}
     * @memberof CreateCheckDepositRequestData
     */
    'type': CreateCheckDepositRequestDataTypeEnum;
    /**
     * 
     * @type {CreateCheckDepositRequestDataAttributes}
     * @memberof CreateCheckDepositRequestData
     */
    'attributes': CreateCheckDepositRequestDataAttributes;
    /**
     * 
     * @type {CreateCheckDepositRelationships}
     * @memberof CreateCheckDepositRequestData
     */
    'relationships': CreateCheckDepositRelationships;
}

export const CreateCheckDepositRequestDataTypeEnum = {
    CheckDeposit: 'checkDeposit'
} as const;

export type CreateCheckDepositRequestDataTypeEnum = typeof CreateCheckDepositRequestDataTypeEnum[keyof typeof CreateCheckDepositRequestDataTypeEnum];

/**
 * 
 * @export
 * @interface CreateCheckDepositRequestDataAttributes
 */
export interface CreateCheckDepositRequestDataAttributes {
    /**
     * 
     * @type {number}
     * @memberof CreateCheckDepositRequestDataAttributes
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof CreateCheckDepositRequestDataAttributes
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCheckDepositRequestDataAttributes
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateCheckDepositRequestDataAttributes
     */
    'tags'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface CreateCheckPaymentRelationships
 */
export interface CreateCheckPaymentRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof CreateCheckPaymentRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof CreateCheckPaymentRelationships
     */
    'customer': CustomerRelationship;
}
/**
 * 
 * @export
 * @interface CreateCheckPaymentRequest
 */
export interface CreateCheckPaymentRequest {
    /**
     * 
     * @type {CreateCheckPaymentRequestData}
     * @memberof CreateCheckPaymentRequest
     */
    'data': CreateCheckPaymentRequestData;
}
/**
 * 
 * @export
 * @interface CreateCheckPaymentRequestData
 */
export interface CreateCheckPaymentRequestData {
    /**
     * 
     * @type {string}
     * @memberof CreateCheckPaymentRequestData
     */
    'type': CreateCheckPaymentRequestDataTypeEnum;
    /**
     * 
     * @type {CreateCheckPaymentRequestDataAttributes}
     * @memberof CreateCheckPaymentRequestData
     */
    'attributes': CreateCheckPaymentRequestDataAttributes;
    /**
     * 
     * @type {CreateCheckPaymentRelationships}
     * @memberof CreateCheckPaymentRequestData
     */
    'relationships': CreateCheckPaymentRelationships;
}

export const CreateCheckPaymentRequestDataTypeEnum = {
    CheckPayment: 'checkPayment'
} as const;

export type CreateCheckPaymentRequestDataTypeEnum = typeof CreateCheckPaymentRequestDataTypeEnum[keyof typeof CreateCheckPaymentRequestDataTypeEnum];

/**
 * 
 * @export
 * @interface CreateCheckPaymentRequestDataAttributes
 */
export interface CreateCheckPaymentRequestDataAttributes {
    /**
     * 
     * @type {CreateCheckPaymentRequestDataAttributesCounterparty}
     * @memberof CreateCheckPaymentRequestDataAttributes
     */
    'counterparty': CreateCheckPaymentRequestDataAttributesCounterparty;
    /**
     * 
     * @type {number}
     * @memberof CreateCheckPaymentRequestDataAttributes
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof CreateCheckPaymentRequestDataAttributes
     */
    'idempotencyKey': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCheckPaymentRequestDataAttributes
     */
    'sendDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCheckPaymentRequestDataAttributes
     */
    'memo'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCheckPaymentRequestDataAttributes
     */
    'description': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateCheckPaymentRequestDataAttributes
     */
    'tags'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface CreateCheckPaymentRequestDataAttributesCounterparty
 */
export interface CreateCheckPaymentRequestDataAttributesCounterparty {
    /**
     * 
     * @type {string}
     * @memberof CreateCheckPaymentRequestDataAttributesCounterparty
     */
    'name': string;
    /**
     * 
     * @type {Address}
     * @memberof CreateCheckPaymentRequestDataAttributesCounterparty
     */
    'address': Address;
    /**
     * 
     * @type {boolean}
     * @memberof CreateCheckPaymentRequestDataAttributesCounterparty
     */
    'counterpartyMoved'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateCheckStopPayment
 */
export interface CreateCheckStopPayment {
    /**
     * 
     * @type {string}
     * @memberof CreateCheckStopPayment
     */
    'type': CreateCheckStopPaymentTypeEnum;
    /**
     * 
     * @type {CreateCheckStopPaymentAttributes}
     * @memberof CreateCheckStopPayment
     */
    'attributes': CreateCheckStopPaymentAttributes;
    /**
     * 
     * @type {CreateCheckStopPaymentRelationships}
     * @memberof CreateCheckStopPayment
     */
    'relationships': CreateCheckStopPaymentRelationships;
}

export const CreateCheckStopPaymentTypeEnum = {
    CheckStopPayment: 'checkStopPayment'
} as const;

export type CreateCheckStopPaymentTypeEnum = typeof CreateCheckStopPaymentTypeEnum[keyof typeof CreateCheckStopPaymentTypeEnum];

/**
 * 
 * @export
 * @interface CreateCheckStopPaymentAttributes
 */
export interface CreateCheckStopPaymentAttributes {
    /**
     * 
     * @type {number}
     * @memberof CreateCheckStopPaymentAttributes
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateCheckStopPaymentAttributes
     */
    'checkNumber': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateCheckStopPaymentAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof CreateCheckStopPaymentAttributes
     */
    'idempotencyKey'?: string;
}
/**
 * 
 * @export
 * @interface CreateCheckStopPaymentRelationships
 */
export interface CreateCheckStopPaymentRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof CreateCheckStopPaymentRelationships
     */
    'account': AccountRelationship;
}
/**
 * 
 * @export
 * @interface CreateCounterpartyRelationships
 */
export interface CreateCounterpartyRelationships {
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof CreateCounterpartyRelationships
     */
    'customer': CustomerRelationship;
}
/**
 * 
 * @export
 * @interface CreateCounterpartyRequest
 */
export interface CreateCounterpartyRequest {
    /**
     * 
     * @type {CreateCounterpartyRequestData}
     * @memberof CreateCounterpartyRequest
     */
    'data'?: CreateCounterpartyRequestData;
}
/**
 * @type CreateCounterpartyRequestData
 * @export
 */
export type CreateCounterpartyRequestData = CreateAchCounterparty | CreatePlaidCounterparty;

/**
 * 
 * @export
 * @interface CreateCreditAccount
 */
export interface CreateCreditAccount {
    /**
     * 
     * @type {string}
     * @memberof CreateCreditAccount
     */
    'type'?: CreateCreditAccountTypeEnum;
    /**
     * 
     * @type {CreateCreditAccountAttributes}
     * @memberof CreateCreditAccount
     */
    'attributes'?: CreateCreditAccountAttributes;
    /**
     * 
     * @type {CreateCreditAccountRelationships}
     * @memberof CreateCreditAccount
     */
    'relationships'?: CreateCreditAccountRelationships;
}

export const CreateCreditAccountTypeEnum = {
    CreditAccount: 'creditAccount'
} as const;

export type CreateCreditAccountTypeEnum = typeof CreateCreditAccountTypeEnum[keyof typeof CreateCreditAccountTypeEnum];

/**
 * 
 * @export
 * @interface CreateCreditAccountAttributes
 */
export interface CreateCreditAccountAttributes {
    /**
     * 
     * @type {string}
     * @memberof CreateCreditAccountAttributes
     */
    'creditTerms': string;
    /**
     * 
     * @type {number}
     * @memberof CreateCreditAccountAttributes
     */
    'creditLimit': number;
    /**
     * 
     * @type {object}
     * @memberof CreateCreditAccountAttributes
     */
    'tags'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof CreateCreditAccountAttributes
     */
    'idempotencyKey'?: string;
}
/**
 * 
 * @export
 * @interface CreateCreditAccountRelationships
 */
export interface CreateCreditAccountRelationships {
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof CreateCreditAccountRelationships
     */
    'customer': CustomerRelationship;
}
/**
 * 
 * @export
 * @interface CreateCustomerTokenRequest
 */
export interface CreateCustomerTokenRequest {
    /**
     * 
     * @type {CreateCustomerTokenRequestData}
     * @memberof CreateCustomerTokenRequest
     */
    'data'?: CreateCustomerTokenRequestData;
}
/**
 * 
 * @export
 * @interface CreateCustomerTokenRequestData
 */
export interface CreateCustomerTokenRequestData {
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerTokenRequestData
     */
    'type'?: CreateCustomerTokenRequestDataTypeEnum;
    /**
     * 
     * @type {CreateCustomerTokenRequestDataAttributes}
     * @memberof CreateCustomerTokenRequestData
     */
    'attributes'?: CreateCustomerTokenRequestDataAttributes;
}

export const CreateCustomerTokenRequestDataTypeEnum = {
    CustomerToken: 'customerToken'
} as const;

export type CreateCustomerTokenRequestDataTypeEnum = typeof CreateCustomerTokenRequestDataTypeEnum[keyof typeof CreateCustomerTokenRequestDataTypeEnum];

/**
 * 
 * @export
 * @interface CreateCustomerTokenRequestDataAttributes
 */
export interface CreateCustomerTokenRequestDataAttributes {
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerTokenRequestDataAttributes
     */
    'scope'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerTokenRequestDataAttributes
     */
    'verificationToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerTokenRequestDataAttributes
     */
    'jwtToken'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateCustomerTokenRequestDataAttributes
     */
    'expiresIn'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerTokenRequestDataAttributes
     */
    'verificationCode'?: string;
    /**
     * 
     * @type {Array<CreateApiTokenRequestDataAttributesResourcesInner>}
     * @memberof CreateCustomerTokenRequestDataAttributes
     */
    'resources'?: Array<CreateApiTokenRequestDataAttributesResourcesInner>;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerTokenRequestDataAttributes
     */
    'upgradableScope'?: string;
}
/**
 * 
 * @export
 * @interface CreateCustomerTokenVerificationRequest
 */
export interface CreateCustomerTokenVerificationRequest {
    /**
     * 
     * @type {CreateCustomerTokenVerificationRequestData}
     * @memberof CreateCustomerTokenVerificationRequest
     */
    'data'?: CreateCustomerTokenVerificationRequestData;
}
/**
 * 
 * @export
 * @interface CreateCustomerTokenVerificationRequestData
 */
export interface CreateCustomerTokenVerificationRequestData {
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerTokenVerificationRequestData
     */
    'type': CreateCustomerTokenVerificationRequestDataTypeEnum;
    /**
     * 
     * @type {CreateCustomerTokenVerificationRequestDataAttributes}
     * @memberof CreateCustomerTokenVerificationRequestData
     */
    'attributes': CreateCustomerTokenVerificationRequestDataAttributes;
}

export const CreateCustomerTokenVerificationRequestDataTypeEnum = {
    CustomerTokenVerification: 'customerTokenVerification'
} as const;

export type CreateCustomerTokenVerificationRequestDataTypeEnum = typeof CreateCustomerTokenVerificationRequestDataTypeEnum[keyof typeof CreateCustomerTokenVerificationRequestDataTypeEnum];

/**
 * 
 * @export
 * @interface CreateCustomerTokenVerificationRequestDataAttributes
 */
export interface CreateCustomerTokenVerificationRequestDataAttributes {
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerTokenVerificationRequestDataAttributes
     */
    'channel': CreateCustomerTokenVerificationRequestDataAttributesChannelEnum;
    /**
     * 
     * @type {Phone}
     * @memberof CreateCustomerTokenVerificationRequestDataAttributes
     */
    'phone'?: Phone;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerTokenVerificationRequestDataAttributes
     */
    'appHash'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerTokenVerificationRequestDataAttributes
     */
    'language'?: CreateCustomerTokenVerificationRequestDataAttributesLanguageEnum;
}

export const CreateCustomerTokenVerificationRequestDataAttributesChannelEnum = {
    Sms: 'sms',
    Call: 'call'
} as const;

export type CreateCustomerTokenVerificationRequestDataAttributesChannelEnum = typeof CreateCustomerTokenVerificationRequestDataAttributesChannelEnum[keyof typeof CreateCustomerTokenVerificationRequestDataAttributesChannelEnum];
export const CreateCustomerTokenVerificationRequestDataAttributesLanguageEnum = {
    En: 'en',
    Af: 'af',
    Ar: 'ar',
    Ca: 'ca',
    Zh: 'zh',
    ZhCn: 'zh-CN',
    ZhHk: 'zh-HK',
    Hr: 'hr',
    Cs: 'cs',
    Da: 'da',
    Nl: 'nl',
    EnGb: 'en-GB',
    Et: 'et',
    Fi: 'fi',
    Fr: 'fr',
    De: 'de',
    El: 'el',
    He: 'he',
    Hi: 'hi',
    Hu: 'hu',
    Id: 'id',
    It: 'it',
    Ja: 'ja',
    Kn: 'kn',
    Ko: 'ko',
    Ms: 'ms',
    Mr: 'mr',
    Nb: 'nb',
    Pl: 'pl',
    PtBr: 'pt-BR',
    Pt: 'pt',
    Ro: 'ro',
    Ru: 'ru',
    Sk: 'sk',
    Es: 'es',
    Sv: 'sv',
    Tl: 'tl',
    Te: 'te',
    Th: 'th',
    Tr: 'tr',
    Vi: 'vi'
} as const;

export type CreateCustomerTokenVerificationRequestDataAttributesLanguageEnum = typeof CreateCustomerTokenVerificationRequestDataAttributesLanguageEnum[keyof typeof CreateCustomerTokenVerificationRequestDataAttributesLanguageEnum];

/**
 * 
 * @export
 * @interface CreateDepositAccount
 */
export interface CreateDepositAccount {
    /**
     * 
     * @type {string}
     * @memberof CreateDepositAccount
     */
    'type'?: CreateDepositAccountTypeEnum;
    /**
     * 
     * @type {CreateDepositAccountAttributes}
     * @memberof CreateDepositAccount
     */
    'attributes'?: CreateDepositAccountAttributes;
    /**
     * 
     * @type {CreateDepositAccountRelationships}
     * @memberof CreateDepositAccount
     */
    'relationships'?: CreateDepositAccountRelationships;
}

export const CreateDepositAccountTypeEnum = {
    DepositAccount: 'depositAccount'
} as const;

export type CreateDepositAccountTypeEnum = typeof CreateDepositAccountTypeEnum[keyof typeof CreateDepositAccountTypeEnum];

/**
 * 
 * @export
 * @interface CreateDepositAccountAttributes
 */
export interface CreateDepositAccountAttributes {
    /**
     * 
     * @type {string}
     * @memberof CreateDepositAccountAttributes
     */
    'depositProduct': string;
    /**
     * 
     * @type {object}
     * @memberof CreateDepositAccountAttributes
     */
    'tags'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof CreateDepositAccountAttributes
     */
    'idempotencyKey'?: string;
}
/**
 * 
 * @export
 * @interface CreateDepositAccountRelationships
 */
export interface CreateDepositAccountRelationships {
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof CreateDepositAccountRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof CreateDepositAccountRelationships
     */
    'customers'?: CustomersRelationship;
}
/**
 * 
 * @export
 * @interface CreateFeeRelationships
 */
export interface CreateFeeRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof CreateFeeRelationships
     */
    'account': AccountRelationship;
}
/**
 * 
 * @export
 * @interface CreateFeeRequest
 */
export interface CreateFeeRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateFeeRequest
     */
    'type': CreateFeeRequestTypeEnum;
    /**
     * 
     * @type {CreateFeeRequestAttributes}
     * @memberof CreateFeeRequest
     */
    'attributes': CreateFeeRequestAttributes;
    /**
     * 
     * @type {CreateFeeRelationships}
     * @memberof CreateFeeRequest
     */
    'relationships': CreateFeeRelationships;
}

export const CreateFeeRequestTypeEnum = {
    Fee: 'fee'
} as const;

export type CreateFeeRequestTypeEnum = typeof CreateFeeRequestTypeEnum[keyof typeof CreateFeeRequestTypeEnum];

/**
 * 
 * @export
 * @interface CreateFeeRequestAttributes
 */
export interface CreateFeeRequestAttributes {
    /**
     * 
     * @type {number}
     * @memberof CreateFeeRequestAttributes
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof CreateFeeRequestAttributes
     */
    'description': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateFeeRequestAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof CreateFeeRequestAttributes
     */
    'idempotencyKey'?: string;
}
/**
 * 
 * @export
 * @interface CreateIndividualApplication
 */
export interface CreateIndividualApplication {
    /**
     * 
     * @type {string}
     * @memberof CreateIndividualApplication
     */
    'type': CreateIndividualApplicationTypeEnum;
    /**
     * 
     * @type {CreateIndividualApplicationAttributes}
     * @memberof CreateIndividualApplication
     */
    'attributes': CreateIndividualApplicationAttributes;
}

export const CreateIndividualApplicationTypeEnum = {
    IndividualApplication: 'individualApplication'
} as const;

export type CreateIndividualApplicationTypeEnum = typeof CreateIndividualApplicationTypeEnum[keyof typeof CreateIndividualApplicationTypeEnum];

/**
 * 
 * @export
 * @interface CreateIndividualApplicationAttributes
 */
export interface CreateIndividualApplicationAttributes {
    /**
     * 
     * @type {FullName}
     * @memberof CreateIndividualApplicationAttributes
     */
    'fullName': FullName;
    /**
     * 
     * @type {string}
     * @memberof CreateIndividualApplicationAttributes
     */
    'email': string;
    /**
     * 
     * @type {Phone}
     * @memberof CreateIndividualApplicationAttributes
     */
    'phone': Phone;
    /**
     * 
     * @type {string}
     * @memberof CreateIndividualApplicationAttributes
     */
    'ssn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateIndividualApplicationAttributes
     */
    'passport'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateIndividualApplicationAttributes
     */
    'nationality'?: string;
    /**
     * 
     * @type {Address}
     * @memberof CreateIndividualApplicationAttributes
     */
    'address': Address;
    /**
     * 
     * @type {string}
     * @memberof CreateIndividualApplicationAttributes
     */
    'dateOfBirth': string;
    /**
     * 
     * @type {string}
     * @memberof CreateIndividualApplicationAttributes
     */
    'ip'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateIndividualApplicationAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof CreateIndividualApplicationAttributes
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {Array<DeviceFingerprint>}
     * @memberof CreateIndividualApplicationAttributes
     */
    'deviceFingerprints'?: Array<DeviceFingerprint>;
    /**
     * 
     * @type {string}
     * @memberof CreateIndividualApplicationAttributes
     */
    'jwtSubject'?: string | null;
    /**
     * 
     * @type {CreatePowerOfAttorneyAgent}
     * @memberof CreateIndividualApplicationAttributes
     */
    'powerOfAttorneyAgent'?: CreatePowerOfAttorneyAgent;
    /**
     * 
     * @type {Industry}
     * @memberof CreateIndividualApplicationAttributes
     */
    'industry'?: Industry;
    /**
     * 
     * @type {EvaluationParams}
     * @memberof CreateIndividualApplicationAttributes
     */
    'EvaluationParams'?: EvaluationParams;
    /**
     * 
     * @type {Occupation}
     * @memberof CreateIndividualApplicationAttributes
     */
    'occupation'?: Occupation;
    /**
     * 
     * @type {AnnualIncome}
     * @memberof CreateIndividualApplicationAttributes
     */
    'annualIncome'?: AnnualIncome;
    /**
     * 
     * @type {SourceOfIncome}
     * @memberof CreateIndividualApplicationAttributes
     */
    'sourceOfIncome'?: SourceOfIncome;
}


/**
 * 
 * @export
 * @interface CreateIndividualDebitCardRequest
 */
export interface CreateIndividualDebitCardRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateIndividualDebitCardRequest
     */
    'type': CreateIndividualDebitCardRequestTypeEnum;
    /**
     * 
     * @type {CreateIndividualDebitCardRequestAttributes}
     * @memberof CreateIndividualDebitCardRequest
     */
    'attributes': CreateIndividualDebitCardRequestAttributes;
    /**
     * 
     * @type {CreateCardRelationships}
     * @memberof CreateIndividualDebitCardRequest
     */
    'relationships': CreateCardRelationships;
}

export const CreateIndividualDebitCardRequestTypeEnum = {
    IndividualDebitCard: 'individualDebitCard'
} as const;

export type CreateIndividualDebitCardRequestTypeEnum = typeof CreateIndividualDebitCardRequestTypeEnum[keyof typeof CreateIndividualDebitCardRequestTypeEnum];

/**
 * 
 * @export
 * @interface CreateIndividualDebitCardRequestAttributes
 */
export interface CreateIndividualDebitCardRequestAttributes {
    /**
     * 
     * @type {Address}
     * @memberof CreateIndividualDebitCardRequestAttributes
     */
    'shippingAddress'?: Address;
    /**
     * 
     * @type {string}
     * @memberof CreateIndividualDebitCardRequestAttributes
     */
    'design'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateIndividualDebitCardRequestAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {CardLevelLimits}
     * @memberof CreateIndividualDebitCardRequestAttributes
     */
    'limits'?: CardLevelLimits;
    /**
     * 
     * @type {string}
     * @memberof CreateIndividualDebitCardRequestAttributes
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {Bin}
     * @memberof CreateIndividualDebitCardRequestAttributes
     */
    'bin'?: Bin;
    /**
     * 
     * @type {string}
     * @memberof CreateIndividualDebitCardRequestAttributes
     */
    'cardQualifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateIndividualDebitCardRequestAttributes
     */
    'cardDesignId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateIndividualDebitCardRequestAttributes
     */
    'additionalEmbossedText'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateIndividualDebitCardRequestAttributes
     */
    'activeForOnlineUse'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateIndividualDebitCardRequestAttributes
     */
    'printOnlyBusinessName'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateIndividualDebitCardRequestAttributes
     */
    'expiryDate'?: string;
}
/**
 * 
 * @export
 * @interface CreateIndividualVirtualDebitCardRequest
 */
export interface CreateIndividualVirtualDebitCardRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateIndividualVirtualDebitCardRequest
     */
    'type': CreateIndividualVirtualDebitCardRequestTypeEnum;
    /**
     * 
     * @type {CreateIndividualVirtualDebitCardRequestAttributes}
     * @memberof CreateIndividualVirtualDebitCardRequest
     */
    'attributes': CreateIndividualVirtualDebitCardRequestAttributes;
    /**
     * 
     * @type {CreateCardRelationships}
     * @memberof CreateIndividualVirtualDebitCardRequest
     */
    'relationships': CreateCardRelationships;
}

export const CreateIndividualVirtualDebitCardRequestTypeEnum = {
    IndividualVirtualDebitCard: 'individualVirtualDebitCard'
} as const;

export type CreateIndividualVirtualDebitCardRequestTypeEnum = typeof CreateIndividualVirtualDebitCardRequestTypeEnum[keyof typeof CreateIndividualVirtualDebitCardRequestTypeEnum];

/**
 * 
 * @export
 * @interface CreateIndividualVirtualDebitCardRequestAttributes
 */
export interface CreateIndividualVirtualDebitCardRequestAttributes {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateIndividualVirtualDebitCardRequestAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {CardLevelLimits}
     * @memberof CreateIndividualVirtualDebitCardRequestAttributes
     */
    'limits'?: CardLevelLimits;
    /**
     * 
     * @type {string}
     * @memberof CreateIndividualVirtualDebitCardRequestAttributes
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {Bin}
     * @memberof CreateIndividualVirtualDebitCardRequestAttributes
     */
    'bin'?: Bin;
    /**
     * 
     * @type {string}
     * @memberof CreateIndividualVirtualDebitCardRequestAttributes
     */
    'cardQualifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateIndividualVirtualDebitCardRequestAttributes
     */
    'expiryDate'?: string;
}
/**
 * 
 * @export
 * @interface CreateOfficer
 */
export interface CreateOfficer {
    /**
     * 
     * @type {FullName}
     * @memberof CreateOfficer
     */
    'fullName': FullName;
    /**
     * 
     * @type {string}
     * @memberof CreateOfficer
     */
    'email': string;
    /**
     * 
     * @type {Phone}
     * @memberof CreateOfficer
     */
    'phone': Phone;
    /**
     * 
     * @type {string}
     * @memberof CreateOfficer
     */
    'ssn'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOfficer
     */
    'passport'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOfficer
     */
    'nationality'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOfficer
     */
    'matriculaConsular'?: string;
    /**
     * 
     * @type {Address}
     * @memberof CreateOfficer
     */
    'address': Address;
    /**
     * 
     * @type {string}
     * @memberof CreateOfficer
     */
    'dateOfBirth': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOfficer
     */
    'title'?: CreateOfficerTitleEnum;
    /**
     * 
     * @type {EvaluationParams}
     * @memberof CreateOfficer
     */
    'EvaluationParams'?: EvaluationParams;
    /**
     * 
     * @type {Occupation}
     * @memberof CreateOfficer
     */
    'occupation': Occupation;
    /**
     * 
     * @type {AnnualIncome}
     * @memberof CreateOfficer
     */
    'annualIncome'?: AnnualIncome;
    /**
     * 
     * @type {SourceOfIncome}
     * @memberof CreateOfficer
     */
    'sourceOfIncome'?: SourceOfIncome;
}

export const CreateOfficerTitleEnum = {
    President: 'President',
    Ceo: 'CEO',
    Coo: 'COO',
    Cfo: 'CFO',
    BenefitsAdministrationOfficer: 'BenefitsAdministrationOfficer',
    Cio: 'CIO',
    Vp: 'VP',
    Avp: 'AVP',
    Treasurer: 'Treasurer',
    Secretary: 'Secretary',
    Controller: 'Controller',
    Manager: 'Manager',
    Partner: 'Partner',
    Member: 'Member'
} as const;

export type CreateOfficerTitleEnum = typeof CreateOfficerTitleEnum[keyof typeof CreateOfficerTitleEnum];

/**
 * 
 * @export
 * @interface CreatePaymentRelationships
 */
export interface CreatePaymentRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof CreatePaymentRelationships
     */
    'account': AccountRelationship;
}
/**
 * 
 * @export
 * @interface CreatePaymentRelationshipsWithCounterparty
 */
export interface CreatePaymentRelationshipsWithCounterparty {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof CreatePaymentRelationshipsWithCounterparty
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CounterpartyRelationship}
     * @memberof CreatePaymentRelationshipsWithCounterparty
     */
    'counterparty': CounterpartyRelationship;
}
/**
 * 
 * @export
 * @interface CreatePaymentRelationshipsWithCounterpartyAccount
 */
export interface CreatePaymentRelationshipsWithCounterpartyAccount {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof CreatePaymentRelationshipsWithCounterpartyAccount
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CounterpartyAccountRelationship}
     * @memberof CreatePaymentRelationshipsWithCounterpartyAccount
     */
    'counterpartyAccount': CounterpartyAccountRelationship;
}
/**
 * 
 * @export
 * @interface CreatePaymentRequest
 */
export interface CreatePaymentRequest {
    /**
     * 
     * @type {CreatePaymentRequestData}
     * @memberof CreatePaymentRequest
     */
    'data'?: CreatePaymentRequestData;
}
/**
 * @type CreatePaymentRequestData
 * @export
 */
export type CreatePaymentRequestData = CreateAchPayment | CreateAchPaymentCounterparty | CreateAchPaymentPlaid | CreateBookPayment | CreatePushToCardPayment | CreateWirePayment;

/**
 * 
 * @export
 * @interface CreatePlaidCounterparty
 */
export interface CreatePlaidCounterparty {
    /**
     * 
     * @type {string}
     * @memberof CreatePlaidCounterparty
     */
    'type': string;
    /**
     * 
     * @type {CreatePlaidCounterpartyAttributes}
     * @memberof CreatePlaidCounterparty
     */
    'attributes': CreatePlaidCounterpartyAttributes;
    /**
     * 
     * @type {CreateCounterpartyRelationships}
     * @memberof CreatePlaidCounterparty
     */
    'relationships': CreateCounterpartyRelationships;
}
/**
 * 
 * @export
 * @interface CreatePlaidCounterpartyAttributes
 */
export interface CreatePlaidCounterpartyAttributes {
    /**
     * 
     * @type {string}
     * @memberof CreatePlaidCounterpartyAttributes
     */
    'type': CreatePlaidCounterpartyAttributesTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreatePlaidCounterpartyAttributes
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreatePlaidCounterpartyAttributes
     */
    'verifyName'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreatePlaidCounterpartyAttributes
     */
    'plaidProcessorToken': string;
    /**
     * 
     * @type {string}
     * @memberof CreatePlaidCounterpartyAttributes
     */
    'permissions'?: CreatePlaidCounterpartyAttributesPermissionsEnum;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreatePlaidCounterpartyAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof CreatePlaidCounterpartyAttributes
     */
    'idempotencyKey'?: string;
}

export const CreatePlaidCounterpartyAttributesTypeEnum = {
    Business: 'Business',
    Person: 'Person',
    Unknown: 'Unknown'
} as const;

export type CreatePlaidCounterpartyAttributesTypeEnum = typeof CreatePlaidCounterpartyAttributesTypeEnum[keyof typeof CreatePlaidCounterpartyAttributesTypeEnum];
export const CreatePlaidCounterpartyAttributesPermissionsEnum = {
    CreditOnly: 'CreditOnly',
    DebitOnly: 'DebitOnly',
    CreditAndDebit: 'CreditAndDebit'
} as const;

export type CreatePlaidCounterpartyAttributesPermissionsEnum = typeof CreatePlaidCounterpartyAttributesPermissionsEnum[keyof typeof CreatePlaidCounterpartyAttributesPermissionsEnum];

/**
 * 
 * @export
 * @interface CreatePowerOfAttorneyAgent
 */
export interface CreatePowerOfAttorneyAgent {
    /**
     * 
     * @type {FullName}
     * @memberof CreatePowerOfAttorneyAgent
     */
    'fullName': FullName;
    /**
     * 
     * @type {string}
     * @memberof CreatePowerOfAttorneyAgent
     */
    'email': string;
    /**
     * 
     * @type {Phone}
     * @memberof CreatePowerOfAttorneyAgent
     */
    'phone': Phone;
    /**
     * 
     * @type {string}
     * @memberof CreatePowerOfAttorneyAgent
     */
    'ssn'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePowerOfAttorneyAgent
     */
    'passport'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePowerOfAttorneyAgent
     */
    'nationality'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePowerOfAttorneyAgent
     */
    'matriculaConsular'?: string;
    /**
     * 
     * @type {Address}
     * @memberof CreatePowerOfAttorneyAgent
     */
    'address': Address;
    /**
     * 
     * @type {string}
     * @memberof CreatePowerOfAttorneyAgent
     */
    'dateOfBirth': string;
    /**
     * 
     * @type {string}
     * @memberof CreatePowerOfAttorneyAgent
     */
    'jwtSubject'?: string | null;
    /**
     * 
     * @type {EvaluationParams}
     * @memberof CreatePowerOfAttorneyAgent
     */
    'EvaluationParams'?: EvaluationParams;
}
/**
 * 
 * @export
 * @interface CreatePushToCardPayment
 */
export interface CreatePushToCardPayment {
    /**
     * 
     * @type {string}
     * @memberof CreatePushToCardPayment
     */
    'type'?: CreatePushToCardPaymentTypeEnum;
    /**
     * 
     * @type {CreatePushToCardPaymentAttributes}
     * @memberof CreatePushToCardPayment
     */
    'attributes': CreatePushToCardPaymentAttributes;
    /**
     * 
     * @type {CreatePushToCardPaymentRelationships}
     * @memberof CreatePushToCardPayment
     */
    'relationships': CreatePushToCardPaymentRelationships;
}

export const CreatePushToCardPaymentTypeEnum = {
    PushToCardPayment: 'pushToCardPayment'
} as const;

export type CreatePushToCardPaymentTypeEnum = typeof CreatePushToCardPaymentTypeEnum[keyof typeof CreatePushToCardPaymentTypeEnum];

/**
 * 
 * @export
 * @interface CreatePushToCardPaymentAttributes
 */
export interface CreatePushToCardPaymentAttributes {
    /**
     * 
     * @type {number}
     * @memberof CreatePushToCardPaymentAttributes
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof CreatePushToCardPaymentAttributes
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreatePushToCardPaymentAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof CreatePushToCardPaymentAttributes
     */
    'description': string;
    /**
     * 
     * @type {CreatePushToCardPaymentAttributesConfiguration}
     * @memberof CreatePushToCardPaymentAttributes
     */
    'configuration': CreatePushToCardPaymentAttributesConfiguration;
}
/**
 * 
 * @export
 * @interface CreatePushToCardPaymentAttributesConfiguration
 */
export interface CreatePushToCardPaymentAttributesConfiguration {
    /**
     * 
     * @type {Astra}
     * @memberof CreatePushToCardPaymentAttributesConfiguration
     */
    'astra'?: Astra;
}
/**
 * 
 * @export
 * @interface CreatePushToCardPaymentRelationships
 */
export interface CreatePushToCardPaymentRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof CreatePushToCardPaymentRelationships
     */
    'account': AccountRelationship;
}
/**
 * 
 * @export
 * @interface CreateRecurringAchRepayment
 */
export interface CreateRecurringAchRepayment {
    /**
     * 
     * @type {string}
     * @memberof CreateRecurringAchRepayment
     */
    'type': CreateRecurringAchRepaymentTypeEnum;
    /**
     * 
     * @type {CreateRecurringAchRepaymentAttributes}
     * @memberof CreateRecurringAchRepayment
     */
    'attributes': CreateRecurringAchRepaymentAttributes;
    /**
     * 
     * @type {CreateRecurringAchRepaymentRelationships}
     * @memberof CreateRecurringAchRepayment
     */
    'relationships': CreateRecurringAchRepaymentRelationships;
}

export const CreateRecurringAchRepaymentTypeEnum = {
    RecurringAchRepayment: 'recurringAchRepayment'
} as const;

export type CreateRecurringAchRepaymentTypeEnum = typeof CreateRecurringAchRepaymentTypeEnum[keyof typeof CreateRecurringAchRepaymentTypeEnum];

/**
 * 
 * @export
 * @interface CreateRecurringAchRepaymentAttributes
 */
export interface CreateRecurringAchRepaymentAttributes {
    /**
     * 
     * @type {string}
     * @memberof CreateRecurringAchRepaymentAttributes
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecurringAchRepaymentAttributes
     */
    'addenda'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecurringAchRepaymentAttributes
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateRecurringAchRepaymentAttributes
     */
    'sameDay'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateRecurringAchRepaymentAttributes
     */
    'secCode'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateRecurringAchRepaymentAttributes
     */
    'tags'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface CreateRecurringAchRepaymentRelationships
 */
export interface CreateRecurringAchRepaymentRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof CreateRecurringAchRepaymentRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CreditAccountRelationship}
     * @memberof CreateRecurringAchRepaymentRelationships
     */
    'creditAccount': CreditAccountRelationship;
    /**
     * 
     * @type {CounterpartyRelationship}
     * @memberof CreateRecurringAchRepaymentRelationships
     */
    'counterparty': CounterpartyRelationship;
}
/**
 * 
 * @export
 * @interface CreateRecurringBookRepayment
 */
export interface CreateRecurringBookRepayment {
    /**
     * 
     * @type {string}
     * @memberof CreateRecurringBookRepayment
     */
    'type': CreateRecurringBookRepaymentTypeEnum;
    /**
     * 
     * @type {CreateRecurringBookRepaymentAttributes}
     * @memberof CreateRecurringBookRepayment
     */
    'attributes': CreateRecurringBookRepaymentAttributes;
    /**
     * 
     * @type {CreateRecurringBookRepaymentRelationships}
     * @memberof CreateRecurringBookRepayment
     */
    'relationships': CreateRecurringBookRepaymentRelationships;
}

export const CreateRecurringBookRepaymentTypeEnum = {
    RecurringBookRepayment: 'recurringBookRepayment'
} as const;

export type CreateRecurringBookRepaymentTypeEnum = typeof CreateRecurringBookRepaymentTypeEnum[keyof typeof CreateRecurringBookRepaymentTypeEnum];

/**
 * 
 * @export
 * @interface CreateRecurringBookRepaymentAttributes
 */
export interface CreateRecurringBookRepaymentAttributes {
    /**
     * 
     * @type {string}
     * @memberof CreateRecurringBookRepaymentAttributes
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecurringBookRepaymentAttributes
     */
    'transactionSummaryOverride'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecurringBookRepaymentAttributes
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateRecurringBookRepaymentAttributes
     */
    'tags'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface CreateRecurringBookRepaymentRelationships
 */
export interface CreateRecurringBookRepaymentRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof CreateRecurringBookRepaymentRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CreditAccountRelationship}
     * @memberof CreateRecurringBookRepaymentRelationships
     */
    'creditAccount': CreditAccountRelationship;
    /**
     * 
     * @type {CounterpartyAccountRelationship}
     * @memberof CreateRecurringBookRepaymentRelationships
     */
    'counterpartyAccount': CounterpartyAccountRelationship;
}
/**
 * 
 * @export
 * @interface CreateRecurringCapitalPartnerAchRepayment
 */
export interface CreateRecurringCapitalPartnerAchRepayment {
    /**
     * 
     * @type {string}
     * @memberof CreateRecurringCapitalPartnerAchRepayment
     */
    'type': CreateRecurringCapitalPartnerAchRepaymentTypeEnum;
    /**
     * 
     * @type {CreateRecurringAchRepaymentAttributes}
     * @memberof CreateRecurringCapitalPartnerAchRepayment
     */
    'attributes': CreateRecurringAchRepaymentAttributes;
    /**
     * 
     * @type {CreateRecurringCapitalPartnerAchRepaymentRelationships}
     * @memberof CreateRecurringCapitalPartnerAchRepayment
     */
    'relationships': CreateRecurringCapitalPartnerAchRepaymentRelationships;
}

export const CreateRecurringCapitalPartnerAchRepaymentTypeEnum = {
    RecurringCapitalPartnerAchRepayment: 'recurringCapitalPartnerAchRepayment'
} as const;

export type CreateRecurringCapitalPartnerAchRepaymentTypeEnum = typeof CreateRecurringCapitalPartnerAchRepaymentTypeEnum[keyof typeof CreateRecurringCapitalPartnerAchRepaymentTypeEnum];

/**
 * 
 * @export
 * @interface CreateRecurringCapitalPartnerAchRepaymentRelationships
 */
export interface CreateRecurringCapitalPartnerAchRepaymentRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof CreateRecurringCapitalPartnerAchRepaymentRelationships
     */
    'account'?: AccountRelationship;
    /**
     * 
     * @type {CreditAccountRelationship}
     * @memberof CreateRecurringCapitalPartnerAchRepaymentRelationships
     */
    'creditAccount': CreditAccountRelationship;
    /**
     * 
     * @type {CounterpartyRelationship}
     * @memberof CreateRecurringCapitalPartnerAchRepaymentRelationships
     */
    'counterparty': CounterpartyRelationship;
}
/**
 * 
 * @export
 * @interface CreateRecurringCapitalPartnerBookRepayment
 */
export interface CreateRecurringCapitalPartnerBookRepayment {
    /**
     * 
     * @type {string}
     * @memberof CreateRecurringCapitalPartnerBookRepayment
     */
    'type': CreateRecurringCapitalPartnerBookRepaymentTypeEnum;
    /**
     * 
     * @type {CreateRecurringBookRepaymentAttributes}
     * @memberof CreateRecurringCapitalPartnerBookRepayment
     */
    'attributes': CreateRecurringBookRepaymentAttributes;
    /**
     * 
     * @type {CreateRecurringCapitalPartnerBookRepaymentRelationships}
     * @memberof CreateRecurringCapitalPartnerBookRepayment
     */
    'relationships': CreateRecurringCapitalPartnerBookRepaymentRelationships;
}

export const CreateRecurringCapitalPartnerBookRepaymentTypeEnum = {
    RecurringCapitalPartnerBookRepayment: 'recurringCapitalPartnerBookRepayment'
} as const;

export type CreateRecurringCapitalPartnerBookRepaymentTypeEnum = typeof CreateRecurringCapitalPartnerBookRepaymentTypeEnum[keyof typeof CreateRecurringCapitalPartnerBookRepaymentTypeEnum];

/**
 * 
 * @export
 * @interface CreateRecurringCapitalPartnerBookRepaymentRelationships
 */
export interface CreateRecurringCapitalPartnerBookRepaymentRelationships {
    /**
     * 
     * @type {CreditAccountRelationship}
     * @memberof CreateRecurringCapitalPartnerBookRepaymentRelationships
     */
    'creditAccount': CreditAccountRelationship;
    /**
     * 
     * @type {CounterpartyAccountRelationship}
     * @memberof CreateRecurringCapitalPartnerBookRepaymentRelationships
     */
    'counterpartyAccount': CounterpartyAccountRelationship;
}
/**
 * 
 * @export
 * @interface CreateRecurringCreditAchPayment
 */
export interface CreateRecurringCreditAchPayment {
    /**
     * 
     * @type {string}
     * @memberof CreateRecurringCreditAchPayment
     */
    'type': CreateRecurringCreditAchPaymentTypeEnum;
    /**
     * 
     * @type {CreateRecurringCreditAchPaymentAttributes}
     * @memberof CreateRecurringCreditAchPayment
     */
    'attributes': CreateRecurringCreditAchPaymentAttributes;
    /**
     * 
     * @type {CreatePaymentRelationshipsWithCounterparty}
     * @memberof CreateRecurringCreditAchPayment
     */
    'relationships': CreatePaymentRelationshipsWithCounterparty;
}

export const CreateRecurringCreditAchPaymentTypeEnum = {
    RecurringCreditAchPayment: 'recurringCreditAchPayment'
} as const;

export type CreateRecurringCreditAchPaymentTypeEnum = typeof CreateRecurringCreditAchPaymentTypeEnum[keyof typeof CreateRecurringCreditAchPaymentTypeEnum];

/**
 * 
 * @export
 * @interface CreateRecurringCreditAchPaymentAttributes
 */
export interface CreateRecurringCreditAchPaymentAttributes {
    /**
     * 
     * @type {number}
     * @memberof CreateRecurringCreditAchPaymentAttributes
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof CreateRecurringCreditAchPaymentAttributes
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecurringCreditAchPaymentAttributes
     */
    'addenda'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecurringCreditAchPaymentAttributes
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateRecurringCreditAchPaymentAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {Schedule}
     * @memberof CreateRecurringCreditAchPaymentAttributes
     */
    'schedule': Schedule;
}
/**
 * 
 * @export
 * @interface CreateRecurringCreditBookPayment
 */
export interface CreateRecurringCreditBookPayment {
    /**
     * 
     * @type {string}
     * @memberof CreateRecurringCreditBookPayment
     */
    'type': CreateRecurringCreditBookPaymentTypeEnum;
    /**
     * 
     * @type {CreateRecurringCreditBookPaymentAttributes}
     * @memberof CreateRecurringCreditBookPayment
     */
    'attributes': CreateRecurringCreditBookPaymentAttributes;
    /**
     * 
     * @type {CreatePaymentRelationshipsWithCounterparty}
     * @memberof CreateRecurringCreditBookPayment
     */
    'relationships': CreatePaymentRelationshipsWithCounterparty;
}

export const CreateRecurringCreditBookPaymentTypeEnum = {
    RecurringCreditBookPayment: 'recurringCreditBookPayment'
} as const;

export type CreateRecurringCreditBookPaymentTypeEnum = typeof CreateRecurringCreditBookPaymentTypeEnum[keyof typeof CreateRecurringCreditBookPaymentTypeEnum];

/**
 * 
 * @export
 * @interface CreateRecurringCreditBookPaymentAttributes
 */
export interface CreateRecurringCreditBookPaymentAttributes {
    /**
     * 
     * @type {number}
     * @memberof CreateRecurringCreditBookPaymentAttributes
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof CreateRecurringCreditBookPaymentAttributes
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecurringCreditBookPaymentAttributes
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateRecurringCreditBookPaymentAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof CreateRecurringCreditBookPaymentAttributes
     */
    'transactionSummaryOverride'?: string;
    /**
     * 
     * @type {Schedule}
     * @memberof CreateRecurringCreditBookPaymentAttributes
     */
    'schedule': Schedule;
}
/**
 * 
 * @export
 * @interface CreateRecurringDebitAchPayment
 */
export interface CreateRecurringDebitAchPayment {
    /**
     * 
     * @type {string}
     * @memberof CreateRecurringDebitAchPayment
     */
    'type': CreateRecurringDebitAchPaymentTypeEnum;
    /**
     * 
     * @type {CreateRecurringDebitAchPaymentAttributes}
     * @memberof CreateRecurringDebitAchPayment
     */
    'attributes': CreateRecurringDebitAchPaymentAttributes;
    /**
     * 
     * @type {CreatePaymentRelationshipsWithCounterparty}
     * @memberof CreateRecurringDebitAchPayment
     */
    'relationships': CreatePaymentRelationshipsWithCounterparty;
}

export const CreateRecurringDebitAchPaymentTypeEnum = {
    RecurringDebitAchPayment: 'recurringDebitAchPayment'
} as const;

export type CreateRecurringDebitAchPaymentTypeEnum = typeof CreateRecurringDebitAchPaymentTypeEnum[keyof typeof CreateRecurringDebitAchPaymentTypeEnum];

/**
 * 
 * @export
 * @interface CreateRecurringDebitAchPaymentAttributes
 */
export interface CreateRecurringDebitAchPaymentAttributes {
    /**
     * 
     * @type {number}
     * @memberof CreateRecurringDebitAchPaymentAttributes
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof CreateRecurringDebitAchPaymentAttributes
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecurringDebitAchPaymentAttributes
     */
    'addenda'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecurringDebitAchPaymentAttributes
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateRecurringDebitAchPaymentAttributes
     */
    'sameDay'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateRecurringDebitAchPaymentAttributes
     */
    'verifyCounterpartyBalance'?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateRecurringDebitAchPaymentAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {Schedule}
     * @memberof CreateRecurringDebitAchPaymentAttributes
     */
    'schedule': Schedule;
    /**
     * 
     * @type {number}
     * @memberof CreateRecurringDebitAchPaymentAttributes
     */
    'clearingDaysOverride'?: number;
}
/**
 * 
 * @export
 * @interface CreateRecurringPaymentRequest
 */
export interface CreateRecurringPaymentRequest {
    /**
     * 
     * @type {CreateRecurringPaymentRequestData}
     * @memberof CreateRecurringPaymentRequest
     */
    'data': CreateRecurringPaymentRequestData;
}
/**
 * @type CreateRecurringPaymentRequestData
 * @export
 */
export type CreateRecurringPaymentRequestData = CreateRecurringCreditAchPayment | CreateRecurringCreditBookPayment | CreateRecurringDebitAchPayment;

/**
 * 
 * @export
 * @interface CreateRecurringRepaymentRequest
 */
export interface CreateRecurringRepaymentRequest {
    /**
     * 
     * @type {CreateRecurringRepaymentRequestData}
     * @memberof CreateRecurringRepaymentRequest
     */
    'data'?: CreateRecurringRepaymentRequestData;
}
/**
 * @type CreateRecurringRepaymentRequestData
 * @export
 */
export type CreateRecurringRepaymentRequestData = { type: 'CreateRecurringAchRepayment' } & CreateRecurringAchRepayment | { type: 'CreateRecurringBookRepayment' } & CreateRecurringBookRepayment | { type: 'CreateRecurringCapitalPartnerAchRepayment' } & CreateRecurringCapitalPartnerAchRepayment | { type: 'CreateRecurringCapitalPartnerBookRepayment' } & CreateRecurringCapitalPartnerBookRepayment;

/**
 * 
 * @export
 * @interface CreateRepaymentRequest
 */
export interface CreateRepaymentRequest {
    /**
     * 
     * @type {CreateRepaymentRequestData}
     * @memberof CreateRepaymentRequest
     */
    'data': CreateRepaymentRequestData;
}
/**
 * @type CreateRepaymentRequestData
 * @export
 */
export type CreateRepaymentRequestData = CreateAchRepayment | CreateBookRepayment | CreateCapitalPartnerAchRepayment | CreateCapitalPartnerBookRepayment;

/**
 * 
 * @export
 * @interface CreateRewardRelationships
 */
export interface CreateRewardRelationships {
    /**
     * 
     * @type {FundingAccountRelationship}
     * @memberof CreateRewardRelationships
     */
    'fundingAccount'?: FundingAccountRelationship;
    /**
     * 
     * @type {ReceivingAccountRelationship}
     * @memberof CreateRewardRelationships
     */
    'receivingAccount': ReceivingAccountRelationship;
    /**
     * 
     * @type {RewardedTransactionRelationship}
     * @memberof CreateRewardRelationships
     */
    'rewardedTransaction'?: RewardedTransactionRelationship;
}
/**
 * 
 * @export
 * @interface CreateRewardRequest
 */
export interface CreateRewardRequest {
    /**
     * 
     * @type {CreateRewardRequestData}
     * @memberof CreateRewardRequest
     */
    'data'?: CreateRewardRequestData;
}
/**
 * 
 * @export
 * @interface CreateRewardRequestData
 */
export interface CreateRewardRequestData {
    /**
     * 
     * @type {string}
     * @memberof CreateRewardRequestData
     */
    'type': CreateRewardRequestDataTypeEnum;
    /**
     * 
     * @type {CreateRewardRequestDataAttributes}
     * @memberof CreateRewardRequestData
     */
    'attributes': CreateRewardRequestDataAttributes;
    /**
     * 
     * @type {CreateRewardRelationships}
     * @memberof CreateRewardRequestData
     */
    'relationships': CreateRewardRelationships;
}

export const CreateRewardRequestDataTypeEnum = {
    Reward: 'reward'
} as const;

export type CreateRewardRequestDataTypeEnum = typeof CreateRewardRequestDataTypeEnum[keyof typeof CreateRewardRequestDataTypeEnum];

/**
 * 
 * @export
 * @interface CreateRewardRequestDataAttributes
 */
export interface CreateRewardRequestDataAttributes {
    /**
     * 
     * @type {number}
     * @memberof CreateRewardRequestDataAttributes
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof CreateRewardRequestDataAttributes
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRewardRequestDataAttributes
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateRewardRequestDataAttributes
     */
    'tags'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface CreateSoleProprietorApplication
 */
export interface CreateSoleProprietorApplication {
    /**
     * 
     * @type {string}
     * @memberof CreateSoleProprietorApplication
     */
    'type': CreateSoleProprietorApplicationTypeEnum;
    /**
     * 
     * @type {CreateSoleProprietorApplicationAttributes}
     * @memberof CreateSoleProprietorApplication
     */
    'attributes': CreateSoleProprietorApplicationAttributes;
}

export const CreateSoleProprietorApplicationTypeEnum = {
    IndividualApplication: 'individualApplication'
} as const;

export type CreateSoleProprietorApplicationTypeEnum = typeof CreateSoleProprietorApplicationTypeEnum[keyof typeof CreateSoleProprietorApplicationTypeEnum];

/**
 * 
 * @export
 * @interface CreateSoleProprietorApplicationAttributes
 */
export interface CreateSoleProprietorApplicationAttributes {
    /**
     * 
     * @type {FullName}
     * @memberof CreateSoleProprietorApplicationAttributes
     */
    'fullName': FullName;
    /**
     * 
     * @type {string}
     * @memberof CreateSoleProprietorApplicationAttributes
     */
    'email': string;
    /**
     * 
     * @type {Phone}
     * @memberof CreateSoleProprietorApplicationAttributes
     */
    'phone': Phone;
    /**
     * 
     * @type {string}
     * @memberof CreateSoleProprietorApplicationAttributes
     */
    'ssn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateSoleProprietorApplicationAttributes
     */
    'passport'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateSoleProprietorApplicationAttributes
     */
    'nationality'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateSoleProprietorApplicationAttributes
     */
    'matriculaConsular'?: string | null;
    /**
     * 
     * @type {Address}
     * @memberof CreateSoleProprietorApplicationAttributes
     */
    'address': Address;
    /**
     * 
     * @type {string}
     * @memberof CreateSoleProprietorApplicationAttributes
     */
    'dateOfBirth': string;
    /**
     * 
     * @type {string}
     * @memberof CreateSoleProprietorApplicationAttributes
     */
    'dba'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateSoleProprietorApplicationAttributes
     */
    'ein'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateSoleProprietorApplicationAttributes
     */
    'ip'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateSoleProprietorApplicationAttributes
     */
    'soleProprietorship'?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateSoleProprietorApplicationAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof CreateSoleProprietorApplicationAttributes
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {Array<DeviceFingerprint>}
     * @memberof CreateSoleProprietorApplicationAttributes
     */
    'deviceFingerprints'?: Array<DeviceFingerprint>;
    /**
     * 
     * @type {string}
     * @memberof CreateSoleProprietorApplicationAttributes
     */
    'jwtSubject'?: string | null;
    /**
     * 
     * @type {CreatePowerOfAttorneyAgent}
     * @memberof CreateSoleProprietorApplicationAttributes
     */
    'powerOfAttorneyAgent'?: CreatePowerOfAttorneyAgent;
    /**
     * 
     * @type {Industry}
     * @memberof CreateSoleProprietorApplicationAttributes
     */
    'industry'?: Industry;
    /**
     * 
     * @type {EvaluationParams}
     * @memberof CreateSoleProprietorApplicationAttributes
     */
    'EvaluationParams'?: EvaluationParams;
    /**
     * 
     * @type {Occupation}
     * @memberof CreateSoleProprietorApplicationAttributes
     */
    'occupation'?: Occupation;
    /**
     * 
     * @type {AnnualIncome}
     * @memberof CreateSoleProprietorApplicationAttributes
     */
    'annualIncome'?: AnnualIncome;
    /**
     * 
     * @type {SourceOfIncome}
     * @memberof CreateSoleProprietorApplicationAttributes
     */
    'sourceOfIncome'?: SourceOfIncome;
    /**
     * 
     * @type {SoleProprietorshipAnnualRevenue}
     * @memberof CreateSoleProprietorApplicationAttributes
     */
    'annualRevenue'?: SoleProprietorshipAnnualRevenue;
    /**
     * 
     * @type {SoleProprietorshipNumberOfEmployees}
     * @memberof CreateSoleProprietorApplicationAttributes
     */
    'numberOfEmployees'?: SoleProprietorshipNumberOfEmployees;
    /**
     * 
     * @type {BusinessVertical}
     * @memberof CreateSoleProprietorApplicationAttributes
     */
    'businessVertical'?: BusinessVertical;
    /**
     * 
     * @type {string}
     * @memberof CreateSoleProprietorApplicationAttributes
     */
    'website'?: string;
}


/**
 * 
 * @export
 * @interface CreateStopPaymentRequest
 */
export interface CreateStopPaymentRequest {
    /**
     * 
     * @type {CreateStopPaymentRequestData}
     * @memberof CreateStopPaymentRequest
     */
    'data': CreateStopPaymentRequestData;
}
/**
 * @type CreateStopPaymentRequestData
 * @export
 */
export type CreateStopPaymentRequestData = CreateAchStopPayment | CreateCheckStopPayment;

/**
 * 
 * @export
 * @interface CreateWebhook
 */
export interface CreateWebhook {
    /**
     * 
     * @type {CreateWebhookData}
     * @memberof CreateWebhook
     */
    'data'?: CreateWebhookData;
}
/**
 * 
 * @export
 * @interface CreateWebhookData
 */
export interface CreateWebhookData {
    /**
     * 
     * @type {string}
     * @memberof CreateWebhookData
     */
    'type'?: string;
    /**
     * 
     * @type {CreateWebhookDataAttributes}
     * @memberof CreateWebhookData
     */
    'attributes'?: CreateWebhookDataAttributes;
}
/**
 * 
 * @export
 * @interface CreateWebhookDataAttributes
 */
export interface CreateWebhookDataAttributes {
    /**
     * 
     * @type {string}
     * @memberof CreateWebhookDataAttributes
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof CreateWebhookDataAttributes
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof CreateWebhookDataAttributes
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof CreateWebhookDataAttributes
     */
    'contentType': CreateWebhookDataAttributesContentTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateWebhookDataAttributes
     */
    'deliveryMode': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateWebhookDataAttributes
     */
    'includeResources'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateWebhookDataAttributes
     */
    'subscriptionType'?: CreateWebhookDataAttributesSubscriptionTypeEnum;
}

export const CreateWebhookDataAttributesContentTypeEnum = {
    Json: 'Json',
    JsonApi: 'JsonAPI'
} as const;

export type CreateWebhookDataAttributesContentTypeEnum = typeof CreateWebhookDataAttributesContentTypeEnum[keyof typeof CreateWebhookDataAttributesContentTypeEnum];
export const CreateWebhookDataAttributesSubscriptionTypeEnum = {
    All: 'All',
    OnlyAuthorizationRequest: 'OnlyAuthorizationRequest'
} as const;

export type CreateWebhookDataAttributesSubscriptionTypeEnum = typeof CreateWebhookDataAttributesSubscriptionTypeEnum[keyof typeof CreateWebhookDataAttributesSubscriptionTypeEnum];

/**
 * 
 * @export
 * @interface CreateWirePayment
 */
export interface CreateWirePayment {
    /**
     * 
     * @type {string}
     * @memberof CreateWirePayment
     */
    'type'?: CreateWirePaymentTypeEnum;
    /**
     * 
     * @type {CreateWirePaymentAttributes}
     * @memberof CreateWirePayment
     */
    'attributes': CreateWirePaymentAttributes;
    /**
     * 
     * @type {CreateWirePaymentRelationships}
     * @memberof CreateWirePayment
     */
    'relationships': CreateWirePaymentRelationships;
}

export const CreateWirePaymentTypeEnum = {
    WirePayment: 'wirePayment'
} as const;

export type CreateWirePaymentTypeEnum = typeof CreateWirePaymentTypeEnum[keyof typeof CreateWirePaymentTypeEnum];

/**
 * 
 * @export
 * @interface CreateWirePaymentAttributes
 */
export interface CreateWirePaymentAttributes {
    /**
     * 
     * @type {number}
     * @memberof CreateWirePaymentAttributes
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof CreateWirePaymentAttributes
     */
    'direction'?: CreateWirePaymentAttributesDirectionEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateWirePaymentAttributes
     */
    'description': string;
    /**
     * 
     * @type {WirePaymentCounterparty}
     * @memberof CreateWirePaymentAttributes
     */
    'counterparty': WirePaymentCounterparty;
    /**
     * 
     * @type {string}
     * @memberof CreateWirePaymentAttributes
     */
    'idempotencyKey'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateWirePaymentAttributes
     */
    'tags'?: { [key: string]: string; };
}

export const CreateWirePaymentAttributesDirectionEnum = {
    Credit: 'Credit'
} as const;

export type CreateWirePaymentAttributesDirectionEnum = typeof CreateWirePaymentAttributesDirectionEnum[keyof typeof CreateWirePaymentAttributesDirectionEnum];

/**
 * 
 * @export
 * @interface CreateWirePaymentRelationships
 */
export interface CreateWirePaymentRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof CreateWirePaymentRelationships
     */
    'account': AccountRelationship;
}
/**
 * 
 * @export
 * @interface CreditAccount
 */
export interface CreditAccount extends Account {
    /**
     * 
     * @type {CreditAccountAllOfAttributes}
     * @memberof CreditAccount
     */
    'attributes': CreditAccountAllOfAttributes;
    /**
     * 
     * @type {CreditAccountAllOfRelationships}
     * @memberof CreditAccount
     */
    'relationships': CreditAccountAllOfRelationships;
}


/**
 * 
 * @export
 * @interface CreditAccountAllOfAttributes
 */
export interface CreditAccountAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof CreditAccountAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CreditAccountAllOfAttributes
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreditAccountAllOfAttributes
     */
    'creditTerms': string;
    /**
     * 
     * @type {string}
     * @memberof CreditAccountAllOfAttributes
     */
    'currency': string;
    /**
     * 
     * @type {number}
     * @memberof CreditAccountAllOfAttributes
     */
    'balance': number;
    /**
     * 
     * @type {number}
     * @memberof CreditAccountAllOfAttributes
     */
    'hold': number;
    /**
     * 
     * @type {number}
     * @memberof CreditAccountAllOfAttributes
     */
    'available': number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreditAccountAllOfAttributes
     */
    'tags': { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof CreditAccountAllOfAttributes
     */
    'status': CreditAccountAllOfAttributesStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CreditAccountAllOfAttributes
     */
    'closeReason'?: CreditAccountAllOfAttributesCloseReasonEnum;
    /**
     * 
     * @type {string}
     * @memberof CreditAccountAllOfAttributes
     */
    'fraudReason'?: CreditAccountAllOfAttributesFraudReasonEnum;
    /**
     * 
     * @type {string}
     * @memberof CreditAccountAllOfAttributes
     */
    'closeReasonText'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreditAccountAllOfAttributes
     */
    'freezeReason'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreditAccountAllOfAttributes
     */
    'creditLimit': number;
    /**
     * 
     * @type {string}
     * @memberof CreditAccountAllOfAttributes
     */
    'updatedAt'?: string;
}

export const CreditAccountAllOfAttributesStatusEnum = {
    Open: 'Open',
    Closed: 'Closed',
    Frozen: 'Frozen'
} as const;

export type CreditAccountAllOfAttributesStatusEnum = typeof CreditAccountAllOfAttributesStatusEnum[keyof typeof CreditAccountAllOfAttributesStatusEnum];
export const CreditAccountAllOfAttributesCloseReasonEnum = {
    ByCustomer: 'ByCustomer',
    Fraud: 'Fraud',
    Overdue: 'Overdue',
    NegativeBalance: 'NegativeBalance',
    ByBank: 'ByBank',
    BreachOfTermsAndConditions: 'BreachOfTermsAndConditions',
    NoAccountActivity: 'NoAccountActivity',
    ProgramChange: 'ProgramChange'
} as const;

export type CreditAccountAllOfAttributesCloseReasonEnum = typeof CreditAccountAllOfAttributesCloseReasonEnum[keyof typeof CreditAccountAllOfAttributesCloseReasonEnum];
export const CreditAccountAllOfAttributesFraudReasonEnum = {
    AchActivity: 'ACHActivity',
    CardActivity: 'CardActivity',
    CheckActivity: 'CheckActivity',
    ApplicationHistory: 'ApplicationHistory',
    AccountActivity: 'AccountActivity',
    ClientIdentified: 'ClientIdentified',
    IdentityTheft: 'IdentityTheft',
    LinkedToFraudulentCustomer: 'LinkedToFraudulentCustomer'
} as const;

export type CreditAccountAllOfAttributesFraudReasonEnum = typeof CreditAccountAllOfAttributesFraudReasonEnum[keyof typeof CreditAccountAllOfAttributesFraudReasonEnum];

/**
 * 
 * @export
 * @interface CreditAccountAllOfRelationships
 */
export interface CreditAccountAllOfRelationships {
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof CreditAccountAllOfRelationships
     */
    'customer': CustomerRelationship;
}
/**
 * 
 * @export
 * @interface CreditAccountRelationship
 */
export interface CreditAccountRelationship {
    /**
     * 
     * @type {CreditAccountRelationshipData}
     * @memberof CreditAccountRelationship
     */
    'data': CreditAccountRelationshipData;
}
/**
 * 
 * @export
 * @interface CreditAccountRelationshipData
 */
export interface CreditAccountRelationshipData {
    /**
     * 
     * @type {string}
     * @memberof CreditAccountRelationshipData
     */
    'type': CreditAccountRelationshipDataTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreditAccountRelationshipData
     */
    'id': string;
}

export const CreditAccountRelationshipDataTypeEnum = {
    CreditAccount: 'creditAccount'
} as const;

export type CreditAccountRelationshipDataTypeEnum = typeof CreditAccountRelationshipDataTypeEnum[keyof typeof CreditAccountRelationshipDataTypeEnum];

/**
 * 
 * @export
 * @interface Customer
 */
export interface Customer {
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'type'?: CustomerTypeEnum;
}

export const CustomerTypeEnum = {
    IndividualCustomer: 'individualCustomer',
    BusinessCustomer: 'businessCustomer'
} as const;

export type CustomerTypeEnum = typeof CustomerTypeEnum[keyof typeof CustomerTypeEnum];

/**
 * 
 * @export
 * @interface CustomerRelationship
 */
export interface CustomerRelationship {
    /**
     * 
     * @type {CustomerRelationshipData}
     * @memberof CustomerRelationship
     */
    'data': CustomerRelationshipData;
}
/**
 * 
 * @export
 * @interface CustomerRelationshipData
 */
export interface CustomerRelationshipData {
    /**
     * 
     * @type {string}
     * @memberof CustomerRelationshipData
     */
    'type': CustomerRelationshipDataTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CustomerRelationshipData
     */
    'id': string;
}

export const CustomerRelationshipDataTypeEnum = {
    Customer: 'customer',
    BusinessCustomer: 'businessCustomer',
    IndividualCustomer: 'individualCustomer'
} as const;

export type CustomerRelationshipDataTypeEnum = typeof CustomerRelationshipDataTypeEnum[keyof typeof CustomerRelationshipDataTypeEnum];

/**
 * 
 * @export
 * @interface CustomerRelationships
 */
export interface CustomerRelationships {
    /**
     * 
     * @type {OrgRelationship}
     * @memberof CustomerRelationships
     */
    'org'?: OrgRelationship;
    /**
     * 
     * @type {ApplicationRelationship}
     * @memberof CustomerRelationships
     */
    'application'?: ApplicationRelationship;
}
/**
 * 
 * @export
 * @interface CustomerRepaymentReturnedTransaction
 */
export interface CustomerRepaymentReturnedTransaction extends Transaction {
    /**
     * 
     * @type {FeeTransactionAllOfAttributes}
     * @memberof CustomerRepaymentReturnedTransaction
     */
    'attributes': FeeTransactionAllOfAttributes;
    /**
     * 
     * @type {CustomerRepaymentReturnedTransactionRelationships}
     * @memberof CustomerRepaymentReturnedTransaction
     */
    'relationships': CustomerRepaymentReturnedTransactionRelationships;
}


/**
 * 
 * @export
 * @interface CustomerRepaymentReturnedTransactionRelationships
 */
export interface CustomerRepaymentReturnedTransactionRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof CustomerRepaymentReturnedTransactionRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof CustomerRepaymentReturnedTransactionRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof CustomerRepaymentReturnedTransactionRelationships
     */
    'customers'?: CustomersRelationship;
    /**
     * 
     * @type {OrgRelationship}
     * @memberof CustomerRepaymentReturnedTransactionRelationships
     */
    'org'?: OrgRelationship;
    /**
     * 
     * @type {RepaymentRelationship}
     * @memberof CustomerRepaymentReturnedTransactionRelationships
     */
    'repayment': RepaymentRelationship;
}
/**
 * 
 * @export
 * @interface CustomerRepaymentTransaction
 */
export interface CustomerRepaymentTransaction extends Transaction {
    /**
     * 
     * @type {FeeTransactionAllOfAttributes}
     * @memberof CustomerRepaymentTransaction
     */
    'attributes': FeeTransactionAllOfAttributes;
    /**
     * 
     * @type {CustomerRepaymentTransactionRelationships}
     * @memberof CustomerRepaymentTransaction
     */
    'relationships': CustomerRepaymentTransactionRelationships;
}


/**
 * 
 * @export
 * @interface CustomerRepaymentTransactionRelationships
 */
export interface CustomerRepaymentTransactionRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof CustomerRepaymentTransactionRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof CustomerRepaymentTransactionRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof CustomerRepaymentTransactionRelationships
     */
    'customers'?: CustomersRelationship;
    /**
     * 
     * @type {OrgRelationship}
     * @memberof CustomerRepaymentTransactionRelationships
     */
    'org'?: OrgRelationship;
    /**
     * 
     * @type {RepaymentRelationship}
     * @memberof CustomerRepaymentTransactionRelationships
     */
    'repayment': RepaymentRelationship;
}
/**
 * 
 * @export
 * @interface CustomerToken
 */
export interface CustomerToken {
    /**
     * 
     * @type {string}
     * @memberof CustomerToken
     */
    'type': CustomerTokenTypeEnum;
    /**
     * 
     * @type {CustomerTokenAttributes}
     * @memberof CustomerToken
     */
    'attributes': CustomerTokenAttributes;
}

export const CustomerTokenTypeEnum = {
    CustomerBearerToken: 'customerBearerToken'
} as const;

export type CustomerTokenTypeEnum = typeof CustomerTokenTypeEnum[keyof typeof CustomerTokenTypeEnum];

/**
 * 
 * @export
 * @interface CustomerTokenAttributes
 */
export interface CustomerTokenAttributes {
    /**
     * 
     * @type {string}
     * @memberof CustomerTokenAttributes
     */
    'token'?: string;
    /**
     * 
     * @type {number}
     * @memberof CustomerTokenAttributes
     */
    'expiresIn'?: number;
}
/**
 * 
 * @export
 * @interface CustomerTokenVerification
 */
export interface CustomerTokenVerification {
    /**
     * 
     * @type {string}
     * @memberof CustomerTokenVerification
     */
    'type': CustomerTokenVerificationTypeEnum;
    /**
     * 
     * @type {CustomerTokenVerificationAttributes}
     * @memberof CustomerTokenVerification
     */
    'attributes': CustomerTokenVerificationAttributes;
}

export const CustomerTokenVerificationTypeEnum = {
    CustomerTokenVerification: 'customerTokenVerification'
} as const;

export type CustomerTokenVerificationTypeEnum = typeof CustomerTokenVerificationTypeEnum[keyof typeof CustomerTokenVerificationTypeEnum];

/**
 * 
 * @export
 * @interface CustomerTokenVerificationAttributes
 */
export interface CustomerTokenVerificationAttributes {
    /**
     * 
     * @type {string}
     * @memberof CustomerTokenVerificationAttributes
     */
    'verificationToken'?: string;
}
/**
 * 
 * @export
 * @interface CustomersRelationship
 */
export interface CustomersRelationship {
    /**
     * 
     * @type {Array<CustomersRelationshipDataInner>}
     * @memberof CustomersRelationship
     */
    'data': Array<CustomersRelationshipDataInner>;
}
/**
 * 
 * @export
 * @interface CustomersRelationshipDataInner
 */
export interface CustomersRelationshipDataInner {
    /**
     * 
     * @type {string}
     * @memberof CustomersRelationshipDataInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomersRelationshipDataInner
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface DeclineAuthorizationRequest
 */
export interface DeclineAuthorizationRequest {
    /**
     * 
     * @type {DeclineAuthorizationRequest}
     * @memberof DeclineAuthorizationRequest
     */
    'data'?: DeclineAuthorizationRequest;
}
/**
 * 
 * @export
 * @interface DeclineAuthorizationRequestAttributes
 */
export interface DeclineAuthorizationRequestAttributes {
    /**
     * 
     * @type {string}
     * @memberof DeclineAuthorizationRequestAttributes
     */
    'reason'?: DeclineAuthorizationRequestAttributesReasonEnum;
}

export const DeclineAuthorizationRequestAttributesReasonEnum = {
    AccountClosed: 'AccountClosed',
    CardExceedsAmountLimit: 'CardExceedsAmountLimit',
    DoNotHonor: 'DoNotHonor',
    InsufficientFunds: 'InsufficientFunds',
    InvalidMerchant: 'InvalidMerchant',
    ReferToCardIssuer: 'ReferToCardIssuer',
    RestrictedCard: 'RestrictedCard',
    TransactionNotPermittedToCardholder: 'TransactionNotPermittedToCardholder'
} as const;

export type DeclineAuthorizationRequestAttributesReasonEnum = typeof DeclineAuthorizationRequestAttributesReasonEnum[keyof typeof DeclineAuthorizationRequestAttributesReasonEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const DefaultContentType = {
    ApplicationVndApijson: 'application/vnd.api+json'
} as const;

export type DefaultContentType = typeof DefaultContentType[keyof typeof DefaultContentType];


/**
 * 
 * @export
 * @interface DefaultTransactionRelationships
 */
export interface DefaultTransactionRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof DefaultTransactionRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof DefaultTransactionRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof DefaultTransactionRelationships
     */
    'customers'?: CustomersRelationship;
}
/**
 * 
 * @export
 * @interface DepositAccount
 */
export interface DepositAccount extends Account {
    /**
     * 
     * @type {DepositAccountAllOfAttributes}
     * @memberof DepositAccount
     */
    'attributes': DepositAccountAllOfAttributes;
    /**
     * 
     * @type {DepositAccountAllOfRelationships}
     * @memberof DepositAccount
     */
    'relationships': DepositAccountAllOfRelationships;
}


/**
 * 
 * @export
 * @interface DepositAccountAllOfAttributes
 */
export interface DepositAccountAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof DepositAccountAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof DepositAccountAllOfAttributes
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DepositAccountAllOfAttributes
     */
    'depositProduct': string;
    /**
     * 
     * @type {string}
     * @memberof DepositAccountAllOfAttributes
     */
    'routingNumber': string;
    /**
     * 
     * @type {string}
     * @memberof DepositAccountAllOfAttributes
     */
    'accountNumber'?: string;
    /**
     * 
     * @type {DepositAccountAllOfAttributesSecondaryAccountNumber}
     * @memberof DepositAccountAllOfAttributes
     */
    'secondaryAccountNumber'?: DepositAccountAllOfAttributesSecondaryAccountNumber;
    /**
     * 
     * @type {string}
     * @memberof DepositAccountAllOfAttributes
     */
    'currency': string;
    /**
     * 
     * @type {number}
     * @memberof DepositAccountAllOfAttributes
     */
    'balance': number;
    /**
     * 
     * @type {number}
     * @memberof DepositAccountAllOfAttributes
     */
    'overdraftLimit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DepositAccountAllOfAttributes
     */
    'hold': number;
    /**
     * 
     * @type {number}
     * @memberof DepositAccountAllOfAttributes
     */
    'available': number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DepositAccountAllOfAttributes
     */
    'tags': { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof DepositAccountAllOfAttributes
     */
    'status': DepositAccountAllOfAttributesStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof DepositAccountAllOfAttributes
     */
    'closeReason'?: DepositAccountAllOfAttributesCloseReasonEnum;
    /**
     * 
     * @type {string}
     * @memberof DepositAccountAllOfAttributes
     */
    'fraudReason'?: DepositAccountAllOfAttributesFraudReasonEnum;
    /**
     * 
     * @type {string}
     * @memberof DepositAccountAllOfAttributes
     */
    'closeReasonText'?: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAccountAllOfAttributes
     */
    'freezeReason'?: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAccountAllOfAttributes
     */
    'maskedAccountNumber'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DepositAccountAllOfAttributes
     */
    'isOverdrawnWithinLimit'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DepositAccountAllOfAttributes
     */
    'dacaStatus'?: DepositAccountAllOfAttributesDacaStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof DepositAccountAllOfAttributes
     */
    'updatedAt'?: string;
}

export const DepositAccountAllOfAttributesStatusEnum = {
    Open: 'Open',
    Closed: 'Closed',
    Frozen: 'Frozen'
} as const;

export type DepositAccountAllOfAttributesStatusEnum = typeof DepositAccountAllOfAttributesStatusEnum[keyof typeof DepositAccountAllOfAttributesStatusEnum];
export const DepositAccountAllOfAttributesCloseReasonEnum = {
    ByCustomer: 'ByCustomer',
    Fraud: 'Fraud',
    NegativeBalance: 'NegativeBalance',
    ByBank: 'ByBank',
    BreachOfTermsAndConditions: 'BreachOfTermsAndConditions',
    NoAccountActivity: 'NoAccountActivity',
    ProgramChange: 'ProgramChange'
} as const;

export type DepositAccountAllOfAttributesCloseReasonEnum = typeof DepositAccountAllOfAttributesCloseReasonEnum[keyof typeof DepositAccountAllOfAttributesCloseReasonEnum];
export const DepositAccountAllOfAttributesFraudReasonEnum = {
    AchActivity: 'ACHActivity',
    CardActivity: 'CardActivity',
    CheckActivity: 'CheckActivity',
    ApplicationHistory: 'ApplicationHistory',
    AccountActivity: 'AccountActivity',
    ClientIdentified: 'ClientIdentified',
    IdentityTheft: 'IdentityTheft',
    LinkedToFraudulentCustomer: 'LinkedToFraudulentCustomer'
} as const;

export type DepositAccountAllOfAttributesFraudReasonEnum = typeof DepositAccountAllOfAttributesFraudReasonEnum[keyof typeof DepositAccountAllOfAttributesFraudReasonEnum];
export const DepositAccountAllOfAttributesDacaStatusEnum = {
    Activated: 'Activated',
    Entered: 'Entered'
} as const;

export type DepositAccountAllOfAttributesDacaStatusEnum = typeof DepositAccountAllOfAttributesDacaStatusEnum[keyof typeof DepositAccountAllOfAttributesDacaStatusEnum];

/**
 * 
 * @export
 * @interface DepositAccountAllOfAttributesSecondaryAccountNumber
 */
export interface DepositAccountAllOfAttributesSecondaryAccountNumber {
    /**
     * 
     * @type {string}
     * @memberof DepositAccountAllOfAttributesSecondaryAccountNumber
     */
    'routingNumber': string;
    /**
     * 
     * @type {string}
     * @memberof DepositAccountAllOfAttributesSecondaryAccountNumber
     */
    'accountNumber': string;
}
/**
 * 
 * @export
 * @interface DepositAccountAllOfRelationships
 */
export interface DepositAccountAllOfRelationships {
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof DepositAccountAllOfRelationships
     */
    'customer'?: CustomerRelationship;
}
/**
 * 
 * @export
 * @interface DeviceFingerprint
 */
export interface DeviceFingerprint {
    /**
     * 
     * @type {string}
     * @memberof DeviceFingerprint
     */
    'provider': DeviceFingerprintProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof DeviceFingerprint
     */
    'value': string;
}

export const DeviceFingerprintProviderEnum = {
    Iovation: 'iovation'
} as const;

export type DeviceFingerprintProviderEnum = typeof DeviceFingerprintProviderEnum[keyof typeof DeviceFingerprintProviderEnum];

/**
 * 
 * @export
 * @interface DishonoredAchTransaction
 */
export interface DishonoredAchTransaction extends Transaction {
    /**
     * 
     * @type {DishonoredAchTransactionAllOfAttributes}
     * @memberof DishonoredAchTransaction
     */
    'attributes': DishonoredAchTransactionAllOfAttributes;
    /**
     * 
     * @type {DishonoredAchTransactionRelationships}
     * @memberof DishonoredAchTransaction
     */
    'relationships': DishonoredAchTransactionRelationships;
}


/**
 * 
 * @export
 * @interface DishonoredAchTransactionAllOfAttributes
 */
export interface DishonoredAchTransactionAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof DishonoredAchTransactionAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof DishonoredAchTransactionAllOfAttributes
     */
    'direction': DishonoredAchTransactionAllOfAttributesDirectionEnum;
    /**
     * 
     * @type {number}
     * @memberof DishonoredAchTransactionAllOfAttributes
     */
    'amount': number;
    /**
     * 
     * @type {number}
     * @memberof DishonoredAchTransactionAllOfAttributes
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof DishonoredAchTransactionAllOfAttributes
     */
    'summary': string;
    /**
     * 
     * @type {string}
     * @memberof DishonoredAchTransactionAllOfAttributes
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof DishonoredAchTransactionAllOfAttributes
     */
    'companyName': string;
    /**
     * 
     * @type {string}
     * @memberof DishonoredAchTransactionAllOfAttributes
     */
    'counterpartyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof DishonoredAchTransactionAllOfAttributes
     */
    'counterpartyRoutingNumber': string;
    /**
     * 
     * @type {string}
     * @memberof DishonoredAchTransactionAllOfAttributes
     */
    'traceNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof DishonoredAchTransactionAllOfAttributes
     */
    'reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof DishonoredAchTransactionAllOfAttributes
     */
    'secCode'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DishonoredAchTransactionAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
}

export const DishonoredAchTransactionAllOfAttributesDirectionEnum = {
    Credit: 'Credit',
    Debit: 'Debit'
} as const;

export type DishonoredAchTransactionAllOfAttributesDirectionEnum = typeof DishonoredAchTransactionAllOfAttributesDirectionEnum[keyof typeof DishonoredAchTransactionAllOfAttributesDirectionEnum];

/**
 * 
 * @export
 * @interface DishonoredAchTransactionRelationships
 */
export interface DishonoredAchTransactionRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof DishonoredAchTransactionRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof DishonoredAchTransactionRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof DishonoredAchTransactionRelationships
     */
    'customers'?: CustomersRelationship;
}
/**
 * 
 * @export
 * @interface Dispute
 */
export interface Dispute {
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    'type': DisputeTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    'id': string;
    /**
     * 
     * @type {DisputeAttributes}
     * @memberof Dispute
     */
    'attributes'?: DisputeAttributes;
    /**
     * 
     * @type {DisputeRelationships}
     * @memberof Dispute
     */
    'relationships': DisputeRelationships;
}

export const DisputeTypeEnum = {
    Dispute: 'dispute'
} as const;

export type DisputeTypeEnum = typeof DisputeTypeEnum[keyof typeof DisputeTypeEnum];

/**
 * 
 * @export
 * @interface DisputeAttributes
 */
export interface DisputeAttributes {
    /**
     * 
     * @type {string}
     * @memberof DisputeAttributes
     */
    'source': DisputeAttributesSourceEnum;
    /**
     * 
     * @type {string}
     * @memberof DisputeAttributes
     */
    'externalId': string;
    /**
     * 
     * @type {string}
     * @memberof DisputeAttributes
     */
    'link'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisputeAttributes
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof DisputeAttributes
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof DisputeAttributes
     */
    'status': string;
    /**
     * 
     * @type {Array<DisputeAttributesStatusHistoryInner>}
     * @memberof DisputeAttributes
     */
    'statusHistory'?: Array<DisputeAttributesStatusHistoryInner>;
    /**
     * 
     * @type {string}
     * @memberof DisputeAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof DisputeAttributes
     */
    'decisionReason'?: string;
}

export const DisputeAttributesSourceEnum = {
    DebitCard: 'DebitCard',
    Ach: 'ACH'
} as const;

export type DisputeAttributesSourceEnum = typeof DisputeAttributesSourceEnum[keyof typeof DisputeAttributesSourceEnum];

/**
 * 
 * @export
 * @interface DisputeAttributesStatusHistoryInner
 */
export interface DisputeAttributesStatusHistoryInner {
    /**
     * 
     * @type {string}
     * @memberof DisputeAttributesStatusHistoryInner
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisputeAttributesStatusHistoryInner
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface DisputeRelationships
 */
export interface DisputeRelationships {
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof DisputeRelationships
     */
    'customer': CustomerRelationship;
    /**
     * 
     * @type {AccountRelationship}
     * @memberof DisputeRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {TransactionRelationship}
     * @memberof DisputeRelationships
     */
    'transaction': TransactionRelationship;
}
/**
 * 
 * @export
 * @interface DisputeTransaction
 */
export interface DisputeTransaction extends Transaction {
    /**
     * 
     * @type {DisputeTransactionAllOfAttributes}
     * @memberof DisputeTransaction
     */
    'attributes': DisputeTransactionAllOfAttributes;
    /**
     * 
     * @type {DisputeTransactionRelationships}
     * @memberof DisputeTransaction
     */
    'relationships': DisputeTransactionRelationships;
}


/**
 * 
 * @export
 * @interface DisputeTransactionAllOfAttributes
 */
export interface DisputeTransactionAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof DisputeTransactionAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof DisputeTransactionAllOfAttributes
     */
    'direction': DisputeTransactionAllOfAttributesDirectionEnum;
    /**
     * 
     * @type {number}
     * @memberof DisputeTransactionAllOfAttributes
     */
    'amount': number;
    /**
     * 
     * @type {number}
     * @memberof DisputeTransactionAllOfAttributes
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof DisputeTransactionAllOfAttributes
     */
    'summary': string;
    /**
     * 
     * @type {string}
     * @memberof DisputeTransactionAllOfAttributes
     */
    'reason': string;
    /**
     * 
     * @type {string}
     * @memberof DisputeTransactionAllOfAttributes
     */
    'disputeId': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DisputeTransactionAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
}

export const DisputeTransactionAllOfAttributesDirectionEnum = {
    Credit: 'Credit',
    Debit: 'Debit'
} as const;

export type DisputeTransactionAllOfAttributesDirectionEnum = typeof DisputeTransactionAllOfAttributesDirectionEnum[keyof typeof DisputeTransactionAllOfAttributesDirectionEnum];

/**
 * 
 * @export
 * @interface DisputeTransactionRelationships
 */
export interface DisputeTransactionRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof DisputeTransactionRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof DisputeTransactionRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof DisputeTransactionRelationships
     */
    'customers'?: CustomersRelationship;
    /**
     * 
     * @type {DisputedTransactionRelationship}
     * @memberof DisputeTransactionRelationships
     */
    'disputedTransaction': DisputedTransactionRelationship;
}
/**
 * 
 * @export
 * @interface DisputedTransactionRelationship
 */
export interface DisputedTransactionRelationship {
    /**
     * 
     * @type {TransactionRelationshipData}
     * @memberof DisputedTransactionRelationship
     */
    'data': TransactionRelationshipData;
}
/**
 * 
 * @export
 * @interface DocumentsRelationship
 */
export interface DocumentsRelationship {
    /**
     * 
     * @type {Array<DocumentsRelationshipDataInner>}
     * @memberof DocumentsRelationship
     */
    'data'?: Array<DocumentsRelationshipDataInner>;
}
/**
 * 
 * @export
 * @interface DocumentsRelationshipDataInner
 */
export interface DocumentsRelationshipDataInner {
    /**
     * 
     * @type {string}
     * @memberof DocumentsRelationshipDataInner
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentsRelationshipDataInner
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const EntityType = {
    Corporation: 'Corporation',
    Llc: 'LLC',
    Partnership: 'Partnership',
    PubliclyTradedCorporation: 'PubliclyTradedCorporation',
    PrivatelyHeldCorporation: 'PrivatelyHeldCorporation',
    NotForProfitOrganization: 'NotForProfitOrganization'
} as const;

export type EntityType = typeof EntityType[keyof typeof EntityType];


/**
 * 
 * @export
 * @interface EvaluationParams
 */
export interface EvaluationParams {
    /**
     * 
     * @type {string}
     * @memberof EvaluationParams
     */
    'useSelfieVerification'?: EvaluationParamsUseSelfieVerificationEnum;
    /**
     * 
     * @type {boolean}
     * @memberof EvaluationParams
     */
    'requireIdVerification'?: boolean;
}

export const EvaluationParamsUseSelfieVerificationEnum = {
    Never: 'Never',
    ReplaceIdentification: 'ReplaceIdentification',
    Always: 'Always'
} as const;

export type EvaluationParamsUseSelfieVerificationEnum = typeof EvaluationParamsUseSelfieVerificationEnum[keyof typeof EvaluationParamsUseSelfieVerificationEnum];

/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'id': string;
    /**
     * 
     * @type {object}
     * @memberof Event
     */
    'attributes'?: object;
    /**
     * 
     * @type {object}
     * @memberof Event
     */
    'relationships'?: object;
}
/**
 * 
 * @export
 * @interface Fee
 */
export interface Fee {
    /**
     * 
     * @type {string}
     * @memberof Fee
     */
    'type'?: FeeTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Fee
     */
    'id'?: string;
    /**
     * 
     * @type {FeeAttributes}
     * @memberof Fee
     */
    'attributes'?: FeeAttributes;
    /**
     * 
     * @type {FeeRelationships}
     * @memberof Fee
     */
    'relationships'?: FeeRelationships;
}

export const FeeTypeEnum = {
    Fee: 'fee'
} as const;

export type FeeTypeEnum = typeof FeeTypeEnum[keyof typeof FeeTypeEnum];

/**
 * 
 * @export
 * @interface FeeAttributes
 */
export interface FeeAttributes {
    /**
     * 
     * @type {number}
     * @memberof FeeAttributes
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof FeeAttributes
     */
    'description': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof FeeAttributes
     */
    'tags'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface FeeRelationships
 */
export interface FeeRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof FeeRelationships
     */
    'account': AccountRelationship;
}
/**
 * 
 * @export
 * @interface FeeReversalTransaction
 */
export interface FeeReversalTransaction extends Transaction {
    /**
     * 
     * @type {FeeTransactionAllOfAttributes}
     * @memberof FeeReversalTransaction
     */
    'attributes': FeeTransactionAllOfAttributes;
    /**
     * 
     * @type {FeeReversalTransactionRelationships}
     * @memberof FeeReversalTransaction
     */
    'relationships': FeeReversalTransactionRelationships;
}


/**
 * 
 * @export
 * @interface FeeReversalTransactionRelationships
 */
export interface FeeReversalTransactionRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof FeeReversalTransactionRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof FeeReversalTransactionRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof FeeReversalTransactionRelationships
     */
    'customers'?: CustomersRelationship;
    /**
     * 
     * @type {TransactionRelationshipData}
     * @memberof FeeReversalTransactionRelationships
     */
    'data': TransactionRelationshipData;
}
/**
 * 
 * @export
 * @interface FeeTransaction
 */
export interface FeeTransaction extends Transaction {
    /**
     * 
     * @type {FeeTransactionAllOfAttributes}
     * @memberof FeeTransaction
     */
    'attributes': FeeTransactionAllOfAttributes;
    /**
     * 
     * @type {FeeTransactionRelationships}
     * @memberof FeeTransaction
     */
    'relationships': FeeTransactionRelationships;
}


/**
 * 
 * @export
 * @interface FeeTransactionAllOfAttributes
 */
export interface FeeTransactionAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof FeeTransactionAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof FeeTransactionAllOfAttributes
     */
    'direction': FeeTransactionAllOfAttributesDirectionEnum;
    /**
     * 
     * @type {number}
     * @memberof FeeTransactionAllOfAttributes
     */
    'amount': number;
    /**
     * 
     * @type {number}
     * @memberof FeeTransactionAllOfAttributes
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof FeeTransactionAllOfAttributes
     */
    'summary': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof FeeTransactionAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
}

export const FeeTransactionAllOfAttributesDirectionEnum = {
    Credit: 'Credit',
    Debit: 'Debit'
} as const;

export type FeeTransactionAllOfAttributesDirectionEnum = typeof FeeTransactionAllOfAttributesDirectionEnum[keyof typeof FeeTransactionAllOfAttributesDirectionEnum];

/**
 * 
 * @export
 * @interface FeeTransactionRelationships
 */
export interface FeeTransactionRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof FeeTransactionRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof FeeTransactionRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof FeeTransactionRelationships
     */
    'customers'?: CustomersRelationship;
    /**
     * 
     * @type {TransactionRelationshipData}
     * @memberof FeeTransactionRelationships
     */
    'data': TransactionRelationshipData;
}
/**
 * 
 * @export
 * @interface FreezeAccountRequest
 */
export interface FreezeAccountRequest {
    /**
     * 
     * @type {FreezeAccountRequest}
     * @memberof FreezeAccountRequest
     */
    'data'?: FreezeAccountRequest;
}
/**
 * 
 * @export
 * @interface FreezeAccountRequestAttributes
 */
export interface FreezeAccountRequestAttributes {
    /**
     * 
     * @type {string}
     * @memberof FreezeAccountRequestAttributes
     */
    'reason'?: FreezeAccountRequestAttributesReasonEnum;
    /**
     * 
     * @type {string}
     * @memberof FreezeAccountRequestAttributes
     */
    'reasonText'?: string | null;
}

export const FreezeAccountRequestAttributesReasonEnum = {
    Fraud: 'Fraud',
    Other: 'Other'
} as const;

export type FreezeAccountRequestAttributesReasonEnum = typeof FreezeAccountRequestAttributesReasonEnum[keyof typeof FreezeAccountRequestAttributesReasonEnum];

/**
 * 
 * @export
 * @interface FullName
 */
export interface FullName {
    /**
     * 
     * @type {string}
     * @memberof FullName
     */
    'first': string;
    /**
     * 
     * @type {string}
     * @memberof FullName
     */
    'last': string;
}
/**
 * 
 * @export
 * @interface FundingAccountRelationship
 */
export interface FundingAccountRelationship {
    /**
     * 
     * @type {FundingAccountRelationshipData}
     * @memberof FundingAccountRelationship
     */
    'data': FundingAccountRelationshipData;
}
/**
 * 
 * @export
 * @interface FundingAccountRelationshipData
 */
export interface FundingAccountRelationshipData {
    /**
     * 
     * @type {string}
     * @memberof FundingAccountRelationshipData
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof FundingAccountRelationshipData
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface GetAccountsListFilterParameter
 */
export interface GetAccountsListFilterParameter {
    /**
     * 
     * @type {string}
     * @memberof GetAccountsListFilterParameter
     */
    'customerId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetAccountsListFilterParameter
     */
    'status'?: Array<GetAccountsListFilterParameterStatusEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetAccountsListFilterParameter
     */
    'type'?: Array<GetAccountsListFilterParameterTypeEnum>;
    /**
     * 
     * @type {number}
     * @memberof GetAccountsListFilterParameter
     */
    'fromBalance'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetAccountsListFilterParameter
     */
    'toBalance'?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GetAccountsListFilterParameter
     */
    'tags'?: { [key: string]: string; };
}

export const GetAccountsListFilterParameterStatusEnum = {
    Open: 'Open',
    Frozen: 'Frozen',
    Closed: 'Closed'
} as const;

export type GetAccountsListFilterParameterStatusEnum = typeof GetAccountsListFilterParameterStatusEnum[keyof typeof GetAccountsListFilterParameterStatusEnum];
export const GetAccountsListFilterParameterTypeEnum = {
    Deposit: 'deposit',
    Credit: 'credit'
} as const;

export type GetAccountsListFilterParameterTypeEnum = typeof GetAccountsListFilterParameterTypeEnum[keyof typeof GetAccountsListFilterParameterTypeEnum];

/**
 * 
 * @export
 * @interface GetApplicationFormsListFilterParameter
 */
export interface GetApplicationFormsListFilterParameter {
    /**
     * 
     * @type {string}
     * @memberof GetApplicationFormsListFilterParameter
     */
    'query'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetApplicationFormsListFilterParameter
     */
    'status'?: Array<GetApplicationFormsListFilterParameterStatusEnum>;
    /**
     * 
     * @type {string}
     * @memberof GetApplicationFormsListFilterParameter
     */
    'email'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GetApplicationFormsListFilterParameter
     */
    'tags'?: { [key: string]: string; };
}

export const GetApplicationFormsListFilterParameterStatusEnum = {
    Pending: 'Pending',
    Approved: 'Approved'
} as const;

export type GetApplicationFormsListFilterParameterStatusEnum = typeof GetApplicationFormsListFilterParameterStatusEnum[keyof typeof GetApplicationFormsListFilterParameterStatusEnum];

/**
 * 
 * @export
 * @interface GetApplicationsListFilterParameter
 */
export interface GetApplicationsListFilterParameter {
    /**
     * 
     * @type {string}
     * @memberof GetApplicationsListFilterParameter
     */
    'query'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetApplicationsListFilterParameter
     */
    'status'?: Array<GetApplicationsListFilterParameterStatusEnum>;
    /**
     * 
     * @type {string}
     * @memberof GetApplicationsListFilterParameter
     */
    'email'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GetApplicationsListFilterParameter
     */
    'tags'?: { [key: string]: string; };
}

export const GetApplicationsListFilterParameterStatusEnum = {
    AwaitingDocuments: 'AwaitingDocuments',
    PendingReview: 'PendingReview',
    Pending: 'Pending',
    Approved: 'Approved',
    Denied: 'Denied',
    Canceled: 'Canceled'
} as const;

export type GetApplicationsListFilterParameterStatusEnum = typeof GetApplicationsListFilterParameterStatusEnum[keyof typeof GetApplicationsListFilterParameterStatusEnum];

/**
 * 
 * @export
 * @interface GetAtmLocationsListFilterParameter
 */
export interface GetAtmLocationsListFilterParameter {
    /**
     * 
     * @type {object}
     * @memberof GetAtmLocationsListFilterParameter
     */
    'coordinates'?: object;
    /**
     * 
     * @type {number}
     * @memberof GetAtmLocationsListFilterParameter
     */
    'searchRadius'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetAtmLocationsListFilterParameter
     */
    'postalCode'?: string;
    /**
     * 
     * @type {object}
     * @memberof GetAtmLocationsListFilterParameter
     */
    'address'?: object;
}
/**
 * 
 * @export
 * @interface GetAuthorizationRequestsListFilterParameter
 */
export interface GetAuthorizationRequestsListFilterParameter {
    /**
     * 
     * @type {string}
     * @memberof GetAuthorizationRequestsListFilterParameter
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetAuthorizationRequestsListFilterParameter
     */
    'customerId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetAuthorizationRequestsListFilterParameter
     */
    'merchantCategoryCode'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof GetAuthorizationRequestsListFilterParameter
     */
    'fromAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetAuthorizationRequestsListFilterParameter
     */
    'toAmount'?: number;
}
/**
 * 
 * @export
 * @interface GetAuthorizationsListFilterParameter
 */
export interface GetAuthorizationsListFilterParameter {
    /**
     * 
     * @type {string}
     * @memberof GetAuthorizationsListFilterParameter
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetAuthorizationsListFilterParameter
     */
    'accountType'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetAuthorizationsListFilterParameter
     */
    'customerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetAuthorizationsListFilterParameter
     */
    'cardId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetAuthorizationsListFilterParameter
     */
    'includeNonAuthorized'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetAuthorizationsListFilterParameter
     */
    'merchantCategoryCode'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GetAuthorizationsListFilterParameter
     */
    'since'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetAuthorizationsListFilterParameter
     */
    'until'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetAuthorizationsListFilterParameter
     */
    'fromAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetAuthorizationsListFilterParameter
     */
    'toAmount'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetAuthorizationsListFilterParameter
     */
    'status'?: Array<GetAuthorizationsListFilterParameterStatusEnum>;
}

export const GetAuthorizationsListFilterParameterStatusEnum = {
    Authorized: 'Authorized',
    Completed: 'Completed',
    Canceled: 'Canceled',
    Declined: 'Declined'
} as const;

export type GetAuthorizationsListFilterParameterStatusEnum = typeof GetAuthorizationsListFilterParameterStatusEnum[keyof typeof GetAuthorizationsListFilterParameterStatusEnum];

/**
 * 
 * @export
 * @interface GetCardsListFilterParameter
 */
export interface GetCardsListFilterParameter {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetCardsListFilterParameter
     */
    'status'?: Array<GetCardsListFilterParameterStatusEnum>;
    /**
     * 
     * @type {string}
     * @memberof GetCardsListFilterParameter
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetCardsListFilterParameter
     */
    'customerId'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GetCardsListFilterParameter
     */
    'tags'?: { [key: string]: string; };
}

export const GetCardsListFilterParameterStatusEnum = {
    Inactive: 'Inactive',
    Active: 'Active',
    Stolen: 'Stolen',
    Lost: 'Lost',
    Frozen: 'Frozen',
    ClosedByCustomer: 'ClosedByCustomer',
    SuspectedFraud: 'SuspectedFraud'
} as const;

export type GetCardsListFilterParameterStatusEnum = typeof GetCardsListFilterParameterStatusEnum[keyof typeof GetCardsListFilterParameterStatusEnum];

/**
 * 
 * @export
 * @interface GetCheckDepositsListFilterParameter
 */
export interface GetCheckDepositsListFilterParameter {
    /**
     * 
     * @type {string}
     * @memberof GetCheckDepositsListFilterParameter
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetCheckDepositsListFilterParameter
     */
    'customerId'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GetCheckDepositsListFilterParameter
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<string>}
     * @memberof GetCheckDepositsListFilterParameter
     */
    'status'?: Array<GetCheckDepositsListFilterParameterStatusEnum>;
}

export const GetCheckDepositsListFilterParameterStatusEnum = {
    AwaitingImages: 'AwaitingImages',
    AwaitingFrontImage: 'AwaitingFrontImage',
    AwaitingBackImage: 'AwaitingBackImage',
    Pending: 'Pending',
    PendingReview: 'PendingReview',
    Rejected: 'Rejected',
    Clearing: 'Clearing',
    Sent: 'Sent',
    Canceled: 'Canceled',
    Returned: 'Returned',
    AwaitingCustomerConfirmation: 'AwaitingCustomerConfirmation'
} as const;

export type GetCheckDepositsListFilterParameterStatusEnum = typeof GetCheckDepositsListFilterParameterStatusEnum[keyof typeof GetCheckDepositsListFilterParameterStatusEnum];

/**
 * 
 * @export
 * @interface GetCheckPaymentsListFilterParameter
 */
export interface GetCheckPaymentsListFilterParameter {
    /**
     * 
     * @type {string}
     * @memberof GetCheckPaymentsListFilterParameter
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetCheckPaymentsListFilterParameter
     */
    'customerId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetCheckPaymentsListFilterParameter
     */
    'status'?: Array<GetCheckPaymentsListFilterParameterStatusEnum>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GetCheckPaymentsListFilterParameter
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof GetCheckPaymentsListFilterParameter
     */
    'since'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetCheckPaymentsListFilterParameter
     */
    'until'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetCheckPaymentsListFilterParameter
     */
    'fromAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetCheckPaymentsListFilterParameter
     */
    'toAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetCheckPaymentsListFilterParameter
     */
    'checkNumber'?: string;
}

export const GetCheckPaymentsListFilterParameterStatusEnum = {
    New: 'New',
    Pending: 'Pending',
    Canceled: 'Canceled',
    Rejected: 'Rejected',
    InDelivery: 'InDelivery',
    InProduction: 'InProduction',
    Delivered: 'Delivered',
    ReturnedToSender: 'ReturnedToSender',
    Pending2: 'Pending',
    Processed: 'Processed',
    PendingReview: 'PendingReview',
    MarkedForReturn: 'MarkedForReturn',
    Returned: 'Returned'
} as const;

export type GetCheckPaymentsListFilterParameterStatusEnum = typeof GetCheckPaymentsListFilterParameterStatusEnum[keyof typeof GetCheckPaymentsListFilterParameterStatusEnum];

/**
 * 
 * @export
 * @interface GetCounterpartiesListFilterParameter
 */
export interface GetCounterpartiesListFilterParameter {
    /**
     * 
     * @type {string}
     * @memberof GetCounterpartiesListFilterParameter
     */
    'customerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetCounterpartiesListFilterParameter
     */
    'accountNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetCounterpartiesListFilterParameter
     */
    'routingNumber'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetCounterpartiesListFilterParameter
     */
    'permissions'?: Array<GetCounterpartiesListFilterParameterPermissionsEnum>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GetCounterpartiesListFilterParameter
     */
    'tags'?: { [key: string]: string; };
}

export const GetCounterpartiesListFilterParameterPermissionsEnum = {
    CreditOnly: 'CreditOnly',
    DebitOnly: 'DebitOnly',
    CreditAndDebit: 'CreditAndDebit'
} as const;

export type GetCounterpartiesListFilterParameterPermissionsEnum = typeof GetCounterpartiesListFilterParameterPermissionsEnum[keyof typeof GetCounterpartiesListFilterParameterPermissionsEnum];

/**
 * 
 * @export
 * @interface GetCustomersListFilterParameter
 */
export interface GetCustomersListFilterParameter {
    /**
     * 
     * @type {string}
     * @memberof GetCustomersListFilterParameter
     */
    'query'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetCustomersListFilterParameter
     */
    'status'?: Array<GetCustomersListFilterParameterStatusEnum>;
    /**
     * 
     * @type {string}
     * @memberof GetCustomersListFilterParameter
     */
    'email'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GetCustomersListFilterParameter
     */
    'tags'?: { [key: string]: string; };
}

export const GetCustomersListFilterParameterStatusEnum = {
    Active: 'Active',
    Archived: 'Archived'
} as const;

export type GetCustomersListFilterParameterStatusEnum = typeof GetCustomersListFilterParameterStatusEnum[keyof typeof GetCustomersListFilterParameterStatusEnum];

/**
 * 
 * @export
 * @interface GetDisputesListFilterParameter
 */
export interface GetDisputesListFilterParameter {
    /**
     * 
     * @type {string}
     * @memberof GetDisputesListFilterParameter
     */
    'query'?: string;
}
/**
 * 
 * @export
 * @interface GetEventsListFilterParameter
 */
export interface GetEventsListFilterParameter {
    /**
     * 
     * @type {string}
     * @memberof GetEventsListFilterParameter
     */
    'since'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetEventsListFilterParameter
     */
    'until'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetEventsListFilterParameter
     */
    'type'?: Array<string>;
}
/**
 * 
 * @export
 * @interface GetListRewardsFilterParameter
 */
export interface GetListRewardsFilterParameter {
    /**
     * 
     * @type {string}
     * @memberof GetListRewardsFilterParameter
     */
    'transactionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetListRewardsFilterParameter
     */
    'rewardedTransactionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetListRewardsFilterParameter
     */
    'receivingAccountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetListRewardsFilterParameter
     */
    'customerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetListRewardsFilterParameter
     */
    'cardId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetListRewardsFilterParameter
     */
    'since'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetListRewardsFilterParameter
     */
    'until'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetListRewardsFilterParameter
     */
    'status'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GetListRewardsFilterParameter
     */
    'tags'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface GetPaymentsListFilterParameter
 */
export interface GetPaymentsListFilterParameter {
    /**
     * 
     * @type {string}
     * @memberof GetPaymentsListFilterParameter
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetPaymentsListFilterParameter
     */
    'customerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetPaymentsListFilterParameter
     */
    'counterpartyAccountId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetPaymentsListFilterParameter
     */
    'status'?: Array<GetPaymentsListFilterParameterStatusEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetPaymentsListFilterParameter
     */
    'type'?: Array<GetPaymentsListFilterParameterTypeEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetPaymentsListFilterParameter
     */
    'direction'?: Array<GetPaymentsListFilterParameterDirectionEnum>;
    /**
     * 
     * @type {string}
     * @memberof GetPaymentsListFilterParameter
     */
    'since'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetPaymentsListFilterParameter
     */
    'until'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetPaymentsListFilterParameter
     */
    'fromAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetPaymentsListFilterParameter
     */
    'toAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetPaymentsListFilterParameter
     */
    'recurringPaymentId'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetPaymentsListFilterParameter
     */
    'feature'?: Array<GetPaymentsListFilterParameterFeatureEnum>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GetPaymentsListFilterParameter
     */
    'tags'?: { [key: string]: string; };
}

export const GetPaymentsListFilterParameterStatusEnum = {
    Rejected: 'Rejected',
    Pending: 'Pending',
    Canceled: 'Canceled',
    PendingReview: 'Pending Review',
    Clearing: 'Clearing',
    Sent: 'Sent',
    Returned: 'Returned'
} as const;

export type GetPaymentsListFilterParameterStatusEnum = typeof GetPaymentsListFilterParameterStatusEnum[keyof typeof GetPaymentsListFilterParameterStatusEnum];
export const GetPaymentsListFilterParameterTypeEnum = {
    AchPayment: 'AchPayment',
    BookPayment: 'BookPayment',
    WirePayment: 'WirePayment'
} as const;

export type GetPaymentsListFilterParameterTypeEnum = typeof GetPaymentsListFilterParameterTypeEnum[keyof typeof GetPaymentsListFilterParameterTypeEnum];
export const GetPaymentsListFilterParameterDirectionEnum = {
    Debit: 'Debit',
    Credit: 'Credit'
} as const;

export type GetPaymentsListFilterParameterDirectionEnum = typeof GetPaymentsListFilterParameterDirectionEnum[keyof typeof GetPaymentsListFilterParameterDirectionEnum];
export const GetPaymentsListFilterParameterFeatureEnum = {
    SameDay: 'SameDay',
    RecurringPayment: 'RecurringPayment'
} as const;

export type GetPaymentsListFilterParameterFeatureEnum = typeof GetPaymentsListFilterParameterFeatureEnum[keyof typeof GetPaymentsListFilterParameterFeatureEnum];

/**
 * 
 * @export
 * @interface GetRecurringPaymentsListFilterParameter
 */
export interface GetRecurringPaymentsListFilterParameter {
    /**
     * 
     * @type {string}
     * @memberof GetRecurringPaymentsListFilterParameter
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetRecurringPaymentsListFilterParameter
     */
    'customerId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetRecurringPaymentsListFilterParameter
     */
    'status'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetRecurringPaymentsListFilterParameter
     */
    'type'?: Array<GetRecurringPaymentsListFilterParameterTypeEnum>;
    /**
     * 
     * @type {string}
     * @memberof GetRecurringPaymentsListFilterParameter
     */
    'fromStartTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetRecurringPaymentsListFilterParameter
     */
    'toStartTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetRecurringPaymentsListFilterParameter
     */
    'fromEndTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetRecurringPaymentsListFilterParameter
     */
    'toEndTime'?: string;
}

export const GetRecurringPaymentsListFilterParameterTypeEnum = {
    RecurringCreditAchPayment: 'recurringCreditAchPayment',
    RecurringDebitAchPayment: 'recurringDebitAchPayment',
    RecurringCreditBookPayment: 'recurringCreditBookPayment'
} as const;

export type GetRecurringPaymentsListFilterParameterTypeEnum = typeof GetRecurringPaymentsListFilterParameterTypeEnum[keyof typeof GetRecurringPaymentsListFilterParameterTypeEnum];

/**
 * 
 * @export
 * @interface GetRecurringRepaymentsListFilterParameter
 */
export interface GetRecurringRepaymentsListFilterParameter {
    /**
     * 
     * @type {string}
     * @memberof GetRecurringRepaymentsListFilterParameter
     */
    'creditAccountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetRecurringRepaymentsListFilterParameter
     */
    'customerId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetRecurringRepaymentsListFilterParameter
     */
    'status'?: Array<GetRecurringRepaymentsListFilterParameterStatusEnum>;
    /**
     * 
     * @type {string}
     * @memberof GetRecurringRepaymentsListFilterParameter
     */
    'fromStartTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetRecurringRepaymentsListFilterParameter
     */
    'toStartTime'?: string;
}

export const GetRecurringRepaymentsListFilterParameterStatusEnum = {
    Active: 'Active',
    Disabled: 'Disabled'
} as const;

export type GetRecurringRepaymentsListFilterParameterStatusEnum = typeof GetRecurringRepaymentsListFilterParameterStatusEnum[keyof typeof GetRecurringRepaymentsListFilterParameterStatusEnum];

/**
 * 
 * @export
 * @interface GetRepaymentsListFilterParameter
 */
export interface GetRepaymentsListFilterParameter {
    /**
     * 
     * @type {string}
     * @memberof GetRepaymentsListFilterParameter
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetRepaymentsListFilterParameter
     */
    'creditAccountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetRepaymentsListFilterParameter
     */
    'customerId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetRepaymentsListFilterParameter
     */
    'status'?: Array<GetRepaymentsListFilterParameterStatusEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetRepaymentsListFilterParameter
     */
    'type'?: Array<GetRepaymentsListFilterParameterTypeEnum>;
}

export const GetRepaymentsListFilterParameterStatusEnum = {
    Pending: 'Pending',
    PendingReview: 'PendingReview',
    Returned: 'Returned',
    Sent: 'Sent',
    Rejected: 'Rejected'
} as const;

export type GetRepaymentsListFilterParameterStatusEnum = typeof GetRepaymentsListFilterParameterStatusEnum[keyof typeof GetRepaymentsListFilterParameterStatusEnum];
export const GetRepaymentsListFilterParameterTypeEnum = {
    AchRepayment: 'AchRepayment',
    BookRepayment: 'BookRepayment'
} as const;

export type GetRepaymentsListFilterParameterTypeEnum = typeof GetRepaymentsListFilterParameterTypeEnum[keyof typeof GetRepaymentsListFilterParameterTypeEnum];

/**
 * 
 * @export
 * @interface GetStatementsListFilterParameter
 */
export interface GetStatementsListFilterParameter {
    /**
     * 
     * @type {string}
     * @memberof GetStatementsListFilterParameter
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetStatementsListFilterParameter
     */
    'customerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetStatementsListFilterParameter
     */
    'period'?: string;
}
/**
 * 
 * @export
 * @interface GetStopPaymentsListFilterParameter
 */
export interface GetStopPaymentsListFilterParameter {
    /**
     * 
     * @type {string}
     * @memberof GetStopPaymentsListFilterParameter
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetStopPaymentsListFilterParameter
     */
    'customerId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetStopPaymentsListFilterParameter
     */
    'status'?: Array<GetStopPaymentsListFilterParameterStatusEnum>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GetStopPaymentsListFilterParameter
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof GetStopPaymentsListFilterParameter
     */
    'since'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetStopPaymentsListFilterParameter
     */
    'until'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetStopPaymentsListFilterParameter
     */
    'fromAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetStopPaymentsListFilterParameter
     */
    'toAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetStopPaymentsListFilterParameter
     */
    'checkNumber'?: string;
}

export const GetStopPaymentsListFilterParameterStatusEnum = {
    Active: 'Active',
    Disabled: 'Disabled'
} as const;

export type GetStopPaymentsListFilterParameterStatusEnum = typeof GetStopPaymentsListFilterParameterStatusEnum[keyof typeof GetStopPaymentsListFilterParameterStatusEnum];

/**
 * 
 * @export
 * @interface GetTransactionsListFilterParameter
 */
export interface GetTransactionsListFilterParameter {
    /**
     * 
     * @type {string}
     * @memberof GetTransactionsListFilterParameter
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetTransactionsListFilterParameter
     */
    'customerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetTransactionsListFilterParameter
     */
    'query'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GetTransactionsListFilterParameter
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof GetTransactionsListFilterParameter
     */
    'since'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetTransactionsListFilterParameter
     */
    'until'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetTransactionsListFilterParameter
     */
    'cardId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetTransactionsListFilterParameter
     */
    'excludeFees'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetTransactionsListFilterParameter
     */
    'type'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetTransactionsListFilterParameter
     */
    'direction'?: Array<GetTransactionsListFilterParameterDirectionEnum>;
    /**
     * 
     * @type {number}
     * @memberof GetTransactionsListFilterParameter
     */
    'fromAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetTransactionsListFilterParameter
     */
    'toAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetTransactionsListFilterParameter
     */
    'accountType'?: string;
}

export const GetTransactionsListFilterParameterDirectionEnum = {
    Debit: 'Debit',
    Credit: 'Credit'
} as const;

export type GetTransactionsListFilterParameterDirectionEnum = typeof GetTransactionsListFilterParameterDirectionEnum[keyof typeof GetTransactionsListFilterParameterDirectionEnum];

/**
 * 
 * @export
 * @interface GetWebhooksListFilterParameter
 */
export interface GetWebhooksListFilterParameter {
    /**
     * 
     * @type {string}
     * @memberof GetWebhooksListFilterParameter
     */
    'since'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetWebhooksListFilterParameter
     */
    'until'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetWebhooksListFilterParameter
     */
    'fromId'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetWebhooksListFilterParameter
     */
    'toId'?: number;
}
/**
 * 
 * @export
 * @interface HealthcareAmounts
 */
export interface HealthcareAmounts {
    /**
     * 
     * @type {number}
     * @memberof HealthcareAmounts
     */
    'transitAmount': number;
    /**
     * 
     * @type {number}
     * @memberof HealthcareAmounts
     */
    'prescriptionRXAmount': number;
    /**
     * 
     * @type {number}
     * @memberof HealthcareAmounts
     */
    'visionOpticalAmount': number;
    /**
     * 
     * @type {number}
     * @memberof HealthcareAmounts
     */
    'clinicOtherQualifiedMedicalAmount': number;
    /**
     * 
     * @type {number}
     * @memberof HealthcareAmounts
     */
    'dentalAmount': number;
    /**
     * 
     * @type {number}
     * @memberof HealthcareAmounts
     */
    'totalHealthcareAmount': number;
}
/**
 * 
 * @export
 * @interface IncludedResourceInner
 */
export interface IncludedResourceInner {
    /**
     * 
     * @type {string}
     * @memberof IncludedResourceInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IncludedResourceInner
     */
    'type'?: string;
    /**
     * 
     * @type {object}
     * @memberof IncludedResourceInner
     */
    'attributes'?: object;
    /**
     * 
     * @type {object}
     * @memberof IncludedResourceInner
     */
    'relationships'?: object;
}
/**
 * 
 * @export
 * @interface IndividualApplication
 */
export interface IndividualApplication extends Application {
    /**
     * 
     * @type {IndividualApplicationAllOfAttributes}
     * @memberof IndividualApplication
     */
    'attributes': IndividualApplicationAllOfAttributes;
    /**
     * 
     * @type {IndividualApplicationRelationships}
     * @memberof IndividualApplication
     */
    'relationships'?: IndividualApplicationRelationships;
}


/**
 * 
 * @export
 * @interface IndividualApplicationAllOfAttributes
 */
export interface IndividualApplicationAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {ApplicationStatus}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'status': ApplicationStatus;
    /**
     * 
     * @type {string}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'evaluationOutcome'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'evaluationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'evaluationEntityId'?: string;
    /**
     * 
     * @type {FullName}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'fullName': FullName;
    /**
     * 
     * @type {string}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'email'?: string;
    /**
     * 
     * @type {Phone}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'phone'?: Phone;
    /**
     * 
     * @type {string}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'ssn'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'passport'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'nationality'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'matriculaConsular'?: string;
    /**
     * 
     * @type {Address}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'address'?: Address;
    /**
     * 
     * @type {string}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'dateOfBirth'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'dba'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'ein'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'ip'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'soleProprietorship'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'decisionMethod'?: IndividualApplicationAllOfAttributesDecisionMethodEnum;
    /**
     * 
     * @type {string}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'decisionUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'decisionReason'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'decisionDateTime'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'riskRate'?: IndividualApplicationAllOfAttributesRiskRateEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'evaluationFlags'?: Array<string>;
    /**
     * 
     * @type {object}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'evaluationScores'?: object;
    /**
     * 
     * @type {object}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'ipLocationDetails'?: object;
    /**
     * 
     * @type {object}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'phoneLocationDetails'?: object;
    /**
     * 
     * @type {string}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'maskedSSN'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'maskedPassport'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'maskedMatriculaConsular'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'jwtSubject'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'archived'?: boolean;
    /**
     * 
     * @type {PowerOfAttorneyAgent}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'powerOfAttorneyAgent'?: PowerOfAttorneyAgent;
    /**
     * 
     * @type {Industry}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'industry'?: Industry;
    /**
     * 
     * @type {number}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'idTheftScore'?: number;
    /**
     * 
     * @type {Occupation}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'occupation'?: Occupation;
    /**
     * 
     * @type {AnnualIncome}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'annualIncome'?: AnnualIncome;
    /**
     * 
     * @type {SourceOfIncome}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'sourceOfIncome'?: SourceOfIncome;
    /**
     * 
     * @type {SoleProprietorshipAnnualRevenue}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'annualRevenue'?: SoleProprietorshipAnnualRevenue;
    /**
     * 
     * @type {SoleProprietorshipNumberOfEmployees}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'numberOfEmployees'?: SoleProprietorshipNumberOfEmployees;
    /**
     * 
     * @type {BusinessVertical}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'businessVertical'?: BusinessVertical;
    /**
     * 
     * @type {string}
     * @memberof IndividualApplicationAllOfAttributes
     */
    'website'?: string;
}

export const IndividualApplicationAllOfAttributesDecisionMethodEnum = {
    Manually: 'Manually',
    Automatically: 'Automatically'
} as const;

export type IndividualApplicationAllOfAttributesDecisionMethodEnum = typeof IndividualApplicationAllOfAttributesDecisionMethodEnum[keyof typeof IndividualApplicationAllOfAttributesDecisionMethodEnum];
export const IndividualApplicationAllOfAttributesRiskRateEnum = {
    Low: 'low',
    Medium: 'medium',
    High: 'high'
} as const;

export type IndividualApplicationAllOfAttributesRiskRateEnum = typeof IndividualApplicationAllOfAttributesRiskRateEnum[keyof typeof IndividualApplicationAllOfAttributesRiskRateEnum];

/**
 * 
 * @export
 * @interface IndividualApplicationRelationships
 */
export interface IndividualApplicationRelationships {
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof IndividualApplicationRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {DocumentsRelationship}
     * @memberof IndividualApplicationRelationships
     */
    'documents'?: DocumentsRelationship;
    /**
     * 
     * @type {OrgRelationship}
     * @memberof IndividualApplicationRelationships
     */
    'org'?: OrgRelationship;
    /**
     * 
     * @type {Relationship}
     * @memberof IndividualApplicationRelationships
     */
    'applicationForm'?: Relationship;
}
/**
 * 
 * @export
 * @interface IndividualCustomer
 */
export interface IndividualCustomer extends Customer {
    /**
     * 
     * @type {IndividualCustomerAllOfAttributes}
     * @memberof IndividualCustomer
     */
    'attributes'?: IndividualCustomerAllOfAttributes;
    /**
     * 
     * @type {CustomerRelationships}
     * @memberof IndividualCustomer
     */
    'relationships'?: CustomerRelationships;
}


/**
 * 
 * @export
 * @interface IndividualCustomerAllOfAttributes
 */
export interface IndividualCustomerAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof IndividualCustomerAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {FullName}
     * @memberof IndividualCustomerAllOfAttributes
     */
    'fullName': FullName;
    /**
     * 
     * @type {string}
     * @memberof IndividualCustomerAllOfAttributes
     */
    'email'?: string;
    /**
     * 
     * @type {Phone}
     * @memberof IndividualCustomerAllOfAttributes
     */
    'phone'?: Phone;
    /**
     * 
     * @type {string}
     * @memberof IndividualCustomerAllOfAttributes
     */
    'ssn'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualCustomerAllOfAttributes
     */
    'passport'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualCustomerAllOfAttributes
     */
    'nationality'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualCustomerAllOfAttributes
     */
    'matriculaConsular'?: string;
    /**
     * 
     * @type {Address}
     * @memberof IndividualCustomerAllOfAttributes
     */
    'address'?: Address;
    /**
     * 
     * @type {string}
     * @memberof IndividualCustomerAllOfAttributes
     */
    'dateOfBirth'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualCustomerAllOfAttributes
     */
    'ein'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualCustomerAllOfAttributes
     */
    'dba'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IndividualCustomerAllOfAttributes
     */
    'soleProprietorship'?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof IndividualCustomerAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof IndividualCustomerAllOfAttributes
     */
    'riskRate'?: IndividualCustomerAllOfAttributesRiskRateEnum;
    /**
     * 
     * @type {string}
     * @memberof IndividualCustomerAllOfAttributes
     */
    'maskedSSN'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualCustomerAllOfAttributes
     */
    'maskedPassport'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualCustomerAllOfAttributes
     */
    'maskedMatriculaConsular'?: string;
    /**
     * 
     * @type {Array<AuthorizedUser>}
     * @memberof IndividualCustomerAllOfAttributes
     */
    'authorizedUsers'?: Array<AuthorizedUser>;
    /**
     * 
     * @type {string}
     * @memberof IndividualCustomerAllOfAttributes
     */
    'jwtSubject'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IndividualCustomerAllOfAttributes
     */
    'status': IndividualCustomerAllOfAttributesStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof IndividualCustomerAllOfAttributes
     */
    'archiveReason'?: IndividualCustomerAllOfAttributesArchiveReasonEnum;
}

export const IndividualCustomerAllOfAttributesRiskRateEnum = {
    Low: 'low',
    Medium: 'medium',
    High: 'high'
} as const;

export type IndividualCustomerAllOfAttributesRiskRateEnum = typeof IndividualCustomerAllOfAttributesRiskRateEnum[keyof typeof IndividualCustomerAllOfAttributesRiskRateEnum];
export const IndividualCustomerAllOfAttributesStatusEnum = {
    Active: 'Active',
    Archived: 'Archived'
} as const;

export type IndividualCustomerAllOfAttributesStatusEnum = typeof IndividualCustomerAllOfAttributesStatusEnum[keyof typeof IndividualCustomerAllOfAttributesStatusEnum];
export const IndividualCustomerAllOfAttributesArchiveReasonEnum = {
    Inactive: 'Inactive',
    FraudAchActivity: 'FraudACHActivity',
    FraudCardActivity: 'FraudCardActivity',
    FraudCheckActivity: 'FraudCheckActivity',
    FraudApplicationHistory: 'FraudApplicationHistory',
    FraudAccountActivity: 'FraudAccountActivity',
    FraudClientIdentified: 'FraudClientIdentified',
    FraudLinkedToFraudulentCustomer: 'FraudLinkedToFraudulentCustomer'
} as const;

export type IndividualCustomerAllOfAttributesArchiveReasonEnum = typeof IndividualCustomerAllOfAttributesArchiveReasonEnum[keyof typeof IndividualCustomerAllOfAttributesArchiveReasonEnum];

/**
 * 
 * @export
 * @interface IndividualDebitCard
 */
export interface IndividualDebitCard extends Card {
    /**
     * 
     * @type {IndividualDebitCardAllOfAttributes}
     * @memberof IndividualDebitCard
     */
    'attributes': IndividualDebitCardAllOfAttributes;
    /**
     * 
     * @type {CardRelationships}
     * @memberof IndividualDebitCard
     */
    'relationships': CardRelationships;
}


/**
 * 
 * @export
 * @interface IndividualDebitCardAllOfAttributes
 */
export interface IndividualDebitCardAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof IndividualDebitCardAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof IndividualDebitCardAllOfAttributes
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualDebitCardAllOfAttributes
     */
    'last4Digits': string;
    /**
     * 
     * @type {string}
     * @memberof IndividualDebitCardAllOfAttributes
     */
    'expirationDate': string;
    /**
     * 
     * @type {string}
     * @memberof IndividualDebitCardAllOfAttributes
     */
    'nextExpirationDate'?: string;
    /**
     * 
     * @type {Address}
     * @memberof IndividualDebitCardAllOfAttributes
     */
    'shippingAddress'?: Address;
    /**
     * 
     * @type {string}
     * @memberof IndividualDebitCardAllOfAttributes
     */
    'bin'?: string;
    /**
     * 
     * @type {PhysicalCardStatus}
     * @memberof IndividualDebitCardAllOfAttributes
     */
    'status': PhysicalCardStatus;
    /**
     * 
     * @type {string}
     * @memberof IndividualDebitCardAllOfAttributes
     */
    'design'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof IndividualDebitCardAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof IndividualDebitCardAllOfAttributes
     */
    'freezeReason'?: string;
}


/**
 * 
 * @export
 * @interface IndividualVirtualDebitCard
 */
export interface IndividualVirtualDebitCard extends Card {
    /**
     * 
     * @type {IndividualVirtualDebitCardAllOfAttributes}
     * @memberof IndividualVirtualDebitCard
     */
    'attributes': IndividualVirtualDebitCardAllOfAttributes;
    /**
     * 
     * @type {CardRelationships}
     * @memberof IndividualVirtualDebitCard
     */
    'relationships': CardRelationships;
}


/**
 * 
 * @export
 * @interface IndividualVirtualDebitCardAllOfAttributes
 */
export interface IndividualVirtualDebitCardAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof IndividualVirtualDebitCardAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof IndividualVirtualDebitCardAllOfAttributes
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualVirtualDebitCardAllOfAttributes
     */
    'last4Digits': string;
    /**
     * 
     * @type {string}
     * @memberof IndividualVirtualDebitCardAllOfAttributes
     */
    'expirationDate': string;
    /**
     * 
     * @type {string}
     * @memberof IndividualVirtualDebitCardAllOfAttributes
     */
    'nextExpirationDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndividualVirtualDebitCardAllOfAttributes
     */
    'bin'?: string;
    /**
     * 
     * @type {VirtualCardStatus}
     * @memberof IndividualVirtualDebitCardAllOfAttributes
     */
    'status': VirtualCardStatus;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof IndividualVirtualDebitCardAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof IndividualVirtualDebitCardAllOfAttributes
     */
    'freezeReason'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const Industry = {
    Retail: 'Retail',
    Wholesale: 'Wholesale',
    Restaurants: 'Restaurants',
    Hospitals: 'Hospitals',
    Construction: 'Construction',
    Insurance: 'Insurance',
    Unions: 'Unions',
    RealEstate: 'RealEstate',
    FreelanceProfessional: 'FreelanceProfessional',
    OtherProfessionalServices: 'OtherProfessionalServices',
    OnlineRetailer: 'OnlineRetailer',
    OtherEducationServices: 'OtherEducationServices'
} as const;

export type Industry = typeof Industry[keyof typeof Industry];


/**
 * 
 * @export
 * @interface Institution
 */
export interface Institution {
    /**
     * 
     * @type {string}
     * @memberof Institution
     */
    'type': InstitutionTypeEnum;
    /**
     * 
     * @type {InstitutionAttributes}
     * @memberof Institution
     */
    'attributes': InstitutionAttributes;
}

export const InstitutionTypeEnum = {
    Institution: 'institution'
} as const;

export type InstitutionTypeEnum = typeof InstitutionTypeEnum[keyof typeof InstitutionTypeEnum];

/**
 * 
 * @export
 * @interface InstitutionAttributes
 */
export interface InstitutionAttributes {
    /**
     * 
     * @type {string}
     * @memberof InstitutionAttributes
     */
    'routingNumber': string;
    /**
     * 
     * @type {string}
     * @memberof InstitutionAttributes
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof InstitutionAttributes
     */
    'address'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InstitutionAttributes
     */
    'isWireSupported': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InstitutionAttributes
     */
    'isACHSupported': boolean;
}
/**
 * 
 * @export
 * @interface InterestShareTransaction
 */
export interface InterestShareTransaction extends Transaction {
    /**
     * 
     * @type {FeeTransactionAllOfAttributes}
     * @memberof InterestShareTransaction
     */
    'attributes': FeeTransactionAllOfAttributes;
    /**
     * 
     * @type {InterestShareTransactionRelationships}
     * @memberof InterestShareTransaction
     */
    'relationships': InterestShareTransactionRelationships;
}


/**
 * 
 * @export
 * @interface InterestShareTransactionRelationships
 */
export interface InterestShareTransactionRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof InterestShareTransactionRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof InterestShareTransactionRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof InterestShareTransactionRelationships
     */
    'customers'?: CustomersRelationship;
    /**
     * 
     * @type {OrgRelationship}
     * @memberof InterestShareTransactionRelationships
     */
    'org': OrgRelationship;
}
/**
 * 
 * @export
 * @interface InterestTransaction
 */
export interface InterestTransaction extends Transaction {
    /**
     * 
     * @type {FeeTransactionAllOfAttributes}
     * @memberof InterestTransaction
     */
    'attributes': FeeTransactionAllOfAttributes;
    /**
     * 
     * @type {InterestTransactionRelationships}
     * @memberof InterestTransaction
     */
    'relationships': InterestTransactionRelationships;
}


/**
 * 
 * @export
 * @interface InterestTransactionRelationships
 */
export interface InterestTransactionRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof InterestTransactionRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof InterestTransactionRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof InterestTransactionRelationships
     */
    'customers'?: CustomersRelationship;
}
/**
 * 
 * @export
 * @interface Limits
 */
export interface Limits {
    /**
     * 
     * @type {string}
     * @memberof Limits
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Limits
     */
    'id'?: string;
    /**
     * 
     * @type {LimitsAttributes}
     * @memberof Limits
     */
    'attributes'?: LimitsAttributes;
}
/**
 * 
 * @export
 * @interface LimitsAttributes
 */
export interface LimitsAttributes {
    /**
     * 
     * @type {LimitsAttributesCard}
     * @memberof LimitsAttributes
     */
    'card'?: LimitsAttributesCard;
}
/**
 * 
 * @export
 * @interface LimitsAttributesCard
 */
export interface LimitsAttributesCard {
    /**
     * 
     * @type {LimitsAttributesCardLimits}
     * @memberof LimitsAttributesCard
     */
    'limits'?: LimitsAttributesCardLimits;
    /**
     * 
     * @type {LimitsAttributesCardTotalsDaily}
     * @memberof LimitsAttributesCard
     */
    'totalsDaily'?: LimitsAttributesCardTotalsDaily;
}
/**
 * 
 * @export
 * @interface LimitsAttributesCardLimits
 */
export interface LimitsAttributesCardLimits {
    /**
     * 
     * @type {number}
     * @memberof LimitsAttributesCardLimits
     */
    'dailyWithdrawal'?: number;
    /**
     * 
     * @type {number}
     * @memberof LimitsAttributesCardLimits
     */
    'dailyDeposit'?: number;
    /**
     * 
     * @type {number}
     * @memberof LimitsAttributesCardLimits
     */
    'dailyPurchase'?: number;
    /**
     * 
     * @type {number}
     * @memberof LimitsAttributesCardLimits
     */
    'dailyCardTransaction'?: number;
}
/**
 * 
 * @export
 * @interface LimitsAttributesCardTotalsDaily
 */
export interface LimitsAttributesCardTotalsDaily {
    /**
     * 
     * @type {number}
     * @memberof LimitsAttributesCardTotalsDaily
     */
    'withdrawal'?: number;
    /**
     * 
     * @type {number}
     * @memberof LimitsAttributesCardTotalsDaily
     */
    'deposit'?: number;
    /**
     * 
     * @type {number}
     * @memberof LimitsAttributesCardTotalsDaily
     */
    'purchase'?: number;
    /**
     * 
     * @type {number}
     * @memberof LimitsAttributesCardTotalsDaily
     */
    'cardTransaction'?: number;
}
/**
 * Parameters for paginated list requests
 * @export
 * @interface ListPageParameters
 */
export interface ListPageParameters {
    /**
     * 
     * @type {number}
     * @memberof ListPageParameters
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListPageParameters
     */
    'offset'?: number;
}
/**
 * 
 * @export
 * @interface Merchant
 */
export interface Merchant {
    /**
     * 
     * @type {string}
     * @memberof Merchant
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof Merchant
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof Merchant
     */
    'category': string;
    /**
     * 
     * @type {string}
     * @memberof Merchant
     */
    'location'?: string;
    /**
     * 
     * @type {string}
     * @memberof Merchant
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface MonthlySchedule
 */
export interface MonthlySchedule {
    /**
     * 
     * @type {string}
     * @memberof MonthlySchedule
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof MonthlySchedule
     */
    'endTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof MonthlySchedule
     */
    'dayOfMonth'?: number;
    /**
     * 
     * @type {string}
     * @memberof MonthlySchedule
     */
    'dayOfWeek'?: MonthlyScheduleDayOfWeekEnum;
    /**
     * 
     * @type {number}
     * @memberof MonthlySchedule
     */
    'totalNumberOfPayments'?: number;
    /**
     * 
     * @type {string}
     * @memberof MonthlySchedule
     */
    'interval': MonthlyScheduleIntervalEnum;
}

export const MonthlyScheduleDayOfWeekEnum = {
    Sunday: 'Sunday',
    Monday: 'Monday',
    Tuesday: 'Tuesday',
    Wednesday: 'Wednesday',
    Thursday: 'Thursday',
    Friday: 'Friday',
    Saturday: 'Saturday'
} as const;

export type MonthlyScheduleDayOfWeekEnum = typeof MonthlyScheduleDayOfWeekEnum[keyof typeof MonthlyScheduleDayOfWeekEnum];
export const MonthlyScheduleIntervalEnum = {
    Montly: 'Montly'
} as const;

export type MonthlyScheduleIntervalEnum = typeof MonthlyScheduleIntervalEnum[keyof typeof MonthlyScheduleIntervalEnum];

/**
 * 
 * @export
 * @interface NegativeBalanceCoverageTransaction
 */
export interface NegativeBalanceCoverageTransaction extends Transaction {
    /**
     * 
     * @type {FeeTransactionAllOfAttributes}
     * @memberof NegativeBalanceCoverageTransaction
     */
    'attributes': FeeTransactionAllOfAttributes;
    /**
     * 
     * @type {NegativeBalanceCoverageTransactionRelationships}
     * @memberof NegativeBalanceCoverageTransaction
     */
    'relationships': NegativeBalanceCoverageTransactionRelationships;
}


/**
 * 
 * @export
 * @interface NegativeBalanceCoverageTransactionRelationships
 */
export interface NegativeBalanceCoverageTransactionRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof NegativeBalanceCoverageTransactionRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof NegativeBalanceCoverageTransactionRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof NegativeBalanceCoverageTransactionRelationships
     */
    'customers'?: CustomersRelationship;
    /**
     * 
     * @type {ReceiverAccountRelationship}
     * @memberof NegativeBalanceCoverageTransactionRelationships
     */
    'receiverAccount': ReceiverAccountRelationship;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Occupation = {
    ArchitectOrEngineer: 'ArchitectOrEngineer',
    BusinessAnalystAccountantOrFinancialAdvisor: 'BusinessAnalystAccountantOrFinancialAdvisor',
    CommunityAndSocialServicesWorker: 'CommunityAndSocialServicesWorker',
    ConstructionMechanicOrMaintenanceWorker: 'ConstructionMechanicOrMaintenanceWorker',
    Doctor: 'Doctor',
    Educator: 'Educator',
    EntertainmentSportsArtsOrMedia: 'EntertainmentSportsArtsOrMedia',
    ExecutiveOrManager: 'ExecutiveOrManager',
    FarmerFishermanForester: 'FarmerFishermanForester',
    FoodServiceWorker: 'FoodServiceWorker',
    GigWorker: 'GigWorker',
    HospitalityOfficeOrAdministrativeSupportWorker: 'HospitalityOfficeOrAdministrativeSupportWorker',
    HouseholdManager: 'HouseholdManager',
    JanitorHousekeeperLandscaper: 'JanitorHousekeeperLandscaper',
    Lawyer: 'Lawyer',
    ManufacturingOrProductionWorker: 'ManufacturingOrProductionWorker',
    MilitaryOrPublicSafety: 'MilitaryOrPublicSafety',
    NurseHealthcareTechnicianOrHealthcareSupport: 'NurseHealthcareTechnicianOrHealthcareSupport',
    PersonalCareOrServiceWorker: 'PersonalCareOrServiceWorker',
    PilotDriverOperator: 'PilotDriverOperator',
    SalesRepresentativeBrokerAgent: 'SalesRepresentativeBrokerAgent',
    ScientistOrTechnologist: 'ScientistOrTechnologist',
    Student: 'Student'
} as const;

export type Occupation = typeof Occupation[keyof typeof Occupation];


/**
 * 
 * @export
 * @interface Officer
 */
export interface Officer {
    /**
     * 
     * @type {string}
     * @memberof Officer
     */
    'status'?: string;
    /**
     * 
     * @type {FullName}
     * @memberof Officer
     */
    'fullName'?: FullName;
    /**
     * 
     * @type {string}
     * @memberof Officer
     */
    'email'?: string;
    /**
     * 
     * @type {Phone}
     * @memberof Officer
     */
    'phone'?: Phone;
    /**
     * 
     * @type {string}
     * @memberof Officer
     */
    'ssn'?: string;
    /**
     * 
     * @type {string}
     * @memberof Officer
     */
    'passport'?: string;
    /**
     * 
     * @type {string}
     * @memberof Officer
     */
    'nationality'?: string;
    /**
     * 
     * @type {string}
     * @memberof Officer
     */
    'matriculaConsular'?: string;
    /**
     * 
     * @type {Address}
     * @memberof Officer
     */
    'address'?: Address;
    /**
     * 
     * @type {string}
     * @memberof Officer
     */
    'dateOfBirth'?: string;
    /**
     * 
     * @type {string}
     * @memberof Officer
     */
    'evaluationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Officer
     */
    'title'?: OfficerTitleEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof Officer
     */
    'evaluationFlags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Officer
     */
    'maskedSSN'?: string;
    /**
     * 
     * @type {string}
     * @memberof Officer
     */
    'maskedPassport'?: string;
    /**
     * 
     * @type {string}
     * @memberof Officer
     */
    'maskedMatriculaConsular'?: string;
    /**
     * 
     * @type {number}
     * @memberof Officer
     */
    'idTheftScore'?: number;
    /**
     * 
     * @type {Occupation}
     * @memberof Officer
     */
    'occupation'?: Occupation;
    /**
     * 
     * @type {AnnualIncome}
     * @memberof Officer
     */
    'annualIncome'?: AnnualIncome;
    /**
     * 
     * @type {SourceOfIncome}
     * @memberof Officer
     */
    'sourceOfIncome'?: SourceOfIncome;
}

export const OfficerTitleEnum = {
    President: 'President',
    Ceo: 'CEO',
    Coo: 'COO',
    Cfo: 'CFO',
    BenefitsAdministrationOfficer: 'BenefitsAdministrationOfficer',
    Cio: 'CIO',
    Vp: 'VP',
    Avp: 'AVP',
    Treasurer: 'Treasurer',
    Secretary: 'Secretary',
    Controller: 'Controller',
    Manager: 'Manager',
    Partner: 'Partner',
    Member: 'Member'
} as const;

export type OfficerTitleEnum = typeof OfficerTitleEnum[keyof typeof OfficerTitleEnum];

/**
 * 
 * @export
 * @interface OrgRelationship
 */
export interface OrgRelationship {
    /**
     * 
     * @type {OrgRelationshipData}
     * @memberof OrgRelationship
     */
    'data': OrgRelationshipData;
}
/**
 * 
 * @export
 * @interface OrgRelationshipData
 */
export interface OrgRelationshipData {
    /**
     * 
     * @type {string}
     * @memberof OrgRelationshipData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrgRelationshipData
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface OriginalTransactionRelationship
 */
export interface OriginalTransactionRelationship {
    /**
     * 
     * @type {OriginalTransactionRelationshipData}
     * @memberof OriginalTransactionRelationship
     */
    'data': OriginalTransactionRelationshipData;
}
/**
 * 
 * @export
 * @interface OriginalTransactionRelationshipData
 */
export interface OriginalTransactionRelationshipData {
    /**
     * 
     * @type {string}
     * @memberof OriginalTransactionRelationshipData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OriginalTransactionRelationshipData
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface OriginatedAchTransaction
 */
export interface OriginatedAchTransaction extends Transaction {
    /**
     * 
     * @type {OriginatedAchTransactionAllOfAttributes}
     * @memberof OriginatedAchTransaction
     */
    'attributes': OriginatedAchTransactionAllOfAttributes;
    /**
     * 
     * @type {OriginatedAchTransactionRelationships}
     * @memberof OriginatedAchTransaction
     */
    'relationships': OriginatedAchTransactionRelationships;
}


/**
 * 
 * @export
 * @interface OriginatedAchTransactionAllOfAttributes
 */
export interface OriginatedAchTransactionAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof OriginatedAchTransactionAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof OriginatedAchTransactionAllOfAttributes
     */
    'direction': OriginatedAchTransactionAllOfAttributesDirectionEnum;
    /**
     * 
     * @type {number}
     * @memberof OriginatedAchTransactionAllOfAttributes
     */
    'amount': number;
    /**
     * 
     * @type {number}
     * @memberof OriginatedAchTransactionAllOfAttributes
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof OriginatedAchTransactionAllOfAttributes
     */
    'summary': string;
    /**
     * 
     * @type {string}
     * @memberof OriginatedAchTransactionAllOfAttributes
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof OriginatedAchTransactionAllOfAttributes
     */
    'addenda'?: string;
    /**
     * 
     * @type {PaymentCounterparty}
     * @memberof OriginatedAchTransactionAllOfAttributes
     */
    'counterparty': PaymentCounterparty;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof OriginatedAchTransactionAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof OriginatedAchTransactionAllOfAttributes
     */
    'secCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginatedAchTransactionAllOfAttributes
     */
    'traceNumber'?: string;
}

export const OriginatedAchTransactionAllOfAttributesDirectionEnum = {
    Credit: 'Credit',
    Debit: 'Debit'
} as const;

export type OriginatedAchTransactionAllOfAttributesDirectionEnum = typeof OriginatedAchTransactionAllOfAttributesDirectionEnum[keyof typeof OriginatedAchTransactionAllOfAttributesDirectionEnum];

/**
 * 
 * @export
 * @interface OriginatedAchTransactionRelationships
 */
export interface OriginatedAchTransactionRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof OriginatedAchTransactionRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof OriginatedAchTransactionRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof OriginatedAchTransactionRelationships
     */
    'customers'?: CustomersRelationship;
    /**
     * 
     * @type {PaymentRelationship}
     * @memberof OriginatedAchTransactionRelationships
     */
    'payment': PaymentRelationship;
    /**
     * 
     * @type {RecurringPaymentRelationship}
     * @memberof OriginatedAchTransactionRelationships
     */
    'recurringPayment'?: RecurringPaymentRelationship;
}
/**
 * 
 * @export
 * @interface PaginationMeta
 */
export interface PaginationMeta {
    /**
     * 
     * @type {PaginationMetaPagination}
     * @memberof PaginationMeta
     */
    'pagination'?: PaginationMetaPagination;
}
/**
 * 
 * @export
 * @interface PaginationMetaPagination
 */
export interface PaginationMetaPagination {
    /**
     * 
     * @type {number}
     * @memberof PaginationMetaPagination
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationMetaPagination
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationMetaPagination
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface Payment
 */
export interface Payment {
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'type'?: PaymentTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'id'?: string;
}

export const PaymentTypeEnum = {
    AchPayment: 'achPayment',
    BookPayment: 'bookPayment',
    WirePayment: 'wirePayment'
} as const;

export type PaymentTypeEnum = typeof PaymentTypeEnum[keyof typeof PaymentTypeEnum];

/**
 * 
 * @export
 * @interface PaymentAdvanceTransaction
 */
export interface PaymentAdvanceTransaction extends Transaction {
    /**
     * 
     * @type {CheckDepositTransactionAllOfAttributes}
     * @memberof PaymentAdvanceTransaction
     */
    'attributes': CheckDepositTransactionAllOfAttributes;
    /**
     * 
     * @type {PaymentAdvanceTransactionRelationships}
     * @memberof PaymentAdvanceTransaction
     */
    'relationships': PaymentAdvanceTransactionRelationships;
}


/**
 * 
 * @export
 * @interface PaymentAdvanceTransactionRelationship
 */
export interface PaymentAdvanceTransactionRelationship {
    /**
     * 
     * @type {TransactionRelationshipData}
     * @memberof PaymentAdvanceTransactionRelationship
     */
    'data': TransactionRelationshipData;
}
/**
 * 
 * @export
 * @interface PaymentAdvanceTransactionRelationships
 */
export interface PaymentAdvanceTransactionRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof PaymentAdvanceTransactionRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof PaymentAdvanceTransactionRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {ReceivedPaymentRelationship}
     * @memberof PaymentAdvanceTransactionRelationships
     */
    'receivedPayment': ReceivedPaymentRelationship;
}
/**
 * 
 * @export
 * @interface PaymentCounterparty
 */
export interface PaymentCounterparty {
    /**
     * 
     * @type {string}
     * @memberof PaymentCounterparty
     */
    'routingNumber': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentCounterparty
     */
    'accountNumber': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentCounterparty
     */
    'accountType': PaymentCounterpartyAccountTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PaymentCounterparty
     */
    'name': string;
}

export const PaymentCounterpartyAccountTypeEnum = {
    Checking: 'Checking',
    Savings: 'Savings',
    Loan: 'Loan'
} as const;

export type PaymentCounterpartyAccountTypeEnum = typeof PaymentCounterpartyAccountTypeEnum[keyof typeof PaymentCounterpartyAccountTypeEnum];

/**
 * 
 * @export
 * @interface PaymentRelationship
 */
export interface PaymentRelationship {
    /**
     * 
     * @type {PaymentRelationshipData}
     * @memberof PaymentRelationship
     */
    'data': PaymentRelationshipData;
}
/**
 * 
 * @export
 * @interface PaymentRelationshipData
 */
export interface PaymentRelationshipData {
    /**
     * 
     * @type {string}
     * @memberof PaymentRelationshipData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRelationshipData
     */
    'type': PaymentRelationshipDataTypeEnum;
}

export const PaymentRelationshipDataTypeEnum = {
    Payment: 'payment',
    AchPayment: 'achPayment',
    CardPayment: 'cardPayment',
    CheckPayment: 'checkPayment',
    RecurringPayment: 'recurringPayment',
    PaymentAdvance: 'paymentAdvance',
    RepayPaymentAdvance: 'repayPaymentAdvance',
    ReceivePayment: 'receivePayment',
    RewardedTransaction: 'rewardedTransaction'
} as const;

export type PaymentRelationshipDataTypeEnum = typeof PaymentRelationshipDataTypeEnum[keyof typeof PaymentRelationshipDataTypeEnum];

/**
 * 
 * @export
 * @interface Phone
 */
export interface Phone {
    /**
     * 
     * @type {string}
     * @memberof Phone
     */
    'countryCode': string;
    /**
     * 
     * @type {string}
     * @memberof Phone
     */
    'number': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PhysicalCardStatus = {
    Active: 'Active',
    Inactive: 'Inactive',
    Stolen: 'Stolen',
    Lost: 'Lost',
    Frozen: 'Frozen',
    ClosedByCustomer: 'ClosedByCustomer',
    Unknown: 'Unknown',
    SuspectedFraud: 'SuspectedFraud',
    ActiveForOnlineUse: 'ActiveForOnlineUse'
} as const;

export type PhysicalCardStatus = typeof PhysicalCardStatus[keyof typeof PhysicalCardStatus];


/**
 * 
 * @export
 * @interface PowerOfAttorneyAgent
 */
export interface PowerOfAttorneyAgent {
    /**
     * 
     * @type {string}
     * @memberof PowerOfAttorneyAgent
     */
    'status': string;
    /**
     * 
     * @type {FullName}
     * @memberof PowerOfAttorneyAgent
     */
    'fullName': FullName;
    /**
     * 
     * @type {string}
     * @memberof PowerOfAttorneyAgent
     */
    'email'?: string;
    /**
     * 
     * @type {Phone}
     * @memberof PowerOfAttorneyAgent
     */
    'phone'?: Phone;
    /**
     * 
     * @type {string}
     * @memberof PowerOfAttorneyAgent
     */
    'ssn'?: string;
    /**
     * 
     * @type {string}
     * @memberof PowerOfAttorneyAgent
     */
    'passport'?: string;
    /**
     * 
     * @type {string}
     * @memberof PowerOfAttorneyAgent
     */
    'nationality'?: string;
    /**
     * 
     * @type {string}
     * @memberof PowerOfAttorneyAgent
     */
    'matriculaConsular'?: string;
    /**
     * 
     * @type {Address}
     * @memberof PowerOfAttorneyAgent
     */
    'address'?: Address;
    /**
     * 
     * @type {string}
     * @memberof PowerOfAttorneyAgent
     */
    'dateOfBirth'?: string;
    /**
     * 
     * @type {string}
     * @memberof PowerOfAttorneyAgent
     */
    'evaluationId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PowerOfAttorneyAgent
     */
    'evaluationFlags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PowerOfAttorneyAgent
     */
    'maskedSSN'?: string;
    /**
     * 
     * @type {string}
     * @memberof PowerOfAttorneyAgent
     */
    'maskedPassport'?: string;
    /**
     * 
     * @type {string}
     * @memberof PowerOfAttorneyAgent
     */
    'maskedMatriculaConsular'?: string;
    /**
     * 
     * @type {number}
     * @memberof PowerOfAttorneyAgent
     */
    'idTheftScore'?: number;
}
/**
 * 
 * @export
 * @interface PurchaseAuthorization
 */
export interface PurchaseAuthorization extends AuthorizationRequest {
    /**
     * 
     * @type {PurchaseAuthorizationAllOfAttributes}
     * @memberof PurchaseAuthorization
     */
    'attributes'?: PurchaseAuthorizationAllOfAttributes;
    /**
     * 
     * @type {AuthorizationRequestRelationships}
     * @memberof PurchaseAuthorization
     */
    'relationships': AuthorizationRequestRelationships;
}


/**
 * 
 * @export
 * @interface PurchaseAuthorizationAllOfAttributes
 */
export interface PurchaseAuthorizationAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof PurchaseAuthorizationAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {number}
     * @memberof PurchaseAuthorizationAllOfAttributes
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof PurchaseAuthorizationAllOfAttributes
     */
    'status': string;
    /**
     * 
     * @type {boolean}
     * @memberof PurchaseAuthorizationAllOfAttributes
     */
    'partialApprovalAllowed': boolean;
    /**
     * 
     * @type {number}
     * @memberof PurchaseAuthorizationAllOfAttributes
     */
    'approvedAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof PurchaseAuthorizationAllOfAttributes
     */
    'declineReason'?: string;
    /**
     * 
     * @type {Merchant}
     * @memberof PurchaseAuthorizationAllOfAttributes
     */
    'merchant': Merchant;
    /**
     * 
     * @type {boolean}
     * @memberof PurchaseAuthorizationAllOfAttributes
     */
    'recurring': boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PurchaseAuthorizationAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {HealthcareAmounts}
     * @memberof PurchaseAuthorizationAllOfAttributes
     */
    'healthcareAmounts'?: HealthcareAmounts;
    /**
     * 
     * @type {string}
     * @memberof PurchaseAuthorizationAllOfAttributes
     */
    'paymentMethod'?: string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseAuthorizationAllOfAttributes
     */
    'digitalWallet'?: string;
    /**
     * 
     * @type {CardVerificationData}
     * @memberof PurchaseAuthorizationAllOfAttributes
     */
    'cardVerificationData'?: CardVerificationData;
    /**
     * 
     * @type {boolean}
     * @memberof PurchaseAuthorizationAllOfAttributes
     */
    'ecommerce'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PurchaseAuthorizationAllOfAttributes
     */
    'cardPresent'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PurchaseAuthorizationAllOfAttributes
     */
    'cardNetwork'?: string;
    /**
     * 
     * @type {number}
     * @memberof PurchaseAuthorizationAllOfAttributes
     */
    'cashWithdrawalAmount'?: number;
}
/**
 * 
 * @export
 * @interface PurchaseTransaction
 */
export interface PurchaseTransaction extends Transaction {
    /**
     * 
     * @type {PurchaseTransactionAllOfAttributes}
     * @memberof PurchaseTransaction
     */
    'attributes': PurchaseTransactionAllOfAttributes;
    /**
     * 
     * @type {PurchaseTransactionRelationships}
     * @memberof PurchaseTransaction
     */
    'relationships': PurchaseTransactionRelationships;
}


/**
 * 
 * @export
 * @interface PurchaseTransactionAllOfAttributes
 */
export interface PurchaseTransactionAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof PurchaseTransactionAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseTransactionAllOfAttributes
     */
    'direction': PurchaseTransactionAllOfAttributesDirectionEnum;
    /**
     * 
     * @type {number}
     * @memberof PurchaseTransactionAllOfAttributes
     */
    'amount': number;
    /**
     * 
     * @type {number}
     * @memberof PurchaseTransactionAllOfAttributes
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof PurchaseTransactionAllOfAttributes
     */
    'summary': string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseTransactionAllOfAttributes
     */
    'cardLast4Digits': string;
    /**
     * 
     * @type {Merchant}
     * @memberof PurchaseTransactionAllOfAttributes
     */
    'merchant': Merchant;
    /**
     * 
     * @type {Coordinates}
     * @memberof PurchaseTransactionAllOfAttributes
     */
    'coordinates'?: Coordinates;
    /**
     * 
     * @type {boolean}
     * @memberof PurchaseTransactionAllOfAttributes
     */
    'recurring': boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PurchaseTransactionAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof PurchaseTransactionAllOfAttributes
     */
    'networkTransactionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseTransactionAllOfAttributes
     */
    'interchange'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PurchaseTransactionAllOfAttributes
     */
    'ecommerce': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PurchaseTransactionAllOfAttributes
     */
    'cardPresent': boolean;
    /**
     * 
     * @type {number}
     * @memberof PurchaseTransactionAllOfAttributes
     */
    'internationalServiceFee'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PurchaseTransactionAllOfAttributes
     */
    'paymentMethod'?: string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseTransactionAllOfAttributes
     */
    'digitalWallet'?: string;
    /**
     * 
     * @type {CardVerificationData}
     * @memberof PurchaseTransactionAllOfAttributes
     */
    'cardVerificationData'?: CardVerificationData;
    /**
     * 
     * @type {string}
     * @memberof PurchaseTransactionAllOfAttributes
     */
    'cardNetwork'?: string;
}

export const PurchaseTransactionAllOfAttributesDirectionEnum = {
    Credit: 'Credit',
    Debit: 'Debit'
} as const;

export type PurchaseTransactionAllOfAttributesDirectionEnum = typeof PurchaseTransactionAllOfAttributesDirectionEnum[keyof typeof PurchaseTransactionAllOfAttributesDirectionEnum];

/**
 * 
 * @export
 * @interface PurchaseTransactionRelationships
 */
export interface PurchaseTransactionRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof PurchaseTransactionRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof PurchaseTransactionRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof PurchaseTransactionRelationships
     */
    'customers'?: CustomersRelationship;
    /**
     * 
     * @type {CardRelationship}
     * @memberof PurchaseTransactionRelationships
     */
    'card': CardRelationship;
    /**
     * 
     * @type {AuthorizationRelationship}
     * @memberof PurchaseTransactionRelationships
     */
    'authorization': AuthorizationRelationship;
    /**
     * 
     * @type {AuthorizationRequestRelationship}
     * @memberof PurchaseTransactionRelationships
     */
    'authorizationRequest'?: AuthorizationRequestRelationship;
}
/**
 * 
 * @export
 * @interface PushToCardReversalTransaction
 */
export interface PushToCardReversalTransaction extends Transaction {
    /**
     * 
     * @type {FeeTransactionAllOfAttributes}
     * @memberof PushToCardReversalTransaction
     */
    'attributes': FeeTransactionAllOfAttributes;
    /**
     * 
     * @type {PushToCardReversalTransactionRelationships}
     * @memberof PushToCardReversalTransaction
     */
    'relationships': PushToCardReversalTransactionRelationships;
}


/**
 * 
 * @export
 * @interface PushToCardReversalTransactionRelationships
 */
export interface PushToCardReversalTransactionRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof PushToCardReversalTransactionRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof PushToCardReversalTransactionRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof PushToCardReversalTransactionRelationships
     */
    'customers'?: CustomersRelationship;
    /**
     * 
     * @type {PaymentRelationship}
     * @memberof PushToCardReversalTransactionRelationships
     */
    'payment'?: PaymentRelationship;
    /**
     * 
     * @type {OrgRelationship}
     * @memberof PushToCardReversalTransactionRelationships
     */
    'org': OrgRelationship;
    /**
     * 
     * @type {OriginalTransactionRelationship}
     * @memberof PushToCardReversalTransactionRelationships
     */
    'originalTransaction': OriginalTransactionRelationship;
}
/**
 * 
 * @export
 * @interface ReceivePaymentTransactionRelationship
 */
export interface ReceivePaymentTransactionRelationship {
    /**
     * 
     * @type {TransactionRelationshipData}
     * @memberof ReceivePaymentTransactionRelationship
     */
    'data': TransactionRelationshipData;
}
/**
 * 
 * @export
 * @interface ReceivedAchTransaction
 */
export interface ReceivedAchTransaction extends Transaction {
    /**
     * 
     * @type {ReceivedAchTransactionAllOfAttributes}
     * @memberof ReceivedAchTransaction
     */
    'attributes': ReceivedAchTransactionAllOfAttributes;
    /**
     * 
     * @type {ReceivedAchTransactionRelationships}
     * @memberof ReceivedAchTransaction
     */
    'relationships': ReceivedAchTransactionRelationships;
}


/**
 * 
 * @export
 * @interface ReceivedAchTransactionAllOfAttributes
 */
export interface ReceivedAchTransactionAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof ReceivedAchTransactionAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ReceivedAchTransactionAllOfAttributes
     */
    'direction': ReceivedAchTransactionAllOfAttributesDirectionEnum;
    /**
     * 
     * @type {number}
     * @memberof ReceivedAchTransactionAllOfAttributes
     */
    'amount': number;
    /**
     * 
     * @type {number}
     * @memberof ReceivedAchTransactionAllOfAttributes
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof ReceivedAchTransactionAllOfAttributes
     */
    'summary': string;
    /**
     * 
     * @type {string}
     * @memberof ReceivedAchTransactionAllOfAttributes
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ReceivedAchTransactionAllOfAttributes
     */
    'addenda'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReceivedAchTransactionAllOfAttributes
     */
    'companyName': string;
    /**
     * 
     * @type {string}
     * @memberof ReceivedAchTransactionAllOfAttributes
     */
    'counterpartyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReceivedAchTransactionAllOfAttributes
     */
    'counterpartyRoutingNumber': string;
    /**
     * 
     * @type {string}
     * @memberof ReceivedAchTransactionAllOfAttributes
     */
    'traceNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReceivedAchTransactionAllOfAttributes
     */
    'secCode'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ReceivedAchTransactionAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
}

export const ReceivedAchTransactionAllOfAttributesDirectionEnum = {
    Credit: 'Credit',
    Debit: 'Debit'
} as const;

export type ReceivedAchTransactionAllOfAttributesDirectionEnum = typeof ReceivedAchTransactionAllOfAttributesDirectionEnum[keyof typeof ReceivedAchTransactionAllOfAttributesDirectionEnum];

/**
 * 
 * @export
 * @interface ReceivedAchTransactionRelationships
 */
export interface ReceivedAchTransactionRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof ReceivedAchTransactionRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof ReceivedAchTransactionRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof ReceivedAchTransactionRelationships
     */
    'customers'?: CustomersRelationship;
}
/**
 * 
 * @export
 * @interface ReceivedPayment
 */
export interface ReceivedPayment {
    /**
     * 
     * @type {string}
     * @memberof ReceivedPayment
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReceivedPayment
     */
    'id'?: string;
    /**
     * 
     * @type {ReceivedPaymentAttributes}
     * @memberof ReceivedPayment
     */
    'attributes'?: ReceivedPaymentAttributes;
    /**
     * 
     * @type {ReceivedPaymentRelationships}
     * @memberof ReceivedPayment
     */
    'relationships'?: ReceivedPaymentRelationships;
}
/**
 * 
 * @export
 * @interface ReceivedPaymentAttributes
 */
export interface ReceivedPaymentAttributes {
    /**
     * 
     * @type {string}
     * @memberof ReceivedPaymentAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ReceivedPaymentAttributes
     */
    'status': ReceivedPaymentAttributesStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof ReceivedPaymentAttributes
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof ReceivedPaymentAttributes
     */
    'completionDate': string;
    /**
     * 
     * @type {string}
     * @memberof ReceivedPaymentAttributes
     */
    'direction': ReceivedPaymentAttributesDirectionEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ReceivedPaymentAttributes
     */
    'wasAdvanced': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ReceivedPaymentAttributes
     */
    'isAdvanceable'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ReceivedPaymentAttributes
     */
    'isAdvaceable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ReceivedPaymentAttributes
     */
    'companyName': string;
    /**
     * 
     * @type {string}
     * @memberof ReceivedPaymentAttributes
     */
    'counterpartyRoutingNumber': string;
    /**
     * 
     * @type {string}
     * @memberof ReceivedPaymentAttributes
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ReceivedPaymentAttributes
     */
    'addenda'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReceivedPaymentAttributes
     */
    'traceNumber': string;
    /**
     * 
     * @type {string}
     * @memberof ReceivedPaymentAttributes
     */
    'secCode': string;
    /**
     * 
     * @type {string}
     * @memberof ReceivedPaymentAttributes
     */
    'returnReason'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReceivedPaymentAttributes
     */
    'receivingEntityName'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ReceivedPaymentAttributes
     */
    'tags'?: { [key: string]: string; };
}

export const ReceivedPaymentAttributesStatusEnum = {
    Pending: 'Pending',
    Advanced: 'Advanced',
    Completed: 'Completed',
    Returned: 'Returned'
} as const;

export type ReceivedPaymentAttributesStatusEnum = typeof ReceivedPaymentAttributesStatusEnum[keyof typeof ReceivedPaymentAttributesStatusEnum];
export const ReceivedPaymentAttributesDirectionEnum = {
    Debit: 'Debit',
    Credit: 'Credit'
} as const;

export type ReceivedPaymentAttributesDirectionEnum = typeof ReceivedPaymentAttributesDirectionEnum[keyof typeof ReceivedPaymentAttributesDirectionEnum];

/**
 * 
 * @export
 * @interface ReceivedPaymentRelationship
 */
export interface ReceivedPaymentRelationship {
    /**
     * 
     * @type {ReceivedPaymentRelationshipData}
     * @memberof ReceivedPaymentRelationship
     */
    'data': ReceivedPaymentRelationshipData;
}
/**
 * 
 * @export
 * @interface ReceivedPaymentRelationshipData
 */
export interface ReceivedPaymentRelationshipData {
    /**
     * 
     * @type {string}
     * @memberof ReceivedPaymentRelationshipData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ReceivedPaymentRelationshipData
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ReceivedPaymentRelationships
 */
export interface ReceivedPaymentRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof ReceivedPaymentRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof ReceivedPaymentRelationships
     */
    'customer': CustomerRelationship;
    /**
     * 
     * @type {ReceivePaymentTransactionRelationship}
     * @memberof ReceivedPaymentRelationships
     */
    'receivePaymentTransaction'?: ReceivePaymentTransactionRelationship;
    /**
     * 
     * @type {PaymentAdvanceTransactionRelationship}
     * @memberof ReceivedPaymentRelationships
     */
    'paymentAdvanceTransaction'?: PaymentAdvanceTransactionRelationship;
    /**
     * 
     * @type {RepayPaymentAdvanceTransactionRelationship}
     * @memberof ReceivedPaymentRelationships
     */
    'repayPaymentAdvanceTransaction'?: RepayPaymentAdvanceTransactionRelationship;
}
/**
 * 
 * @export
 * @interface ReceiverAccountRelationship
 */
export interface ReceiverAccountRelationship {
    /**
     * 
     * @type {ReceiverAccountRelationshipData}
     * @memberof ReceiverAccountRelationship
     */
    'data': ReceiverAccountRelationshipData;
}
/**
 * 
 * @export
 * @interface ReceiverAccountRelationshipData
 */
export interface ReceiverAccountRelationshipData {
    /**
     * 
     * @type {string}
     * @memberof ReceiverAccountRelationshipData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ReceiverAccountRelationshipData
     */
    'type': ReceiverAccountRelationshipDataTypeEnum;
}

export const ReceiverAccountRelationshipDataTypeEnum = {
    Account: 'account'
} as const;

export type ReceiverAccountRelationshipDataTypeEnum = typeof ReceiverAccountRelationshipDataTypeEnum[keyof typeof ReceiverAccountRelationshipDataTypeEnum];

/**
 * 
 * @export
 * @interface ReceivingAccountRelationship
 */
export interface ReceivingAccountRelationship {
    /**
     * 
     * @type {ReceivingAccountRelationshipData}
     * @memberof ReceivingAccountRelationship
     */
    'data': ReceivingAccountRelationshipData;
}
/**
 * 
 * @export
 * @interface ReceivingAccountRelationshipData
 */
export interface ReceivingAccountRelationshipData {
    /**
     * 
     * @type {string}
     * @memberof ReceivingAccountRelationshipData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ReceivingAccountRelationshipData
     */
    'type': ReceivingAccountRelationshipDataTypeEnum;
}

export const ReceivingAccountRelationshipDataTypeEnum = {
    Account: 'account',
    DepositAccount: 'depositAccount',
    CreditAccount: 'creditAccount'
} as const;

export type ReceivingAccountRelationshipDataTypeEnum = typeof ReceivingAccountRelationshipDataTypeEnum[keyof typeof ReceivingAccountRelationshipDataTypeEnum];

/**
 * 
 * @export
 * @interface RecurringAchPaymentRelationships
 */
export interface RecurringAchPaymentRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof RecurringAchPaymentRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CreditAccountRelationship}
     * @memberof RecurringAchPaymentRelationships
     */
    'creditAccount': CreditAccountRelationship;
    /**
     * 
     * @type {CounterpartyRelationship}
     * @memberof RecurringAchPaymentRelationships
     */
    'counterparty': CounterpartyRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof RecurringAchPaymentRelationships
     */
    'customer': CustomerRelationship;
    /**
     * 
     * @type {OrgRelationship}
     * @memberof RecurringAchPaymentRelationships
     */
    'org': OrgRelationship;
}
/**
 * 
 * @export
 * @interface RecurringAchRepayment
 */
export interface RecurringAchRepayment extends RecurringRepayment {
    /**
     * 
     * @type {RecurringAchRepaymentAllOfAttributes}
     * @memberof RecurringAchRepayment
     */
    'attributes': RecurringAchRepaymentAllOfAttributes;
    /**
     * 
     * @type {RecurringAchRepaymentRelationships}
     * @memberof RecurringAchRepayment
     */
    'relationships': RecurringAchRepaymentRelationships;
}


/**
 * 
 * @export
 * @interface RecurringAchRepaymentAllOfAttributes
 */
export interface RecurringAchRepaymentAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof RecurringAchRepaymentAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof RecurringAchRepaymentAllOfAttributes
     */
    'updatedAt': string;
    /**
     * 
     * @type {ResponseSchedule}
     * @memberof RecurringAchRepaymentAllOfAttributes
     */
    'schedule': ResponseSchedule;
    /**
     * 
     * @type {string}
     * @memberof RecurringAchRepaymentAllOfAttributes
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof RecurringAchRepaymentAllOfAttributes
     */
    'addenda'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RecurringAchRepaymentAllOfAttributes
     */
    'sameDay'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RecurringAchRepaymentAllOfAttributes
     */
    'secCode'?: string;
    /**
     * 
     * @type {number}
     * @memberof RecurringAchRepaymentAllOfAttributes
     */
    'numberOfRepayments': number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RecurringAchRepaymentAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {RecurringRepaymentStatus}
     * @memberof RecurringAchRepaymentAllOfAttributes
     */
    'status': RecurringRepaymentStatus;
}


/**
 * 
 * @export
 * @interface RecurringAchRepaymentRelationships
 */
export interface RecurringAchRepaymentRelationships {
    /**
     * 
     * @type {RecurringRepaymentRelationshipsBaseCreditAccount}
     * @memberof RecurringAchRepaymentRelationships
     */
    'creditAccount': RecurringRepaymentRelationshipsBaseCreditAccount;
    /**
     * 
     * @type {RecurringRepaymentRelationshipsBaseCounterparty}
     * @memberof RecurringAchRepaymentRelationships
     */
    'counterparty': RecurringRepaymentRelationshipsBaseCounterparty;
    /**
     * 
     * @type {RecurringRepaymentRelationshipsBaseCustomer}
     * @memberof RecurringAchRepaymentRelationships
     */
    'customer'?: RecurringRepaymentRelationshipsBaseCustomer;
    /**
     * 
     * @type {RecurringRepaymentRelationshipsBaseOrg}
     * @memberof RecurringAchRepaymentRelationships
     */
    'org': RecurringRepaymentRelationshipsBaseOrg;
    /**
     * 
     * @type {RecurringAchRepaymentRelationshipsAllOfAccount}
     * @memberof RecurringAchRepaymentRelationships
     */
    'account': RecurringAchRepaymentRelationshipsAllOfAccount;
}
/**
 * 
 * @export
 * @interface RecurringAchRepaymentRelationshipsAllOfAccount
 */
export interface RecurringAchRepaymentRelationshipsAllOfAccount {
    /**
     * 
     * @type {RecurringAchRepaymentRelationshipsAllOfAccountData}
     * @memberof RecurringAchRepaymentRelationshipsAllOfAccount
     */
    'data': RecurringAchRepaymentRelationshipsAllOfAccountData;
}
/**
 * 
 * @export
 * @interface RecurringAchRepaymentRelationshipsAllOfAccountData
 */
export interface RecurringAchRepaymentRelationshipsAllOfAccountData {
    /**
     * 
     * @type {string}
     * @memberof RecurringAchRepaymentRelationshipsAllOfAccountData
     */
    'type': RecurringAchRepaymentRelationshipsAllOfAccountDataTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RecurringAchRepaymentRelationshipsAllOfAccountData
     */
    'id': string;
}

export const RecurringAchRepaymentRelationshipsAllOfAccountDataTypeEnum = {
    DepositAccount: 'depositAccount',
    Account: 'account'
} as const;

export type RecurringAchRepaymentRelationshipsAllOfAccountDataTypeEnum = typeof RecurringAchRepaymentRelationshipsAllOfAccountDataTypeEnum[keyof typeof RecurringAchRepaymentRelationshipsAllOfAccountDataTypeEnum];

/**
 * 
 * @export
 * @interface RecurringBookPaymentRelationships
 */
export interface RecurringBookPaymentRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof RecurringBookPaymentRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CreditAccountRelationship}
     * @memberof RecurringBookPaymentRelationships
     */
    'creditAccount': CreditAccountRelationship;
    /**
     * 
     * @type {CounterpartyRelationship}
     * @memberof RecurringBookPaymentRelationships
     */
    'counterparty': CounterpartyRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof RecurringBookPaymentRelationships
     */
    'customer': CustomerRelationship;
    /**
     * 
     * @type {OrgRelationship}
     * @memberof RecurringBookPaymentRelationships
     */
    'org': OrgRelationship;
}
/**
 * 
 * @export
 * @interface RecurringBookRepayment
 */
export interface RecurringBookRepayment extends RecurringRepayment {
    /**
     * 
     * @type {RecurringBookRepaymentAllOfAttributes}
     * @memberof RecurringBookRepayment
     */
    'attributes': RecurringBookRepaymentAllOfAttributes;
    /**
     * 
     * @type {RecurringBookRepaymentRelationships}
     * @memberof RecurringBookRepayment
     */
    'relationships': RecurringBookRepaymentRelationships;
}


/**
 * 
 * @export
 * @interface RecurringBookRepaymentAllOfAttributes
 */
export interface RecurringBookRepaymentAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof RecurringBookRepaymentAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof RecurringBookRepaymentAllOfAttributes
     */
    'updatedAt': string;
    /**
     * 
     * @type {ResponseSchedule}
     * @memberof RecurringBookRepaymentAllOfAttributes
     */
    'schedule': ResponseSchedule;
    /**
     * 
     * @type {string}
     * @memberof RecurringBookRepaymentAllOfAttributes
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof RecurringBookRepaymentAllOfAttributes
     */
    'transactionSummaryOverride'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RecurringBookRepaymentAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof RecurringBookRepaymentAllOfAttributes
     */
    'numberOfRepayments': number;
    /**
     * 
     * @type {RecurringRepaymentStatus}
     * @memberof RecurringBookRepaymentAllOfAttributes
     */
    'status': RecurringRepaymentStatus;
}


/**
 * 
 * @export
 * @interface RecurringBookRepaymentRelationships
 */
export interface RecurringBookRepaymentRelationships {
    /**
     * 
     * @type {RecurringRepaymentRelationshipsBaseCreditAccount}
     * @memberof RecurringBookRepaymentRelationships
     */
    'creditAccount': RecurringRepaymentRelationshipsBaseCreditAccount;
    /**
     * 
     * @type {RecurringRepaymentRelationshipsBaseCounterparty}
     * @memberof RecurringBookRepaymentRelationships
     */
    'counterparty': RecurringRepaymentRelationshipsBaseCounterparty;
    /**
     * 
     * @type {RecurringRepaymentRelationshipsBaseCustomer}
     * @memberof RecurringBookRepaymentRelationships
     */
    'customer'?: RecurringRepaymentRelationshipsBaseCustomer;
    /**
     * 
     * @type {RecurringRepaymentRelationshipsBaseOrg}
     * @memberof RecurringBookRepaymentRelationships
     */
    'org': RecurringRepaymentRelationshipsBaseOrg;
    /**
     * 
     * @type {RecurringAchRepaymentRelationshipsAllOfAccount}
     * @memberof RecurringBookRepaymentRelationships
     */
    'account': RecurringAchRepaymentRelationshipsAllOfAccount;
}
/**
 * 
 * @export
 * @interface RecurringCapitalPartnerAchRepayment
 */
export interface RecurringCapitalPartnerAchRepayment extends RecurringRepayment {
    /**
     * 
     * @type {RecurringCapitalPartnerAchRepaymentAllOfAttributes}
     * @memberof RecurringCapitalPartnerAchRepayment
     */
    'attributes': RecurringCapitalPartnerAchRepaymentAllOfAttributes;
    /**
     * 
     * @type {RecurringCapitalPartnerAchRepaymentRelationships}
     * @memberof RecurringCapitalPartnerAchRepayment
     */
    'relationships': RecurringCapitalPartnerAchRepaymentRelationships;
}


/**
 * 
 * @export
 * @interface RecurringCapitalPartnerAchRepaymentAllOfAttributes
 */
export interface RecurringCapitalPartnerAchRepaymentAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof RecurringCapitalPartnerAchRepaymentAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof RecurringCapitalPartnerAchRepaymentAllOfAttributes
     */
    'updatedAt': string;
    /**
     * 
     * @type {ResponseSchedule}
     * @memberof RecurringCapitalPartnerAchRepaymentAllOfAttributes
     */
    'schedule': ResponseSchedule;
    /**
     * 
     * @type {string}
     * @memberof RecurringCapitalPartnerAchRepaymentAllOfAttributes
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof RecurringCapitalPartnerAchRepaymentAllOfAttributes
     */
    'addenda'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RecurringCapitalPartnerAchRepaymentAllOfAttributes
     */
    'sameDay'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RecurringCapitalPartnerAchRepaymentAllOfAttributes
     */
    'secCode'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RecurringCapitalPartnerAchRepaymentAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof RecurringCapitalPartnerAchRepaymentAllOfAttributes
     */
    'numberOfRepayments': number;
    /**
     * 
     * @type {RecurringRepaymentStatus}
     * @memberof RecurringCapitalPartnerAchRepaymentAllOfAttributes
     */
    'status': RecurringRepaymentStatus;
}


/**
 * 
 * @export
 * @interface RecurringCapitalPartnerAchRepaymentRelationships
 */
export interface RecurringCapitalPartnerAchRepaymentRelationships {
    /**
     * 
     * @type {RecurringRepaymentRelationshipsBaseCreditAccount}
     * @memberof RecurringCapitalPartnerAchRepaymentRelationships
     */
    'creditAccount': RecurringRepaymentRelationshipsBaseCreditAccount;
    /**
     * 
     * @type {RecurringRepaymentRelationshipsBaseCounterparty}
     * @memberof RecurringCapitalPartnerAchRepaymentRelationships
     */
    'counterparty': RecurringRepaymentRelationshipsBaseCounterparty;
    /**
     * 
     * @type {RecurringRepaymentRelationshipsBaseCustomer}
     * @memberof RecurringCapitalPartnerAchRepaymentRelationships
     */
    'customer'?: RecurringRepaymentRelationshipsBaseCustomer;
    /**
     * 
     * @type {RecurringRepaymentRelationshipsBaseOrg}
     * @memberof RecurringCapitalPartnerAchRepaymentRelationships
     */
    'org': RecurringRepaymentRelationshipsBaseOrg;
}
/**
 * 
 * @export
 * @interface RecurringCapitalPartnerBookRepayment
 */
export interface RecurringCapitalPartnerBookRepayment extends RecurringRepayment {
    /**
     * 
     * @type {RecurringBookRepaymentAllOfAttributes}
     * @memberof RecurringCapitalPartnerBookRepayment
     */
    'attributes': RecurringBookRepaymentAllOfAttributes;
    /**
     * 
     * @type {RecurringCapitalPartnerBookRepaymentRelationships}
     * @memberof RecurringCapitalPartnerBookRepayment
     */
    'relationships': RecurringCapitalPartnerBookRepaymentRelationships;
}


/**
 * 
 * @export
 * @interface RecurringCapitalPartnerBookRepaymentRelationships
 */
export interface RecurringCapitalPartnerBookRepaymentRelationships {
    /**
     * 
     * @type {RecurringRepaymentRelationshipsBaseCreditAccount}
     * @memberof RecurringCapitalPartnerBookRepaymentRelationships
     */
    'creditAccount': RecurringRepaymentRelationshipsBaseCreditAccount;
    /**
     * 
     * @type {RecurringRepaymentRelationshipsBaseCounterparty}
     * @memberof RecurringCapitalPartnerBookRepaymentRelationships
     */
    'counterparty': RecurringRepaymentRelationshipsBaseCounterparty;
    /**
     * 
     * @type {RecurringRepaymentRelationshipsBaseCustomer}
     * @memberof RecurringCapitalPartnerBookRepaymentRelationships
     */
    'customer'?: RecurringRepaymentRelationshipsBaseCustomer;
    /**
     * 
     * @type {RecurringRepaymentRelationshipsBaseOrg}
     * @memberof RecurringCapitalPartnerBookRepaymentRelationships
     */
    'org': RecurringRepaymentRelationshipsBaseOrg;
}
/**
 * 
 * @export
 * @interface RecurringCreditAchPayment
 */
export interface RecurringCreditAchPayment extends RecurringPayment {
    /**
     * 
     * @type {RecurringCreditAchPaymentAllOfAttributes}
     * @memberof RecurringCreditAchPayment
     */
    'attributes': RecurringCreditAchPaymentAllOfAttributes;
    /**
     * 
     * @type {RecurringAchPaymentRelationships}
     * @memberof RecurringCreditAchPayment
     */
    'relationships': RecurringAchPaymentRelationships;
}


/**
 * 
 * @export
 * @interface RecurringCreditAchPaymentAllOfAttributes
 */
export interface RecurringCreditAchPaymentAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof RecurringCreditAchPaymentAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof RecurringCreditAchPaymentAllOfAttributes
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof RecurringCreditAchPaymentAllOfAttributes
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof RecurringCreditAchPaymentAllOfAttributes
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof RecurringCreditAchPaymentAllOfAttributes
     */
    'addenda'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RecurringCreditAchPaymentAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof RecurringCreditAchPaymentAllOfAttributes
     */
    'status': RecurringCreditAchPaymentAllOfAttributesStatusEnum;
    /**
     * 
     * @type {ResponseSchedule}
     * @memberof RecurringCreditAchPaymentAllOfAttributes
     */
    'schedule': ResponseSchedule;
    /**
     * 
     * @type {number}
     * @memberof RecurringCreditAchPaymentAllOfAttributes
     */
    'numberOfPayments': number;
}

export const RecurringCreditAchPaymentAllOfAttributesStatusEnum = {
    Pending: 'Pending',
    Active: 'Active',
    Completed: 'Completed',
    Disabled: 'Disabled'
} as const;

export type RecurringCreditAchPaymentAllOfAttributesStatusEnum = typeof RecurringCreditAchPaymentAllOfAttributesStatusEnum[keyof typeof RecurringCreditAchPaymentAllOfAttributesStatusEnum];

/**
 * 
 * @export
 * @interface RecurringCreditBookPayment
 */
export interface RecurringCreditBookPayment extends RecurringPayment {
    /**
     * 
     * @type {RecurringCreditBookPaymentAllOfAttributes}
     * @memberof RecurringCreditBookPayment
     */
    'attributes': RecurringCreditBookPaymentAllOfAttributes;
    /**
     * 
     * @type {RecurringBookPaymentRelationships}
     * @memberof RecurringCreditBookPayment
     */
    'relationships': RecurringBookPaymentRelationships;
}


/**
 * 
 * @export
 * @interface RecurringCreditBookPaymentAllOfAttributes
 */
export interface RecurringCreditBookPaymentAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof RecurringCreditBookPaymentAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof RecurringCreditBookPaymentAllOfAttributes
     */
    'updatedAt': string;
    /**
     * 
     * @type {number}
     * @memberof RecurringCreditBookPaymentAllOfAttributes
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof RecurringCreditBookPaymentAllOfAttributes
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof RecurringCreditBookPaymentAllOfAttributes
     */
    'status': RecurringCreditBookPaymentAllOfAttributesStatusEnum;
    /**
     * 
     * @type {ResponseSchedule}
     * @memberof RecurringCreditBookPaymentAllOfAttributes
     */
    'schedule': ResponseSchedule;
    /**
     * 
     * @type {number}
     * @memberof RecurringCreditBookPaymentAllOfAttributes
     */
    'numberOfPayments': number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RecurringCreditBookPaymentAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
}

export const RecurringCreditBookPaymentAllOfAttributesStatusEnum = {
    Pending: 'Pending',
    Active: 'Active',
    Completed: 'Completed',
    Disabled: 'Disabled'
} as const;

export type RecurringCreditBookPaymentAllOfAttributesStatusEnum = typeof RecurringCreditBookPaymentAllOfAttributesStatusEnum[keyof typeof RecurringCreditBookPaymentAllOfAttributesStatusEnum];

/**
 * 
 * @export
 * @interface RecurringDebitAchPayment
 */
export interface RecurringDebitAchPayment extends RecurringPayment {
    /**
     * 
     * @type {RecurringDebitAchPaymentAllOfAttributes}
     * @memberof RecurringDebitAchPayment
     */
    'attributes': RecurringDebitAchPaymentAllOfAttributes;
    /**
     * 
     * @type {RecurringAchPaymentRelationships}
     * @memberof RecurringDebitAchPayment
     */
    'relationships': RecurringAchPaymentRelationships;
}


/**
 * 
 * @export
 * @interface RecurringDebitAchPaymentAllOfAttributes
 */
export interface RecurringDebitAchPaymentAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof RecurringDebitAchPaymentAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof RecurringDebitAchPaymentAllOfAttributes
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof RecurringDebitAchPaymentAllOfAttributes
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof RecurringDebitAchPaymentAllOfAttributes
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof RecurringDebitAchPaymentAllOfAttributes
     */
    'addenda'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RecurringDebitAchPaymentAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof RecurringDebitAchPaymentAllOfAttributes
     */
    'status': RecurringDebitAchPaymentAllOfAttributesStatusEnum;
    /**
     * 
     * @type {ResponseSchedule}
     * @memberof RecurringDebitAchPaymentAllOfAttributes
     */
    'schedule': ResponseSchedule;
    /**
     * 
     * @type {number}
     * @memberof RecurringDebitAchPaymentAllOfAttributes
     */
    'numberOfPayments': number;
    /**
     * 
     * @type {boolean}
     * @memberof RecurringDebitAchPaymentAllOfAttributes
     */
    'verifyCounterpartyBalance'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RecurringDebitAchPaymentAllOfAttributes
     */
    'sameDay'?: boolean;
}

export const RecurringDebitAchPaymentAllOfAttributesStatusEnum = {
    Pending: 'Pending',
    Active: 'Active',
    Completed: 'Completed',
    Disabled: 'Disabled'
} as const;

export type RecurringDebitAchPaymentAllOfAttributesStatusEnum = typeof RecurringDebitAchPaymentAllOfAttributesStatusEnum[keyof typeof RecurringDebitAchPaymentAllOfAttributesStatusEnum];

/**
 * 
 * @export
 * @interface RecurringPayment
 */
export interface RecurringPayment {
    /**
     * 
     * @type {string}
     * @memberof RecurringPayment
     */
    'type'?: RecurringPaymentTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RecurringPayment
     */
    'id'?: string;
}

export const RecurringPaymentTypeEnum = {
    RecurringCreditAchPayment: 'recurringCreditAchPayment',
    RecurringDebitAchPayment: 'recurringDebitAchPayment',
    RecurringCreditBookPayment: 'recurringCreditBookPayment'
} as const;

export type RecurringPaymentTypeEnum = typeof RecurringPaymentTypeEnum[keyof typeof RecurringPaymentTypeEnum];

/**
 * 
 * @export
 * @interface RecurringPaymentRelationship
 */
export interface RecurringPaymentRelationship {
    /**
     * 
     * @type {RecurringPaymentRelationshipData}
     * @memberof RecurringPaymentRelationship
     */
    'data': RecurringPaymentRelationshipData;
}
/**
 * 
 * @export
 * @interface RecurringPaymentRelationshipData
 */
export interface RecurringPaymentRelationshipData {
    /**
     * 
     * @type {string}
     * @memberof RecurringPaymentRelationshipData
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof RecurringPaymentRelationshipData
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface RecurringRepayment
 */
export interface RecurringRepayment {
    /**
     * 
     * @type {string}
     * @memberof RecurringRepayment
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RecurringRepayment
     */
    'type'?: RecurringRepaymentTypeEnum;
}

export const RecurringRepaymentTypeEnum = {
    RecurringAchRepayment: 'recurringAchRepayment',
    RecurringBookRepayment: 'recurringBookRepayment',
    RecurringCapitalPartnerAchRepayment: 'recurringCapitalPartnerAchRepayment',
    RecurrinCapitalPartnerBookRepayment: 'recurrinCapitalPartnerBookRepayment'
} as const;

export type RecurringRepaymentTypeEnum = typeof RecurringRepaymentTypeEnum[keyof typeof RecurringRepaymentTypeEnum];

/**
 * 
 * @export
 * @interface RecurringRepaymentRelationship
 */
export interface RecurringRepaymentRelationship {
    /**
     * 
     * @type {RecurringRepaymentRelationshipData}
     * @memberof RecurringRepaymentRelationship
     */
    'data': RecurringRepaymentRelationshipData;
}
/**
 * 
 * @export
 * @interface RecurringRepaymentRelationshipData
 */
export interface RecurringRepaymentRelationshipData {
    /**
     * 
     * @type {string}
     * @memberof RecurringRepaymentRelationshipData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof RecurringRepaymentRelationshipData
     */
    'type': RecurringRepaymentRelationshipDataTypeEnum;
}

export const RecurringRepaymentRelationshipDataTypeEnum = {
    RecurringRepayment: 'recurringRepayment'
} as const;

export type RecurringRepaymentRelationshipDataTypeEnum = typeof RecurringRepaymentRelationshipDataTypeEnum[keyof typeof RecurringRepaymentRelationshipDataTypeEnum];

/**
 * 
 * @export
 * @interface RecurringRepaymentRelationshipsBase
 */
export interface RecurringRepaymentRelationshipsBase {
    /**
     * 
     * @type {RecurringRepaymentRelationshipsBaseCreditAccount}
     * @memberof RecurringRepaymentRelationshipsBase
     */
    'creditAccount': RecurringRepaymentRelationshipsBaseCreditAccount;
    /**
     * 
     * @type {RecurringRepaymentRelationshipsBaseCounterparty}
     * @memberof RecurringRepaymentRelationshipsBase
     */
    'counterparty': RecurringRepaymentRelationshipsBaseCounterparty;
    /**
     * 
     * @type {RecurringRepaymentRelationshipsBaseCustomer}
     * @memberof RecurringRepaymentRelationshipsBase
     */
    'customer'?: RecurringRepaymentRelationshipsBaseCustomer;
    /**
     * 
     * @type {RecurringRepaymentRelationshipsBaseOrg}
     * @memberof RecurringRepaymentRelationshipsBase
     */
    'org': RecurringRepaymentRelationshipsBaseOrg;
}
/**
 * 
 * @export
 * @interface RecurringRepaymentRelationshipsBaseCounterparty
 */
export interface RecurringRepaymentRelationshipsBaseCounterparty {
    /**
     * 
     * @type {RecurringRepaymentRelationshipsBaseCounterpartyData}
     * @memberof RecurringRepaymentRelationshipsBaseCounterparty
     */
    'data': RecurringRepaymentRelationshipsBaseCounterpartyData;
}
/**
 * 
 * @export
 * @interface RecurringRepaymentRelationshipsBaseCounterpartyData
 */
export interface RecurringRepaymentRelationshipsBaseCounterpartyData {
    /**
     * 
     * @type {string}
     * @memberof RecurringRepaymentRelationshipsBaseCounterpartyData
     */
    'type': RecurringRepaymentRelationshipsBaseCounterpartyDataTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RecurringRepaymentRelationshipsBaseCounterpartyData
     */
    'id': string;
}

export const RecurringRepaymentRelationshipsBaseCounterpartyDataTypeEnum = {
    Counterparty: 'counterparty'
} as const;

export type RecurringRepaymentRelationshipsBaseCounterpartyDataTypeEnum = typeof RecurringRepaymentRelationshipsBaseCounterpartyDataTypeEnum[keyof typeof RecurringRepaymentRelationshipsBaseCounterpartyDataTypeEnum];

/**
 * 
 * @export
 * @interface RecurringRepaymentRelationshipsBaseCreditAccount
 */
export interface RecurringRepaymentRelationshipsBaseCreditAccount {
    /**
     * 
     * @type {RecurringRepaymentRelationshipsBaseCreditAccountData}
     * @memberof RecurringRepaymentRelationshipsBaseCreditAccount
     */
    'data': RecurringRepaymentRelationshipsBaseCreditAccountData;
}
/**
 * 
 * @export
 * @interface RecurringRepaymentRelationshipsBaseCreditAccountData
 */
export interface RecurringRepaymentRelationshipsBaseCreditAccountData {
    /**
     * 
     * @type {string}
     * @memberof RecurringRepaymentRelationshipsBaseCreditAccountData
     */
    'type': RecurringRepaymentRelationshipsBaseCreditAccountDataTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RecurringRepaymentRelationshipsBaseCreditAccountData
     */
    'id': string;
}

export const RecurringRepaymentRelationshipsBaseCreditAccountDataTypeEnum = {
    CreditAccount: 'creditAccount'
} as const;

export type RecurringRepaymentRelationshipsBaseCreditAccountDataTypeEnum = typeof RecurringRepaymentRelationshipsBaseCreditAccountDataTypeEnum[keyof typeof RecurringRepaymentRelationshipsBaseCreditAccountDataTypeEnum];

/**
 * 
 * @export
 * @interface RecurringRepaymentRelationshipsBaseCustomer
 */
export interface RecurringRepaymentRelationshipsBaseCustomer {
    /**
     * 
     * @type {RecurringRepaymentRelationshipsBaseCustomerData}
     * @memberof RecurringRepaymentRelationshipsBaseCustomer
     */
    'data': RecurringRepaymentRelationshipsBaseCustomerData;
}
/**
 * 
 * @export
 * @interface RecurringRepaymentRelationshipsBaseCustomerData
 */
export interface RecurringRepaymentRelationshipsBaseCustomerData {
    /**
     * 
     * @type {string}
     * @memberof RecurringRepaymentRelationshipsBaseCustomerData
     */
    'type': RecurringRepaymentRelationshipsBaseCustomerDataTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RecurringRepaymentRelationshipsBaseCustomerData
     */
    'id': string;
}

export const RecurringRepaymentRelationshipsBaseCustomerDataTypeEnum = {
    BusinessCustomer: 'businessCustomer',
    IndividualCustomer: 'individualCustomer',
    Customer: 'customer'
} as const;

export type RecurringRepaymentRelationshipsBaseCustomerDataTypeEnum = typeof RecurringRepaymentRelationshipsBaseCustomerDataTypeEnum[keyof typeof RecurringRepaymentRelationshipsBaseCustomerDataTypeEnum];

/**
 * 
 * @export
 * @interface RecurringRepaymentRelationshipsBaseOrg
 */
export interface RecurringRepaymentRelationshipsBaseOrg {
    /**
     * 
     * @type {RecurringRepaymentRelationshipsBaseOrgData}
     * @memberof RecurringRepaymentRelationshipsBaseOrg
     */
    'data': RecurringRepaymentRelationshipsBaseOrgData;
}
/**
 * 
 * @export
 * @interface RecurringRepaymentRelationshipsBaseOrgData
 */
export interface RecurringRepaymentRelationshipsBaseOrgData {
    /**
     * 
     * @type {string}
     * @memberof RecurringRepaymentRelationshipsBaseOrgData
     */
    'type': RecurringRepaymentRelationshipsBaseOrgDataTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RecurringRepaymentRelationshipsBaseOrgData
     */
    'id': string;
}

export const RecurringRepaymentRelationshipsBaseOrgDataTypeEnum = {
    Org: 'org'
} as const;

export type RecurringRepaymentRelationshipsBaseOrgDataTypeEnum = typeof RecurringRepaymentRelationshipsBaseOrgDataTypeEnum[keyof typeof RecurringRepaymentRelationshipsBaseOrgDataTypeEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const RecurringRepaymentStatus = {
    Active: 'Active',
    Disabled: 'Disabled'
} as const;

export type RecurringRepaymentStatus = typeof RecurringRepaymentStatus[keyof typeof RecurringRepaymentStatus];


/**
 * 
 * @export
 * @interface RelatedTransactionRelationship
 */
export interface RelatedTransactionRelationship {
    /**
     * 
     * @type {TransactionRelationshipData}
     * @memberof RelatedTransactionRelationship
     */
    'data': TransactionRelationshipData;
}
/**
 * 
 * @export
 * @interface Relationship
 */
export interface Relationship {
    /**
     * 
     * @type {RelationshipData}
     * @memberof Relationship
     */
    'data': RelationshipData;
}
/**
 * 
 * @export
 * @interface RelationshipData
 */
export interface RelationshipData {
    /**
     * 
     * @type {string}
     * @memberof RelationshipData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof RelationshipData
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ReleaseTransaction
 */
export interface ReleaseTransaction extends Transaction {
    /**
     * 
     * @type {ReleaseTransactionAllOfAttributes}
     * @memberof ReleaseTransaction
     */
    'attributes': ReleaseTransactionAllOfAttributes;
    /**
     * 
     * @type {ReleaseTransactionRelationships}
     * @memberof ReleaseTransaction
     */
    'relationships': ReleaseTransactionRelationships;
}


/**
 * 
 * @export
 * @interface ReleaseTransactionAllOfAttributes
 */
export interface ReleaseTransactionAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof ReleaseTransactionAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ReleaseTransactionAllOfAttributes
     */
    'direction': ReleaseTransactionAllOfAttributesDirectionEnum;
    /**
     * 
     * @type {number}
     * @memberof ReleaseTransactionAllOfAttributes
     */
    'amount': number;
    /**
     * 
     * @type {number}
     * @memberof ReleaseTransactionAllOfAttributes
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof ReleaseTransactionAllOfAttributes
     */
    'summary': string;
    /**
     * 
     * @type {string}
     * @memberof ReleaseTransactionAllOfAttributes
     */
    'senderName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReleaseTransactionAllOfAttributes
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReleaseTransactionAllOfAttributes
     */
    'senderAccountNumber'?: string;
    /**
     * 
     * @type {Address}
     * @memberof ReleaseTransactionAllOfAttributes
     */
    'senderAddress'?: Address;
    /**
     * 
     * @type {PaymentCounterparty}
     * @memberof ReleaseTransactionAllOfAttributes
     */
    'counterparty': PaymentCounterparty;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ReleaseTransactionAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
}

export const ReleaseTransactionAllOfAttributesDirectionEnum = {
    Credit: 'Credit',
    Debit: 'Debit'
} as const;

export type ReleaseTransactionAllOfAttributesDirectionEnum = typeof ReleaseTransactionAllOfAttributesDirectionEnum[keyof typeof ReleaseTransactionAllOfAttributesDirectionEnum];

/**
 * 
 * @export
 * @interface ReleaseTransactionRelationships
 */
export interface ReleaseTransactionRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof ReleaseTransactionRelationships
     */
    'account': AccountRelationship;
}
/**
 * 
 * @export
 * @interface RemoveAuthorizedUsersRequest
 */
export interface RemoveAuthorizedUsersRequest {
    /**
     * 
     * @type {RemoveAuthorizedUsersRequestData}
     * @memberof RemoveAuthorizedUsersRequest
     */
    'data'?: RemoveAuthorizedUsersRequestData;
}
/**
 * 
 * @export
 * @interface RemoveAuthorizedUsersRequestData
 */
export interface RemoveAuthorizedUsersRequestData {
    /**
     * 
     * @type {string}
     * @memberof RemoveAuthorizedUsersRequestData
     */
    'type'?: RemoveAuthorizedUsersRequestDataTypeEnum;
    /**
     * 
     * @type {RemoveAuthorizedUsersRequestDataAttributes}
     * @memberof RemoveAuthorizedUsersRequestData
     */
    'attributes'?: RemoveAuthorizedUsersRequestDataAttributes;
}

export const RemoveAuthorizedUsersRequestDataTypeEnum = {
    RemoveAuthorizedUsers: 'removeAuthorizedUsers'
} as const;

export type RemoveAuthorizedUsersRequestDataTypeEnum = typeof RemoveAuthorizedUsersRequestDataTypeEnum[keyof typeof RemoveAuthorizedUsersRequestDataTypeEnum];

/**
 * 
 * @export
 * @interface RemoveAuthorizedUsersRequestDataAttributes
 */
export interface RemoveAuthorizedUsersRequestDataAttributes {
    /**
     * 
     * @type {Array<string>}
     * @memberof RemoveAuthorizedUsersRequestDataAttributes
     */
    'authorizedUsersEmails'?: Array<string>;
}
/**
 * 
 * @export
 * @interface RepaidPaymentAdvanceTransaction
 */
export interface RepaidPaymentAdvanceTransaction extends Transaction {
    /**
     * 
     * @type {CheckDepositTransactionAllOfAttributes}
     * @memberof RepaidPaymentAdvanceTransaction
     */
    'attributes': CheckDepositTransactionAllOfAttributes;
    /**
     * 
     * @type {RepaidPaymentAdvanceTransactionRelationships}
     * @memberof RepaidPaymentAdvanceTransaction
     */
    'relationships': RepaidPaymentAdvanceTransactionRelationships;
}


/**
 * 
 * @export
 * @interface RepaidPaymentAdvanceTransactionRelationships
 */
export interface RepaidPaymentAdvanceTransactionRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof RepaidPaymentAdvanceTransactionRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof RepaidPaymentAdvanceTransactionRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {ReceivedPaymentRelationship}
     * @memberof RepaidPaymentAdvanceTransactionRelationships
     */
    'receivedPayment': ReceivedPaymentRelationship;
    /**
     * 
     * @type {PaymentAdvanceTransactionRelationship}
     * @memberof RepaidPaymentAdvanceTransactionRelationships
     */
    'paymentAdvanceTransaction': PaymentAdvanceTransactionRelationship;
}
/**
 * 
 * @export
 * @interface RepayPaymentAdvanceTransactionRelationship
 */
export interface RepayPaymentAdvanceTransactionRelationship {
    /**
     * 
     * @type {TransactionRelationshipData}
     * @memberof RepayPaymentAdvanceTransactionRelationship
     */
    'data': TransactionRelationshipData;
}
/**
 * 
 * @export
 * @interface Repayment
 */
export interface Repayment {
    /**
     * 
     * @type {string}
     * @memberof Repayment
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Repayment
     */
    'type'?: RepaymentTypeEnum;
}

export const RepaymentTypeEnum = {
    AchRepayment: 'achRepayment',
    BookRepayment: 'bookRepayment',
    CapitalPartnerAchRepayment: 'capitalPartnerAchRepayment',
    CapitalPartnerBookRepayment: 'capitalPartnerBookRepayment'
} as const;

export type RepaymentTypeEnum = typeof RepaymentTypeEnum[keyof typeof RepaymentTypeEnum];

/**
 * 
 * @export
 * @interface RepaymentRelationship
 */
export interface RepaymentRelationship {
    /**
     * 
     * @type {RepaymentRelationshipData}
     * @memberof RepaymentRelationship
     */
    'data': RepaymentRelationshipData;
}
/**
 * 
 * @export
 * @interface RepaymentRelationshipData
 */
export interface RepaymentRelationshipData {
    /**
     * 
     * @type {string}
     * @memberof RepaymentRelationshipData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof RepaymentRelationshipData
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface RequireIdVerification
 */
export interface RequireIdVerification {
    /**
     * 
     * @type {boolean}
     * @memberof RequireIdVerification
     */
    'individual'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RequireIdVerification
     */
    'officer'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RequireIdVerification
     */
    'beneficialOwners'?: boolean;
}
/**
 * 
 * @export
 * @interface ResponseContact
 */
export interface ResponseContact {
    /**
     * 
     * @type {FullName}
     * @memberof ResponseContact
     */
    'fullName': FullName;
    /**
     * 
     * @type {string}
     * @memberof ResponseContact
     */
    'email': string;
    /**
     * 
     * @type {Phone}
     * @memberof ResponseContact
     */
    'phone': Phone;
    /**
     * 
     * @type {string}
     * @memberof ResponseContact
     */
    'jwtSubject'?: string | null;
}
/**
 * 
 * @export
 * @interface ResponseMonthlySchedule
 */
export interface ResponseMonthlySchedule extends ResponseSchedule {
    /**
     * 
     * @type {string}
     * @memberof ResponseMonthlySchedule
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseMonthlySchedule
     */
    'endTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof ResponseMonthlySchedule
     */
    'dayOfMonth'?: number;
    /**
     * 
     * @type {string}
     * @memberof ResponseMonthlySchedule
     */
    'dayOfWeek'?: ResponseMonthlyScheduleDayOfWeekEnum;
    /**
     * 
     * @type {number}
     * @memberof ResponseMonthlySchedule
     */
    'totalNumberOfPayments'?: number;
}

export const ResponseMonthlyScheduleDayOfWeekEnum = {
    Sunday: 'Sunday',
    Monday: 'Monday',
    Tuesday: 'Tuesday',
    Wednesday: 'Wednesday',
    Thursday: 'Thursday',
    Friday: 'Friday',
    Saturday: 'Saturday'
} as const;

export type ResponseMonthlyScheduleDayOfWeekEnum = typeof ResponseMonthlyScheduleDayOfWeekEnum[keyof typeof ResponseMonthlyScheduleDayOfWeekEnum];

/**
 * 
 * @export
 * @interface ResponseSchedule
 */
export interface ResponseSchedule {
    /**
     * 
     * @type {string}
     * @memberof ResponseSchedule
     */
    'interval': ResponseScheduleIntervalEnum;
}

export const ResponseScheduleIntervalEnum = {
    Weekly: 'Weekly',
    Monthly: 'Monthly'
} as const;

export type ResponseScheduleIntervalEnum = typeof ResponseScheduleIntervalEnum[keyof typeof ResponseScheduleIntervalEnum];

/**
 * 
 * @export
 * @interface ResponseWeeklySchedule
 */
export interface ResponseWeeklySchedule extends ResponseSchedule {
    /**
     * 
     * @type {string}
     * @memberof ResponseWeeklySchedule
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseWeeklySchedule
     */
    'endTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof ResponseWeeklySchedule
     */
    'dayOfMonth'?: number;
    /**
     * 
     * @type {string}
     * @memberof ResponseWeeklySchedule
     */
    'nextScheduledAction': string;
    /**
     * 
     * @type {number}
     * @memberof ResponseWeeklySchedule
     */
    'totalNumberOfPayments'?: number;
}


/**
 * 
 * @export
 * @interface ReturnCheckPaymentRequest
 */
export interface ReturnCheckPaymentRequest {
    /**
     * 
     * @type {ReturnCheckPaymentRequestData}
     * @memberof ReturnCheckPaymentRequest
     */
    'data'?: ReturnCheckPaymentRequestData;
}
/**
 * 
 * @export
 * @interface ReturnCheckPaymentRequestData
 */
export interface ReturnCheckPaymentRequestData {
    /**
     * 
     * @type {string}
     * @memberof ReturnCheckPaymentRequestData
     */
    'type'?: ReturnCheckPaymentRequestDataTypeEnum;
    /**
     * 
     * @type {ReturnCheckPaymentRequestDataAttributes}
     * @memberof ReturnCheckPaymentRequestData
     */
    'attributes'?: ReturnCheckPaymentRequestDataAttributes;
}

export const ReturnCheckPaymentRequestDataTypeEnum = {
    CheckPaymentReturn: 'checkPaymentReturn'
} as const;

export type ReturnCheckPaymentRequestDataTypeEnum = typeof ReturnCheckPaymentRequestDataTypeEnum[keyof typeof ReturnCheckPaymentRequestDataTypeEnum];

/**
 * 
 * @export
 * @interface ReturnCheckPaymentRequestDataAttributes
 */
export interface ReturnCheckPaymentRequestDataAttributes {
    /**
     * 
     * @type {ReturnReason}
     * @memberof ReturnCheckPaymentRequestDataAttributes
     */
    'reason'?: ReturnReason;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ReturnReason = {
    InsufficientFunds: 'InsufficientFunds',
    AccountClosed: 'AccountClosed',
    AlteredCheck: 'AlteredCheck',
    ForgedSignature: 'ForgedSignature',
    PostdatedCheck: 'PostdatedCheck',
    StopPaymentOrder: 'StopPaymentOrder',
    UnauthorizedDebit: 'UnauthorizedDebit',
    WrongAmount: 'WrongAmount',
    DuplicatePayment: 'DuplicatePayment',
    MissingSignature: 'MissingSignature',
    IrregularEndorsement: 'IrregularEndorsement',
    Other: 'Other'
} as const;

export type ReturnReason = typeof ReturnReason[keyof typeof ReturnReason];


/**
 * 
 * @export
 * @interface ReturnedAchTransaction
 */
export interface ReturnedAchTransaction extends Transaction {
    /**
     * 
     * @type {ReturnedAchTransactionAllOfAttributes}
     * @memberof ReturnedAchTransaction
     */
    'attributes': ReturnedAchTransactionAllOfAttributes;
    /**
     * 
     * @type {ReturnedAchTransactionRelationships}
     * @memberof ReturnedAchTransaction
     */
    'relationships': ReturnedAchTransactionRelationships;
}


/**
 * 
 * @export
 * @interface ReturnedAchTransactionAllOfAttributes
 */
export interface ReturnedAchTransactionAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof ReturnedAchTransactionAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ReturnedAchTransactionAllOfAttributes
     */
    'direction': ReturnedAchTransactionAllOfAttributesDirectionEnum;
    /**
     * 
     * @type {number}
     * @memberof ReturnedAchTransactionAllOfAttributes
     */
    'amount': number;
    /**
     * 
     * @type {number}
     * @memberof ReturnedAchTransactionAllOfAttributes
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof ReturnedAchTransactionAllOfAttributes
     */
    'summary': string;
    /**
     * 
     * @type {string}
     * @memberof ReturnedAchTransactionAllOfAttributes
     */
    'companyName': string;
    /**
     * 
     * @type {string}
     * @memberof ReturnedAchTransactionAllOfAttributes
     */
    'counterpartyName': string;
    /**
     * 
     * @type {string}
     * @memberof ReturnedAchTransactionAllOfAttributes
     */
    'counterpartyRoutingNumber': string;
    /**
     * 
     * @type {string}
     * @memberof ReturnedAchTransactionAllOfAttributes
     */
    'reason': string;
    /**
     * 
     * @type {string}
     * @memberof ReturnedAchTransactionAllOfAttributes
     */
    'achReason'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ReturnedAchTransactionAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
}

export const ReturnedAchTransactionAllOfAttributesDirectionEnum = {
    Credit: 'Credit',
    Debit: 'Debit'
} as const;

export type ReturnedAchTransactionAllOfAttributesDirectionEnum = typeof ReturnedAchTransactionAllOfAttributesDirectionEnum[keyof typeof ReturnedAchTransactionAllOfAttributesDirectionEnum];

/**
 * 
 * @export
 * @interface ReturnedAchTransactionRelationships
 */
export interface ReturnedAchTransactionRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof ReturnedAchTransactionRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof ReturnedAchTransactionRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof ReturnedAchTransactionRelationships
     */
    'customers'?: CustomersRelationship;
    /**
     * 
     * @type {PaymentRelationship}
     * @memberof ReturnedAchTransactionRelationships
     */
    'payment': PaymentRelationship;
}
/**
 * 
 * @export
 * @interface ReturnedCheckDepositTransaction
 */
export interface ReturnedCheckDepositTransaction extends Transaction {
    /**
     * 
     * @type {ReturnedCheckDepositTransactionAllOfAttributes}
     * @memberof ReturnedCheckDepositTransaction
     */
    'attributes': ReturnedCheckDepositTransactionAllOfAttributes;
    /**
     * 
     * @type {ReturnedCheckDepositTransactionRelationships}
     * @memberof ReturnedCheckDepositTransaction
     */
    'relationships': ReturnedCheckDepositTransactionRelationships;
}


/**
 * 
 * @export
 * @interface ReturnedCheckDepositTransactionAllOfAttributes
 */
export interface ReturnedCheckDepositTransactionAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof ReturnedCheckDepositTransactionAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {number}
     * @memberof ReturnedCheckDepositTransactionAllOfAttributes
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof ReturnedCheckDepositTransactionAllOfAttributes
     */
    'direction': ReturnedCheckDepositTransactionAllOfAttributesDirectionEnum;
    /**
     * 
     * @type {number}
     * @memberof ReturnedCheckDepositTransactionAllOfAttributes
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof ReturnedCheckDepositTransactionAllOfAttributes
     */
    'summary': string;
    /**
     * 
     * @type {string}
     * @memberof ReturnedCheckDepositTransactionAllOfAttributes
     */
    'reason'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ReturnedCheckDepositTransactionAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
}

export const ReturnedCheckDepositTransactionAllOfAttributesDirectionEnum = {
    Credit: 'Credit',
    Debit: 'Debit'
} as const;

export type ReturnedCheckDepositTransactionAllOfAttributesDirectionEnum = typeof ReturnedCheckDepositTransactionAllOfAttributesDirectionEnum[keyof typeof ReturnedCheckDepositTransactionAllOfAttributesDirectionEnum];

/**
 * 
 * @export
 * @interface ReturnedCheckDepositTransactionRelationships
 */
export interface ReturnedCheckDepositTransactionRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof ReturnedCheckDepositTransactionRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof ReturnedCheckDepositTransactionRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof ReturnedCheckDepositTransactionRelationships
     */
    'customers'?: CustomersRelationship;
    /**
     * 
     * @type {CheckDepositRelationship}
     * @memberof ReturnedCheckDepositTransactionRelationships
     */
    'checkDeposit': CheckDepositRelationship;
}
/**
 * 
 * @export
 * @interface ReturnedCheckPaymentTransaction
 */
export interface ReturnedCheckPaymentTransaction extends Transaction {
    /**
     * 
     * @type {ReturnedCheckPaymentTransactionAllOfAttributes}
     * @memberof ReturnedCheckPaymentTransaction
     */
    'attributes': ReturnedCheckPaymentTransactionAllOfAttributes;
    /**
     * 
     * @type {ReturnedCheckPaymentTransactionRelationships}
     * @memberof ReturnedCheckPaymentTransaction
     */
    'relationships': ReturnedCheckPaymentTransactionRelationships;
}


/**
 * 
 * @export
 * @interface ReturnedCheckPaymentTransactionAllOfAttributes
 */
export interface ReturnedCheckPaymentTransactionAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof ReturnedCheckPaymentTransactionAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {number}
     * @memberof ReturnedCheckPaymentTransactionAllOfAttributes
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof ReturnedCheckPaymentTransactionAllOfAttributes
     */
    'direction': ReturnedCheckPaymentTransactionAllOfAttributesDirectionEnum;
    /**
     * 
     * @type {number}
     * @memberof ReturnedCheckPaymentTransactionAllOfAttributes
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof ReturnedCheckPaymentTransactionAllOfAttributes
     */
    'summary': string;
    /**
     * 
     * @type {string}
     * @memberof ReturnedCheckPaymentTransactionAllOfAttributes
     */
    'reason': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ReturnedCheckPaymentTransactionAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
}

export const ReturnedCheckPaymentTransactionAllOfAttributesDirectionEnum = {
    Credit: 'Credit',
    Debit: 'Debit'
} as const;

export type ReturnedCheckPaymentTransactionAllOfAttributesDirectionEnum = typeof ReturnedCheckPaymentTransactionAllOfAttributesDirectionEnum[keyof typeof ReturnedCheckPaymentTransactionAllOfAttributesDirectionEnum];

/**
 * 
 * @export
 * @interface ReturnedCheckPaymentTransactionRelationships
 */
export interface ReturnedCheckPaymentTransactionRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof ReturnedCheckPaymentTransactionRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof ReturnedCheckPaymentTransactionRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof ReturnedCheckPaymentTransactionRelationships
     */
    'customers'?: CustomersRelationship;
    /**
     * 
     * @type {CheckPaymentRelationship}
     * @memberof ReturnedCheckPaymentTransactionRelationships
     */
    'checkPayment': CheckPaymentRelationship;
}
/**
 * 
 * @export
 * @interface ReturnedReceivedAchTransaction
 */
export interface ReturnedReceivedAchTransaction extends Transaction {
    /**
     * 
     * @type {ReturnedReceivedAchTransactionAllOfAttributes}
     * @memberof ReturnedReceivedAchTransaction
     */
    'attributes': ReturnedReceivedAchTransactionAllOfAttributes;
    /**
     * 
     * @type {ReturnedReceivedAchTransactionRelationships}
     * @memberof ReturnedReceivedAchTransaction
     */
    'relationships': ReturnedReceivedAchTransactionRelationships;
}


/**
 * 
 * @export
 * @interface ReturnedReceivedAchTransactionAllOfAttributes
 */
export interface ReturnedReceivedAchTransactionAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof ReturnedReceivedAchTransactionAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ReturnedReceivedAchTransactionAllOfAttributes
     */
    'direction': ReturnedReceivedAchTransactionAllOfAttributesDirectionEnum;
    /**
     * 
     * @type {number}
     * @memberof ReturnedReceivedAchTransactionAllOfAttributes
     */
    'amount': number;
    /**
     * 
     * @type {number}
     * @memberof ReturnedReceivedAchTransactionAllOfAttributes
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof ReturnedReceivedAchTransactionAllOfAttributes
     */
    'summary': string;
    /**
     * 
     * @type {string}
     * @memberof ReturnedReceivedAchTransactionAllOfAttributes
     */
    'companyName': string;
    /**
     * 
     * @type {string}
     * @memberof ReturnedReceivedAchTransactionAllOfAttributes
     */
    'reason': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ReturnedReceivedAchTransactionAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
}

export const ReturnedReceivedAchTransactionAllOfAttributesDirectionEnum = {
    Credit: 'Credit',
    Debit: 'Debit'
} as const;

export type ReturnedReceivedAchTransactionAllOfAttributesDirectionEnum = typeof ReturnedReceivedAchTransactionAllOfAttributesDirectionEnum[keyof typeof ReturnedReceivedAchTransactionAllOfAttributesDirectionEnum];

/**
 * 
 * @export
 * @interface ReturnedReceivedAchTransactionRelationships
 */
export interface ReturnedReceivedAchTransactionRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof ReturnedReceivedAchTransactionRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof ReturnedReceivedAchTransactionRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof ReturnedReceivedAchTransactionRelationships
     */
    'customers'?: CustomersRelationship;
    /**
     * 
     * @type {ReturnedTransactionRelationship}
     * @memberof ReturnedReceivedAchTransactionRelationships
     */
    'returned': ReturnedTransactionRelationship;
}
/**
 * 
 * @export
 * @interface ReturnedRelationship
 */
export interface ReturnedRelationship {
    /**
     * 
     * @type {ReturnedTransactionRelationship}
     * @memberof ReturnedRelationship
     */
    'returned'?: ReturnedTransactionRelationship;
}
/**
 * 
 * @export
 * @interface ReturnedTransactionRelationship
 */
export interface ReturnedTransactionRelationship {
    /**
     * 
     * @type {TransactionRelationshipData}
     * @memberof ReturnedTransactionRelationship
     */
    'data': TransactionRelationshipData;
}
/**
 * 
 * @export
 * @interface Reward
 */
export interface Reward {
    /**
     * 
     * @type {string}
     * @memberof Reward
     */
    'type': RewardTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Reward
     */
    'id': string;
    /**
     * 
     * @type {RewardAttributes}
     * @memberof Reward
     */
    'attributes': RewardAttributes;
    /**
     * 
     * @type {RewardRelationships}
     * @memberof Reward
     */
    'relationships': RewardRelationships;
}

export const RewardTypeEnum = {
    Reward: 'reward'
} as const;

export type RewardTypeEnum = typeof RewardTypeEnum[keyof typeof RewardTypeEnum];

/**
 * 
 * @export
 * @interface RewardAttributes
 */
export interface RewardAttributes {
    /**
     * 
     * @type {string}
     * @memberof RewardAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {number}
     * @memberof RewardAttributes
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof RewardAttributes
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof RewardAttributes
     */
    'status': RewardAttributesStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof RewardAttributes
     */
    'rejectReason'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RewardAttributes
     */
    'tags': { [key: string]: string; };
}

export const RewardAttributesStatusEnum = {
    Rejected: 'Rejected',
    Sent: 'Sent'
} as const;

export type RewardAttributesStatusEnum = typeof RewardAttributesStatusEnum[keyof typeof RewardAttributesStatusEnum];

/**
 * 
 * @export
 * @interface RewardRelationship
 */
export interface RewardRelationship {
    /**
     * 
     * @type {RewardRelationshipData}
     * @memberof RewardRelationship
     */
    'data': RewardRelationshipData;
}
/**
 * 
 * @export
 * @interface RewardRelationshipData
 */
export interface RewardRelationshipData {
    /**
     * 
     * @type {string}
     * @memberof RewardRelationshipData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof RewardRelationshipData
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface RewardRelationships
 */
export interface RewardRelationships {
    /**
     * 
     * @type {ReceivingAccountRelationship}
     * @memberof RewardRelationships
     */
    'receivingAccount': ReceivingAccountRelationship;
    /**
     * 
     * @type {FundingAccountRelationship}
     * @memberof RewardRelationships
     */
    'fundingAccount': FundingAccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof RewardRelationships
     */
    'customer': CustomerRelationship;
    /**
     * 
     * @type {RewardedTransactionRelationship}
     * @memberof RewardRelationships
     */
    'rewardedTransaction'?: RewardedTransactionRelationship;
    /**
     * 
     * @type {TransactionRelationship}
     * @memberof RewardRelationships
     */
    'transaction'?: TransactionRelationship;
    /**
     * 
     * @type {CardRelationship}
     * @memberof RewardRelationships
     */
    'card'?: CardRelationship;
}
/**
 * 
 * @export
 * @interface RewardTransaction
 */
export interface RewardTransaction extends Transaction {
    /**
     * 
     * @type {RewardTransactionAllOfAttributes}
     * @memberof RewardTransaction
     */
    'attributes': RewardTransactionAllOfAttributes;
    /**
     * 
     * @type {RewardTransactionRelationships}
     * @memberof RewardTransaction
     */
    'relationships': RewardTransactionRelationships;
}


/**
 * 
 * @export
 * @interface RewardTransactionAllOfAttributes
 */
export interface RewardTransactionAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof RewardTransactionAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof RewardTransactionAllOfAttributes
     */
    'direction': RewardTransactionAllOfAttributesDirectionEnum;
    /**
     * 
     * @type {PaymentCounterparty}
     * @memberof RewardTransactionAllOfAttributes
     */
    'receiverCounterparty': PaymentCounterparty;
    /**
     * 
     * @type {number}
     * @memberof RewardTransactionAllOfAttributes
     */
    'amount': number;
    /**
     * 
     * @type {number}
     * @memberof RewardTransactionAllOfAttributes
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof RewardTransactionAllOfAttributes
     */
    'summary': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RewardTransactionAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
}

export const RewardTransactionAllOfAttributesDirectionEnum = {
    Credit: 'Credit',
    Debit: 'Debit'
} as const;

export type RewardTransactionAllOfAttributesDirectionEnum = typeof RewardTransactionAllOfAttributesDirectionEnum[keyof typeof RewardTransactionAllOfAttributesDirectionEnum];

/**
 * 
 * @export
 * @interface RewardTransactionRelationships
 */
export interface RewardTransactionRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof RewardTransactionRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof RewardTransactionRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof RewardTransactionRelationships
     */
    'customers'?: CustomersRelationship;
    /**
     * 
     * @type {RewardRelationship}
     * @memberof RewardTransactionRelationships
     */
    'reward': RewardRelationship;
    /**
     * 
     * @type {ReceiverAccountRelationship}
     * @memberof RewardTransactionRelationships
     */
    'receiverAccount': ReceiverAccountRelationship;
}
/**
 * 
 * @export
 * @interface RewardedTransactionRelationship
 */
export interface RewardedTransactionRelationship {
    /**
     * 
     * @type {TransactionRelationshipData}
     * @memberof RewardedTransactionRelationship
     */
    'data': TransactionRelationshipData;
}
/**
 * @type Schedule
 * @export
 */
export type Schedule = { interval: 'Monthly' } & MonthlySchedule | { interval: 'Weekly' } & WeeklySchedule;

/**
 * 
 * @export
 * @interface SchemasLimits
 */
export interface SchemasLimits {
    /**
     * 
     * @type {SchemasLimitsData}
     * @memberof SchemasLimits
     */
    'data': SchemasLimitsData;
}
/**
 * 
 * @export
 * @interface SchemasLimitsData
 */
export interface SchemasLimitsData {
    /**
     * 
     * @type {string}
     * @memberof SchemasLimitsData
     */
    'type': SchemasLimitsDataTypeEnum;
    /**
     * 
     * @type {SchemasLimitsDataAttributes}
     * @memberof SchemasLimitsData
     */
    'attributes': SchemasLimitsDataAttributes;
}

export const SchemasLimitsDataTypeEnum = {
    Limits: 'limits'
} as const;

export type SchemasLimitsDataTypeEnum = typeof SchemasLimitsDataTypeEnum[keyof typeof SchemasLimitsDataTypeEnum];

/**
 * 
 * @export
 * @interface SchemasLimitsDataAttributes
 */
export interface SchemasLimitsDataAttributes {
    /**
     * 
     * @type {CardLevelLimits}
     * @memberof SchemasLimitsDataAttributes
     */
    'limits'?: CardLevelLimits;
    /**
     * 
     * @type {CardTotals}
     * @memberof SchemasLimitsDataAttributes
     */
    'dailyTotals': CardTotals;
    /**
     * 
     * @type {CardTotals}
     * @memberof SchemasLimitsDataAttributes
     */
    'monthlyTotals': CardTotals;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SoleProprietorshipAnnualRevenue = {
    UpTo50k: 'UpTo50k',
    Between50kAnd100k: 'Between50kAnd100k',
    Between100kAnd200k: 'Between100kAnd200k',
    Between200kAnd500k: 'Between200kAnd500k',
    Over500k: 'Over500k'
} as const;

export type SoleProprietorshipAnnualRevenue = typeof SoleProprietorshipAnnualRevenue[keyof typeof SoleProprietorshipAnnualRevenue];


/**
 * 
 * @export
 * @enum {string}
 */

export const SoleProprietorshipNumberOfEmployees = {
    One: 'One',
    Between2And5: 'Between2And5',
    Between5And10: 'Between5And10',
    Over10: 'Over10'
} as const;

export type SoleProprietorshipNumberOfEmployees = typeof SoleProprietorshipNumberOfEmployees[keyof typeof SoleProprietorshipNumberOfEmployees];


/**
 * 
 * @export
 * @enum {string}
 */

export const SourceOfIncome = {
    EmploymentOrPayrollIncome: 'EmploymentOrPayrollIncome',
    PartTimeOrContractorIncome: 'PartTimeOrContractorIncome',
    InheritancesAndGifts: 'InheritancesAndGifts',
    PersonalInvestments: 'PersonalInvestments',
    BusinessOwnershipInterests: 'BusinessOwnershipInterests',
    GovernmentBenefits: 'GovernmentBenefits'
} as const;

export type SourceOfIncome = typeof SourceOfIncome[keyof typeof SourceOfIncome];


/**
 * 
 * @export
 * @interface SponsoredInterestTransaction
 */
export interface SponsoredInterestTransaction extends Transaction {
    /**
     * 
     * @type {CheckDepositTransactionAllOfAttributes}
     * @memberof SponsoredInterestTransaction
     */
    'attributes': CheckDepositTransactionAllOfAttributes;
    /**
     * 
     * @type {SponsoredInterestTransaction}
     * @memberof SponsoredInterestTransaction
     */
    'relationships': SponsoredInterestTransaction;
}


/**
 * 
 * @export
 * @interface Statement
 */
export interface Statement {
    /**
     * 
     * @type {string}
     * @memberof Statement
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof Statement
     */
    'id': string;
    /**
     * 
     * @type {StatementAttributes}
     * @memberof Statement
     */
    'attributes': StatementAttributes;
    /**
     * 
     * @type {StatementRelationships}
     * @memberof Statement
     */
    'relationships': StatementRelationships;
}
/**
 * 
 * @export
 * @interface StatementAttributes
 */
export interface StatementAttributes {
    /**
     * 
     * @type {string}
     * @memberof StatementAttributes
     */
    'period'?: string;
}
/**
 * 
 * @export
 * @interface StatementRelationships
 */
export interface StatementRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof StatementRelationships
     */
    'account'?: AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof StatementRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof StatementRelationships
     */
    'customers'?: CustomersRelationship;
}
/**
 * 
 * @export
 * @interface StatusEvent
 */
export interface StatusEvent {
    /**
     * 
     * @type {string}
     * @memberof StatusEvent
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof StatusEvent
     */
    'updatedBy'?: string;
    /**
     * 
     * @type {StatusEventStatus}
     * @memberof StatusEvent
     */
    'status': StatusEventStatus;
}
/**
 * 
 * @export
 * @interface StatusEventStatus
 */
export interface StatusEventStatus {
    /**
     * 
     * @type {CheckDepositStatus}
     * @memberof StatusEventStatus
     */
    'type'?: CheckDepositStatus;
}


/**
 * 
 * @export
 * @interface StopPayment
 */
export interface StopPayment {
    /**
     * 
     * @type {string}
     * @memberof StopPayment
     */
    'type': StopPaymentTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof StopPayment
     */
    'id': string;
}

export const StopPaymentTypeEnum = {
    CheckStopPayment: 'checkStopPayment',
    AchStopPayment: 'achStopPayment'
} as const;

export type StopPaymentTypeEnum = typeof StopPaymentTypeEnum[keyof typeof StopPaymentTypeEnum];

/**
 * 
 * @export
 * @interface StopPaymentListResponse
 */
export interface StopPaymentListResponse {
    /**
     * 
     * @type {Array<StopPayment>}
     * @memberof StopPaymentListResponse
     */
    'data'?: Array<StopPayment>;
}
/**
 * 
 * @export
 * @interface StopPaymentResponse
 */
export interface StopPaymentResponse {
    /**
     * 
     * @type {StopPayment}
     * @memberof StopPaymentResponse
     */
    'data'?: StopPayment;
}
/**
 * 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'type'?: TransactionTypeEnum;
}

export const TransactionTypeEnum = {
    OriginatedAchTransaction: 'originatedAchTransaction',
    ReceivedAchTransaction: 'receivedAchTransaction',
    ReturnedAchTransaction: 'returnedAchTransaction',
    ReturnedReceivedAchTransaction: 'returnedReceivedAchTransaction',
    DishonoredAchTransaction: 'dishonoredAchTransaction',
    PurchaseTransaction: 'purchaseTransaction',
    BookTransaction: 'bookTransaction',
    AtmTransaction: 'atmTransaction',
    FeeTransaction: 'feeTransaction',
    CardTransaction: 'cardTransaction',
    ReleaseTransaction: 'releaseTransaction',
    WireTransaction: 'wireTransaction',
    InterestShareTransaction: 'interestShareTransaction',
    InterestTransaction: 'interestTransaction',
    AdjustmentTransaction: 'adjustmentTransaction',
    DisputeTransaction: 'disputeTransaction',
    CheckDepositTransaction: 'checkDepositTransaction',
    ReturnedCheckDepositTransaction: 'returnedCheckDepositTransaction',
    SponsoredInterestTransaction: 'sponsoredInterestTransaction',
    PaymentAdvanceTransaction: 'paymentAdvanceTransaction',
    RepaidPaymentAdvanceTransaction: 'repaidPaymentAdvanceTransaction',
    ChargebackTransaction: 'chargebackTransaction',
    RewardTransaction: 'rewardTransaction',
    NegativeBalanceCoverageTransaction: 'negativeBalanceCoverageTransaction',
    AccountLowBalanceClosureTransaction: 'accountLowBalanceClosureTransaction',
    BankRepaymentTransaction: 'bankRepaymentTransaction',
    CashDepositTransaction: 'cashDepositTransaction',
    CustomerRepaymentTransaction: 'customerRepaymentTransaction',
    CustomerRepaymentReturnedTransaction: 'customerRepaymentReturnedTransaction',
    CheckPaymentTransaction: 'checkPaymentTransaction',
    ReturnedCheckPaymentTransaction: 'returnedCheckPaymentTransaction',
    CardReversalTransaction: 'cardReversalTransaction',
    FeeReversalTransaction: 'feeReversalTransaction',
    PushToCardReversalTransaction: 'pushToCardReversalTransaction'
} as const;

export type TransactionTypeEnum = typeof TransactionTypeEnum[keyof typeof TransactionTypeEnum];

/**
 * 
 * @export
 * @interface TransactionRelationship
 */
export interface TransactionRelationship {
    /**
     * 
     * @type {TransactionRelationshipData}
     * @memberof TransactionRelationship
     */
    'data': TransactionRelationshipData;
}
/**
 * 
 * @export
 * @interface TransactionRelationshipData
 */
export interface TransactionRelationshipData {
    /**
     * 
     * @type {string}
     * @memberof TransactionRelationshipData
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionRelationshipData
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface UnitAccountResponse
 */
export interface UnitAccountResponse {
    /**
     * 
     * @type {Account}
     * @memberof UnitAccountResponse
     */
    'data'?: Account;
}
/**
 * 
 * @export
 * @interface UnitAccountResponseWithIncluded
 */
export interface UnitAccountResponseWithIncluded {
    /**
     * 
     * @type {Account}
     * @memberof UnitAccountResponseWithIncluded
     */
    'data'?: Account;
    /**
     * 
     * @type {Array<Customer>}
     * @memberof UnitAccountResponseWithIncluded
     */
    'included'?: Array<Customer>;
}
/**
 * 
 * @export
 * @interface UnitAccountsListResponse
 */
export interface UnitAccountsListResponse {
    /**
     * 
     * @type {Array<Account>}
     * @memberof UnitAccountsListResponse
     */
    'data'?: Array<Account>;
    /**
     * 
     * @type {Array<Customer>}
     * @memberof UnitAccountsListResponse
     */
    'included'?: Array<Customer>;
    /**
     * 
     * @type {PaginationMeta}
     * @memberof UnitAccountsListResponse
     */
    'meta'?: PaginationMeta;
}
/**
 * 
 * @export
 * @interface UnitApiTokenResponse
 */
export interface UnitApiTokenResponse {
    /**
     * 
     * @type {ApiToken}
     * @memberof UnitApiTokenResponse
     */
    'data'?: ApiToken;
}
/**
 * 
 * @export
 * @interface UnitApplicationFormResponse
 */
export interface UnitApplicationFormResponse {
    /**
     * 
     * @type {ApplicationForm}
     * @memberof UnitApplicationFormResponse
     */
    'data'?: ApplicationForm;
}
/**
 * 
 * @export
 * @interface UnitApplicationFormResponseWithIncluded
 */
export interface UnitApplicationFormResponseWithIncluded {
    /**
     * 
     * @type {ApplicationForm}
     * @memberof UnitApplicationFormResponseWithIncluded
     */
    'data'?: ApplicationForm;
    /**
     * 
     * @type {Application}
     * @memberof UnitApplicationFormResponseWithIncluded
     */
    'included'?: Application;
}
/**
 * 
 * @export
 * @interface UnitApplicationFormsListResponse
 */
export interface UnitApplicationFormsListResponse {
    /**
     * 
     * @type {Array<ApplicationForm>}
     * @memberof UnitApplicationFormsListResponse
     */
    'data'?: Array<ApplicationForm>;
}
/**
 * 
 * @export
 * @interface UnitApplicationResponseWithIncluded
 */
export interface UnitApplicationResponseWithIncluded {
    /**
     * 
     * @type {Application}
     * @memberof UnitApplicationResponseWithIncluded
     */
    'data'?: Application;
    /**
     * 
     * @type {Array<IncludedResourceInner>}
     * @memberof UnitApplicationResponseWithIncluded
     */
    'included'?: Array<IncludedResourceInner>;
}
/**
 * 
 * @export
 * @interface UnitAuthorizationRequestResponse
 */
export interface UnitAuthorizationRequestResponse {
    /**
     * 
     * @type {AuthorizationRequest}
     * @memberof UnitAuthorizationRequestResponse
     */
    'data'?: AuthorizationRequest;
}
/**
 * 
 * @export
 * @interface UnitAuthorizationRequestsResponse
 */
export interface UnitAuthorizationRequestsResponse {
    /**
     * 
     * @type {AuthorizationRequest}
     * @memberof UnitAuthorizationRequestsResponse
     */
    'data'?: AuthorizationRequest;
}
/**
 * 
 * @export
 * @interface UnitAuthorizationResponse
 */
export interface UnitAuthorizationResponse {
    /**
     * 
     * @type {Authorization}
     * @memberof UnitAuthorizationResponse
     */
    'data'?: Authorization;
}
/**
 * 
 * @export
 * @interface UnitBackCheckDepositResponse
 */
export interface UnitBackCheckDepositResponse {
    /**
     * 
     * @type {string}
     * @memberof UnitBackCheckDepositResponse
     */
    'data'?: string;
}
/**
 * 
 * @export
 * @interface UnitBeneficialOwnerResponse
 */
export interface UnitBeneficialOwnerResponse {
    /**
     * 
     * @type {UnitBeneficialOwnerResponseData}
     * @memberof UnitBeneficialOwnerResponse
     */
    'data': UnitBeneficialOwnerResponseData;
}
/**
 * 
 * @export
 * @interface UnitBeneficialOwnerResponseData
 */
export interface UnitBeneficialOwnerResponseData {
    /**
     * 
     * @type {string}
     * @memberof UnitBeneficialOwnerResponseData
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnitBeneficialOwnerResponseData
     */
    'type'?: UnitBeneficialOwnerResponseDataTypeEnum;
    /**
     * 
     * @type {BeneficialOwner}
     * @memberof UnitBeneficialOwnerResponseData
     */
    'attributes'?: BeneficialOwner;
}

export const UnitBeneficialOwnerResponseDataTypeEnum = {
    BeneficialOwner: 'beneficialOwner'
} as const;

export type UnitBeneficialOwnerResponseDataTypeEnum = typeof UnitBeneficialOwnerResponseDataTypeEnum[keyof typeof UnitBeneficialOwnerResponseDataTypeEnum];

/**
 * 
 * @export
 * @interface UnitCancelApplicationResponse
 */
export interface UnitCancelApplicationResponse {
    /**
     * 
     * @type {Application}
     * @memberof UnitCancelApplicationResponse
     */
    'data'?: Application;
    /**
     * 
     * @type {Array<ApplicationDocument>}
     * @memberof UnitCancelApplicationResponse
     */
    'included'?: Array<ApplicationDocument>;
}
/**
 * 
 * @export
 * @interface UnitCardLimitsResponse
 */
export interface UnitCardLimitsResponse {
    /**
     * 
     * @type {SchemasLimits}
     * @memberof UnitCardLimitsResponse
     */
    'data'?: SchemasLimits;
}
/**
 * 
 * @export
 * @interface UnitCardResponse
 */
export interface UnitCardResponse {
    /**
     * 
     * @type {Card}
     * @memberof UnitCardResponse
     */
    'data'?: Card;
    /**
     * 
     * @type {Array<Array<IncludedResourceInner>>}
     * @memberof UnitCardResponse
     */
    'included'?: Array<Array<IncludedResourceInner>>;
}
/**
 * 
 * @export
 * @interface UnitCardResponseCardsList
 */
export interface UnitCardResponseCardsList {
    /**
     * 
     * @type {Array<Card>}
     * @memberof UnitCardResponseCardsList
     */
    'data'?: Array<Card>;
    /**
     * 
     * @type {Array<Array<IncludedResourceInner>>}
     * @memberof UnitCardResponseCardsList
     */
    'included'?: Array<Array<IncludedResourceInner>>;
}
/**
 * 
 * @export
 * @interface UnitCardsListResponse
 */
export interface UnitCardsListResponse {
    /**
     * 
     * @type {Card}
     * @memberof UnitCardsListResponse
     */
    'data'?: Card;
}
/**
 * 
 * @export
 * @interface UnitCheckDepositResponse
 */
export interface UnitCheckDepositResponse {
    /**
     * 
     * @type {CheckDeposit}
     * @memberof UnitCheckDepositResponse
     */
    'data'?: CheckDeposit;
}
/**
 * 
 * @export
 * @interface UnitCheckPaymentResponse
 */
export interface UnitCheckPaymentResponse {
    /**
     * 
     * @type {CheckPayment}
     * @memberof UnitCheckPaymentResponse
     */
    'data'?: CheckPayment;
}
/**
 * 
 * @export
 * @interface UnitCloseCardResponse
 */
export interface UnitCloseCardResponse {
    /**
     * 
     * @type {Card}
     * @memberof UnitCloseCardResponse
     */
    'data'?: Card;
}
/**
 * 
 * @export
 * @interface UnitConfirmCheckDepositResponse
 */
export interface UnitConfirmCheckDepositResponse {
    /**
     * 
     * @type {CheckDeposit}
     * @memberof UnitConfirmCheckDepositResponse
     */
    'data'?: CheckDeposit;
}
/**
 * 
 * @export
 * @interface UnitCounterpartiesListResponse
 */
export interface UnitCounterpartiesListResponse {
    /**
     * 
     * @type {Counterparty}
     * @memberof UnitCounterpartiesListResponse
     */
    'data'?: Counterparty;
}
/**
 * 
 * @export
 * @interface UnitCounterpartyResponse
 */
export interface UnitCounterpartyResponse {
    /**
     * 
     * @type {Counterparty}
     * @memberof UnitCounterpartyResponse
     */
    'data'?: Counterparty;
}
/**
 * 
 * @export
 * @interface UnitCounterpartyResponse1
 */
export interface UnitCounterpartyResponse1 {
    /**
     * 
     * @type {CounterpartyBalance}
     * @memberof UnitCounterpartyResponse1
     */
    'data'?: CounterpartyBalance;
}
/**
 * 
 * @export
 * @interface UnitCreateApplicationResponse
 */
export interface UnitCreateApplicationResponse {
    /**
     * 
     * @type {Application}
     * @memberof UnitCreateApplicationResponse
     */
    'data'?: Application;
    /**
     * 
     * @type {Array<ApplicationDocument>}
     * @memberof UnitCreateApplicationResponse
     */
    'included'?: Array<ApplicationDocument>;
}
/**
 * 
 * @export
 * @interface UnitCustomerResponse
 */
export interface UnitCustomerResponse {
    /**
     * 
     * @type {Customer}
     * @memberof UnitCustomerResponse
     */
    'data'?: Customer;
}
/**
 * 
 * @export
 * @interface UnitCustomerTokenResponse
 */
export interface UnitCustomerTokenResponse {
    /**
     * 
     * @type {CustomerToken}
     * @memberof UnitCustomerTokenResponse
     */
    'data'?: CustomerToken;
}
/**
 * 
 * @export
 * @interface UnitCustomerTokenVerificationResponse
 */
export interface UnitCustomerTokenVerificationResponse {
    /**
     * 
     * @type {CustomerTokenVerification}
     * @memberof UnitCustomerTokenVerificationResponse
     */
    'data'?: CustomerTokenVerification;
}
/**
 * 
 * @export
 * @interface UnitCustomersListResponse
 */
export interface UnitCustomersListResponse {
    /**
     * 
     * @type {Array<Customer>}
     * @memberof UnitCustomersListResponse
     */
    'data'?: Array<Customer>;
    /**
     * 
     * @type {PaginationMeta}
     * @memberof UnitCustomersListResponse
     */
    'meta'?: PaginationMeta;
}
/**
 * 
 * @export
 * @interface UnitDisputeResponse
 */
export interface UnitDisputeResponse {
    /**
     * 
     * @type {Dispute}
     * @memberof UnitDisputeResponse
     */
    'data'?: Dispute;
}
/**
 * 
 * @export
 * @interface UnitDocumentResponse
 */
export interface UnitDocumentResponse {
    /**
     * 
     * @type {ApplicationDocument}
     * @memberof UnitDocumentResponse
     */
    'data'?: ApplicationDocument;
}
/**
 * 
 * @export
 * @interface UnitErrorInner
 */
export interface UnitErrorInner {
    /**
     * 
     * @type {string}
     * @memberof UnitErrorInner
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnitErrorInner
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnitErrorInner
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnitErrorInner
     */
    'detail'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnitErrorInner
     */
    'details'?: string;
    /**
     * 
     * @type {UnitErrorInnerSource}
     * @memberof UnitErrorInner
     */
    'source'?: UnitErrorInnerSource;
    /**
     * 
     * @type {object}
     * @memberof UnitErrorInner
     */
    'meta'?: object;
}
/**
 * 
 * @export
 * @interface UnitErrorInnerSource
 */
export interface UnitErrorInnerSource {
    /**
     * 
     * @type {string}
     * @memberof UnitErrorInnerSource
     */
    'pointer'?: string;
}
/**
 * 
 * @export
 * @interface UnitEventListResponse
 */
export interface UnitEventListResponse {
    /**
     * 
     * @type {Array<Event>}
     * @memberof UnitEventListResponse
     */
    'data'?: Array<Event>;
}
/**
 * 
 * @export
 * @interface UnitEventResponse
 */
export interface UnitEventResponse {
    /**
     * 
     * @type {Event}
     * @memberof UnitEventResponse
     */
    'data'?: Event;
}
/**
 * 
 * @export
 * @interface UnitFeeResponse
 */
export interface UnitFeeResponse {
    /**
     * 
     * @type {Fee}
     * @memberof UnitFeeResponse
     */
    'data'?: Fee;
}
/**
 * 
 * @export
 * @interface UnitFreezeCardResponse
 */
export interface UnitFreezeCardResponse {
    /**
     * 
     * @type {Card}
     * @memberof UnitFreezeCardResponse
     */
    'data'?: Card;
}
/**
 * 
 * @export
 * @interface UnitFrontCheckDepositResponse
 */
export interface UnitFrontCheckDepositResponse {
    /**
     * 
     * @type {string}
     * @memberof UnitFrontCheckDepositResponse
     */
    'data'?: string;
}
/**
 * 
 * @export
 * @interface UnitGetAccountEndOfDayListResponse
 */
export interface UnitGetAccountEndOfDayListResponse {
    /**
     * 
     * @type {AccountEndOfDay}
     * @memberof UnitGetAccountEndOfDayListResponse
     */
    'data'?: AccountEndOfDay;
}
/**
 * 
 * @export
 * @interface UnitGetAccountLimitsResponse
 */
export interface UnitGetAccountLimitsResponse {
    /**
     * 
     * @type {Limits}
     * @memberof UnitGetAccountLimitsResponse
     */
    'data'?: Limits;
}
/**
 * 
 * @export
 * @interface UnitInstitutionResponse
 */
export interface UnitInstitutionResponse {
    /**
     * 
     * @type {Institution}
     * @memberof UnitInstitutionResponse
     */
    'data'?: Institution;
}
/**
 * 
 * @export
 * @interface UnitListApplicationsResponse
 */
export interface UnitListApplicationsResponse {
    /**
     * 
     * @type {Array<Application>}
     * @memberof UnitListApplicationsResponse
     */
    'data'?: Array<Application>;
    /**
     * 
     * @type {PaginationMeta}
     * @memberof UnitListApplicationsResponse
     */
    'meta'?: PaginationMeta;
}
/**
 * 
 * @export
 * @interface UnitListAuthorizationRequestsResponse
 */
export interface UnitListAuthorizationRequestsResponse {
    /**
     * 
     * @type {Array<AuthorizationRequest>}
     * @memberof UnitListAuthorizationRequestsResponse
     */
    'data'?: Array<AuthorizationRequest>;
}
/**
 * 
 * @export
 * @interface UnitListAuthorizationsResponse
 */
export interface UnitListAuthorizationsResponse {
    /**
     * 
     * @type {Array<Authorization>}
     * @memberof UnitListAuthorizationsResponse
     */
    'data'?: Array<Authorization>;
}
/**
 * 
 * @export
 * @interface UnitListCheckDepositsResponse
 */
export interface UnitListCheckDepositsResponse {
    /**
     * 
     * @type {Array<CheckDeposit>}
     * @memberof UnitListCheckDepositsResponse
     */
    'data'?: Array<CheckDeposit>;
}
/**
 * 
 * @export
 * @interface UnitListCheckDepositsResponse1
 */
export interface UnitListCheckDepositsResponse1 {
    /**
     * 
     * @type {CheckDeposit}
     * @memberof UnitListCheckDepositsResponse1
     */
    'data'?: CheckDeposit;
}
/**
 * 
 * @export
 * @interface UnitListCheckPaymentsResponse
 */
export interface UnitListCheckPaymentsResponse {
    /**
     * 
     * @type {Array<CheckPayment>}
     * @memberof UnitListCheckPaymentsResponse
     */
    'data'?: Array<CheckPayment>;
}
/**
 * 
 * @export
 * @interface UnitListDocumentsResponse
 */
export interface UnitListDocumentsResponse {
    /**
     * 
     * @type {Array<ApplicationDocument>}
     * @memberof UnitListDocumentsResponse
     */
    'data'?: Array<ApplicationDocument>;
}
/**
 * 
 * @export
 * @interface UnitOrgApiTokensListResponse
 */
export interface UnitOrgApiTokensListResponse {
    /**
     * 
     * @type {Array<ApiToken>}
     * @memberof UnitOrgApiTokensListResponse
     */
    'data'?: Array<ApiToken>;
}
/**
 * 
 * @export
 * @interface UnitPaymentResponse
 */
export interface UnitPaymentResponse {
    /**
     * 
     * @type {Payment}
     * @memberof UnitPaymentResponse
     */
    'data'?: Payment;
}
/**
 * 
 * @export
 * @interface UnitPaymentResponseWithIncluded
 */
export interface UnitPaymentResponseWithIncluded {
    /**
     * 
     * @type {Payment}
     * @memberof UnitPaymentResponseWithIncluded
     */
    'data'?: Payment;
    /**
     * 
     * @type {Array<IncludedResourceInner>}
     * @memberof UnitPaymentResponseWithIncluded
     */
    'included'?: Array<IncludedResourceInner>;
}
/**
 * 
 * @export
 * @interface UnitPaymentsListResponse
 */
export interface UnitPaymentsListResponse {
    /**
     * 
     * @type {Array<Payment>}
     * @memberof UnitPaymentsListResponse
     */
    'data'?: Array<Payment>;
    /**
     * 
     * @type {Array<IncludedResourceInner>}
     * @memberof UnitPaymentsListResponse
     */
    'included'?: Array<IncludedResourceInner>;
    /**
     * 
     * @type {PaginationMeta}
     * @memberof UnitPaymentsListResponse
     */
    'meta'?: PaginationMeta;
}
/**
 * 
 * @export
 * @interface UnitPinStatusResponse
 */
export interface UnitPinStatusResponse {
    /**
     * 
     * @type {string}
     * @memberof UnitPinStatusResponse
     */
    'type'?: UnitPinStatusResponseTypeEnum;
    /**
     * 
     * @type {UnitPinStatusResponseAttributes}
     * @memberof UnitPinStatusResponse
     */
    'attributes'?: UnitPinStatusResponseAttributes;
}

export const UnitPinStatusResponseTypeEnum = {
    PinStatus: 'pinStatus'
} as const;

export type UnitPinStatusResponseTypeEnum = typeof UnitPinStatusResponseTypeEnum[keyof typeof UnitPinStatusResponseTypeEnum];

/**
 * 
 * @export
 * @interface UnitPinStatusResponseAttributes
 */
export interface UnitPinStatusResponseAttributes {
    /**
     * 
     * @type {string}
     * @memberof UnitPinStatusResponseAttributes
     */
    'status'?: UnitPinStatusResponseAttributesStatusEnum;
}

export const UnitPinStatusResponseAttributesStatusEnum = {
    Set: 'Set',
    NotSet: 'NotSet'
} as const;

export type UnitPinStatusResponseAttributesStatusEnum = typeof UnitPinStatusResponseAttributesStatusEnum[keyof typeof UnitPinStatusResponseAttributesStatusEnum];

/**
 * 
 * @export
 * @interface UnitReceivedPaymentListResponse
 */
export interface UnitReceivedPaymentListResponse {
    /**
     * 
     * @type {Array<ReceivedPayment>}
     * @memberof UnitReceivedPaymentListResponse
     */
    'data'?: Array<ReceivedPayment>;
    /**
     * 
     * @type {Array<IncludedResourceInner>}
     * @memberof UnitReceivedPaymentListResponse
     */
    'included'?: Array<IncludedResourceInner>;
    /**
     * 
     * @type {PaginationMeta}
     * @memberof UnitReceivedPaymentListResponse
     */
    'meta'?: PaginationMeta;
}
/**
 * 
 * @export
 * @interface UnitReceivedPaymentResponse
 */
export interface UnitReceivedPaymentResponse {
    /**
     * 
     * @type {ReceivedPayment}
     * @memberof UnitReceivedPaymentResponse
     */
    'data'?: ReceivedPayment;
}
/**
 * 
 * @export
 * @interface UnitReceivedPaymentResponseWithIncluded
 */
export interface UnitReceivedPaymentResponseWithIncluded {
    /**
     * 
     * @type {ReceivedPayment}
     * @memberof UnitReceivedPaymentResponseWithIncluded
     */
    'data'?: ReceivedPayment;
    /**
     * 
     * @type {Array<IncludedResourceInner>}
     * @memberof UnitReceivedPaymentResponseWithIncluded
     */
    'included'?: Array<IncludedResourceInner>;
}
/**
 * 
 * @export
 * @interface UnitRecurringPaymentListResponse
 */
export interface UnitRecurringPaymentListResponse {
    /**
     * 
     * @type {Array<RecurringPayment>}
     * @memberof UnitRecurringPaymentListResponse
     */
    'data'?: Array<RecurringPayment>;
    /**
     * 
     * @type {PaginationMeta}
     * @memberof UnitRecurringPaymentListResponse
     */
    'meta'?: PaginationMeta;
}
/**
 * 
 * @export
 * @interface UnitRecurringPaymentResponse
 */
export interface UnitRecurringPaymentResponse {
    /**
     * 
     * @type {RecurringPayment}
     * @memberof UnitRecurringPaymentResponse
     */
    'data'?: RecurringPayment;
}
/**
 * 
 * @export
 * @interface UnitRecurringRepaymentResponse
 */
export interface UnitRecurringRepaymentResponse {
    /**
     * 
     * @type {RecurringRepayment}
     * @memberof UnitRecurringRepaymentResponse
     */
    'data'?: RecurringRepayment;
}
/**
 * 
 * @export
 * @interface UnitRecurringRepaymentsListResponse
 */
export interface UnitRecurringRepaymentsListResponse {
    /**
     * 
     * @type {Array<RecurringRepayment>}
     * @memberof UnitRecurringRepaymentsListResponse
     */
    'data'?: Array<RecurringRepayment>;
    /**
     * 
     * @type {PaginationMeta}
     * @memberof UnitRecurringRepaymentsListResponse
     */
    'meta'?: PaginationMeta;
}
/**
 * 
 * @export
 * @interface UnitRepaymentInformationResponse
 */
export interface UnitRepaymentInformationResponse {
    /**
     * 
     * @type {UnitRepaymentInformationResponseData}
     * @memberof UnitRepaymentInformationResponse
     */
    'data'?: UnitRepaymentInformationResponseData;
}
/**
 * 
 * @export
 * @interface UnitRepaymentInformationResponseData
 */
export interface UnitRepaymentInformationResponseData {
    /**
     * 
     * @type {string}
     * @memberof UnitRepaymentInformationResponseData
     */
    'type': UnitRepaymentInformationResponseDataTypeEnum;
    /**
     * 
     * @type {UnitRepaymentInformationResponseDataAttributes}
     * @memberof UnitRepaymentInformationResponseData
     */
    'attributes': UnitRepaymentInformationResponseDataAttributes;
}

export const UnitRepaymentInformationResponseDataTypeEnum = {
    CreditAccountRepaymentInformation: 'creditAccountRepaymentInformation'
} as const;

export type UnitRepaymentInformationResponseDataTypeEnum = typeof UnitRepaymentInformationResponseDataTypeEnum[keyof typeof UnitRepaymentInformationResponseDataTypeEnum];

/**
 * 
 * @export
 * @interface UnitRepaymentInformationResponseDataAttributes
 */
export interface UnitRepaymentInformationResponseDataAttributes {
    /**
     * 
     * @type {number}
     * @memberof UnitRepaymentInformationResponseDataAttributes
     */
    'remainingAmountDue': number;
    /**
     * 
     * @type {number}
     * @memberof UnitRepaymentInformationResponseDataAttributes
     */
    'remainingAmountOverdue': number;
    /**
     * 
     * @type {number}
     * @memberof UnitRepaymentInformationResponseDataAttributes
     */
    'initiatedRepayments': number;
    /**
     * 
     * @type {string}
     * @memberof UnitRepaymentInformationResponseDataAttributes
     */
    'statementPeriodStart': string;
    /**
     * 
     * @type {string}
     * @memberof UnitRepaymentInformationResponseDataAttributes
     */
    'statementPeriodEnd': string;
    /**
     * 
     * @type {string}
     * @memberof UnitRepaymentInformationResponseDataAttributes
     */
    'nextRepaymentDueDate': string;
}
/**
 * 
 * @export
 * @interface UnitRepaymentResponse
 */
export interface UnitRepaymentResponse {
    /**
     * 
     * @type {Repayment}
     * @memberof UnitRepaymentResponse
     */
    'data'?: Repayment;
}
/**
 * 
 * @export
 * @interface UnitRepaymentsListResponse
 */
export interface UnitRepaymentsListResponse {
    /**
     * 
     * @type {Array<Repayment>}
     * @memberof UnitRepaymentsListResponse
     */
    'data'?: Array<Repayment>;
    /**
     * 
     * @type {PaginationMeta}
     * @memberof UnitRepaymentsListResponse
     */
    'meta'?: PaginationMeta;
}
/**
 * 
 * @export
 * @interface UnitReportLostCardResponse
 */
export interface UnitReportLostCardResponse {
    /**
     * 
     * @type {Card}
     * @memberof UnitReportLostCardResponse
     */
    'data'?: Card;
}
/**
 * 
 * @export
 * @interface UnitReportStolenCardResponse
 */
export interface UnitReportStolenCardResponse {
    /**
     * 
     * @type {Card}
     * @memberof UnitReportStolenCardResponse
     */
    'data'?: Card;
}
/**
 * 
 * @export
 * @interface UnitRewardResponse
 */
export interface UnitRewardResponse {
    /**
     * 
     * @type {Reward}
     * @memberof UnitRewardResponse
     */
    'data'?: Reward;
}
/**
 * 
 * @export
 * @interface UnitRewardsListResponse
 */
export interface UnitRewardsListResponse {
    /**
     * 
     * @type {Array<Reward>}
     * @memberof UnitRewardsListResponse
     */
    'data'?: Array<Reward>;
}
/**
 * 
 * @export
 * @interface UnitStatementsResponse
 */
export interface UnitStatementsResponse {
    /**
     * 
     * @type {Array<Statement>}
     * @memberof UnitStatementsResponse
     */
    'data'?: Array<Statement>;
}
/**
 * 
 * @export
 * @interface UnitTransactionResponse
 */
export interface UnitTransactionResponse {
    /**
     * 
     * @type {Transaction}
     * @memberof UnitTransactionResponse
     */
    'data'?: Transaction;
}
/**
 * 
 * @export
 * @interface UnitTransactionResponseWithIncludedResource
 */
export interface UnitTransactionResponseWithIncludedResource {
    /**
     * 
     * @type {Transaction}
     * @memberof UnitTransactionResponseWithIncludedResource
     */
    'data'?: Transaction;
    /**
     * 
     * @type {Array<IncludedResourceInner>}
     * @memberof UnitTransactionResponseWithIncludedResource
     */
    'included'?: Array<IncludedResourceInner>;
}
/**
 * 
 * @export
 * @interface UnitTransactionsListResponse
 */
export interface UnitTransactionsListResponse {
    /**
     * 
     * @type {Array<Transaction>}
     * @memberof UnitTransactionsListResponse
     */
    'data'?: Array<Transaction>;
    /**
     * 
     * @type {Array<IncludedResourceInner>}
     * @memberof UnitTransactionsListResponse
     */
    'included'?: Array<IncludedResourceInner>;
    /**
     * 
     * @type {PaginationMeta}
     * @memberof UnitTransactionsListResponse
     */
    'meta'?: PaginationMeta;
}
/**
 * 
 * @export
 * @interface UnitUnfreezeCardResponse
 */
export interface UnitUnfreezeCardResponse {
    /**
     * 
     * @type {Card}
     * @memberof UnitUnfreezeCardResponse
     */
    'data'?: Card;
}
/**
 * 
 * @export
 * @interface UnitUpdateCardResponse
 */
export interface UnitUpdateCardResponse {
    /**
     * 
     * @type {Card}
     * @memberof UnitUpdateCardResponse
     */
    'data'?: Card;
}
/**
 * 
 * @export
 * @interface UnitUpdateCheckDepositResponse
 */
export interface UnitUpdateCheckDepositResponse {
    /**
     * 
     * @type {CheckDeposit}
     * @memberof UnitUpdateCheckDepositResponse
     */
    'data'?: CheckDeposit;
}
/**
 * 
 * @export
 * @interface UnitWebhooksListResponse
 */
export interface UnitWebhooksListResponse {
    /**
     * 
     * @type {Array<Webhook>}
     * @memberof UnitWebhooksListResponse
     */
    'data'?: Array<Webhook>;
}
/**
 * 
 * @export
 * @interface UpdateAccountRequest
 */
export interface UpdateAccountRequest {
    /**
     * 
     * @type {UpdateAccountRequestData}
     * @memberof UpdateAccountRequest
     */
    'data': UpdateAccountRequestData;
}
/**
 * @type UpdateAccountRequestData
 * @export
 */
export type UpdateAccountRequestData = UpdateCreditAccount | UpdateDepositAccount;

/**
 * 
 * @export
 * @interface UpdateAchPayment
 */
export interface UpdateAchPayment {
    /**
     * 
     * @type {string}
     * @memberof UpdateAchPayment
     */
    'type': UpdateAchPaymentTypeEnum;
    /**
     * 
     * @type {UpdateAchPaymentAttributes}
     * @memberof UpdateAchPayment
     */
    'attributes': UpdateAchPaymentAttributes;
}

export const UpdateAchPaymentTypeEnum = {
    AchPayment: 'achPayment'
} as const;

export type UpdateAchPaymentTypeEnum = typeof UpdateAchPaymentTypeEnum[keyof typeof UpdateAchPaymentTypeEnum];

/**
 * 
 * @export
 * @interface UpdateAchPaymentAttributes
 */
export interface UpdateAchPaymentAttributes {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UpdateAchPaymentAttributes
     */
    'tags'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface UpdateAchReceivedPayment
 */
export interface UpdateAchReceivedPayment {
    /**
     * 
     * @type {string}
     * @memberof UpdateAchReceivedPayment
     */
    'type': UpdateAchReceivedPaymentTypeEnum;
    /**
     * 
     * @type {UpdateAchPaymentAttributes}
     * @memberof UpdateAchReceivedPayment
     */
    'attributes': UpdateAchPaymentAttributes;
}

export const UpdateAchReceivedPaymentTypeEnum = {
    AchReceivedPayment: 'achReceivedPayment'
} as const;

export type UpdateAchReceivedPaymentTypeEnum = typeof UpdateAchReceivedPaymentTypeEnum[keyof typeof UpdateAchReceivedPaymentTypeEnum];

/**
 * 
 * @export
 * @interface UpdateAchStopPayment
 */
export interface UpdateAchStopPayment {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UpdateAchStopPayment
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof UpdateAchStopPayment
     */
    'expiration'?: string;
}
/**
 * 
 * @export
 * @interface UpdateApplicationRequest
 */
export interface UpdateApplicationRequest {
    /**
     * 
     * @type {UpdateApplicationRequestData}
     * @memberof UpdateApplicationRequest
     */
    'data': UpdateApplicationRequestData;
}
/**
 * @type UpdateApplicationRequestData
 * @export
 */
export type UpdateApplicationRequestData = UpdateBusinessApplication | UpdateBusinessApplicationBeneficialOwner | UpdateBusinessOfficer | UpdateIndividualApplication | UpdateSoleProprietorApplication;

/**
 * 
 * @export
 * @interface UpdateBookPayment
 */
export interface UpdateBookPayment {
    /**
     * 
     * @type {string}
     * @memberof UpdateBookPayment
     */
    'type': UpdateBookPaymentTypeEnum;
    /**
     * 
     * @type {UpdateAchPaymentAttributes}
     * @memberof UpdateBookPayment
     */
    'attributes': UpdateAchPaymentAttributes;
}

export const UpdateBookPaymentTypeEnum = {
    BookPayment: 'bookPayment'
} as const;

export type UpdateBookPaymentTypeEnum = typeof UpdateBookPaymentTypeEnum[keyof typeof UpdateBookPaymentTypeEnum];

/**
 * 
 * @export
 * @interface UpdateBookTransaction
 */
export interface UpdateBookTransaction {
    /**
     * 
     * @type {string}
     * @memberof UpdateBookTransaction
     */
    'type': UpdateBookTransactionTypeEnum;
    /**
     * 
     * @type {UpdateBookTransactionAttributes}
     * @memberof UpdateBookTransaction
     */
    'attributes': UpdateBookTransactionAttributes;
    /**
     * 
     * @type {UpdateTransactionRelationships}
     * @memberof UpdateBookTransaction
     */
    'relationships'?: UpdateTransactionRelationships;
}

export const UpdateBookTransactionTypeEnum = {
    BookTransaction: 'bookTransaction'
} as const;

export type UpdateBookTransactionTypeEnum = typeof UpdateBookTransactionTypeEnum[keyof typeof UpdateBookTransactionTypeEnum];

/**
 * 
 * @export
 * @interface UpdateBookTransactionAttributes
 */
export interface UpdateBookTransactionAttributes {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UpdateBookTransactionAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof UpdateBookTransactionAttributes
     */
    'summary'?: string;
}
/**
 * 
 * @export
 * @interface UpdateBusinessApplication
 */
export interface UpdateBusinessApplication {
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessApplication
     */
    'type': UpdateBusinessApplicationTypeEnum;
    /**
     * 
     * @type {UpdateBusinessApplicationAttributes}
     * @memberof UpdateBusinessApplication
     */
    'attributes': UpdateBusinessApplicationAttributes;
}

export const UpdateBusinessApplicationTypeEnum = {
    BusinessApplication: 'businessApplication'
} as const;

export type UpdateBusinessApplicationTypeEnum = typeof UpdateBusinessApplicationTypeEnum[keyof typeof UpdateBusinessApplicationTypeEnum];

/**
 * 
 * @export
 * @interface UpdateBusinessApplicationAttributes
 */
export interface UpdateBusinessApplicationAttributes {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UpdateBusinessApplicationAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {BusinessAnnualRevenue}
     * @memberof UpdateBusinessApplicationAttributes
     */
    'annualRevenue'?: BusinessAnnualRevenue;
    /**
     * 
     * @type {BusinessNumberOfEmployees}
     * @memberof UpdateBusinessApplicationAttributes
     */
    'numberOfEmployees'?: BusinessNumberOfEmployees;
    /**
     * 
     * @type {CashFlow}
     * @memberof UpdateBusinessApplicationAttributes
     */
    'cashFlow'?: CashFlow;
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessApplicationAttributes
     */
    'yearOfIncorporation'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateBusinessApplicationAttributes
     */
    'countriesOfOperation'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessApplicationAttributes
     */
    'stockSymbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessApplicationAttributes
     */
    'website'?: string;
    /**
     * 
     * @type {BusinessVertical}
     * @memberof UpdateBusinessApplicationAttributes
     */
    'businessVertical'?: BusinessVertical;
}


/**
 * 
 * @export
 * @interface UpdateBusinessApplicationBeneficialOwner
 */
export interface UpdateBusinessApplicationBeneficialOwner {
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessApplicationBeneficialOwner
     */
    'type': UpdateBusinessApplicationBeneficialOwnerTypeEnum;
    /**
     * 
     * @type {UpdateBusinessApplicationBeneficialOwnerAttributes}
     * @memberof UpdateBusinessApplicationBeneficialOwner
     */
    'attributes': UpdateBusinessApplicationBeneficialOwnerAttributes;
}

export const UpdateBusinessApplicationBeneficialOwnerTypeEnum = {
    BeneficialOwner: 'beneficialOwner'
} as const;

export type UpdateBusinessApplicationBeneficialOwnerTypeEnum = typeof UpdateBusinessApplicationBeneficialOwnerTypeEnum[keyof typeof UpdateBusinessApplicationBeneficialOwnerTypeEnum];

/**
 * 
 * @export
 * @interface UpdateBusinessApplicationBeneficialOwnerAttributes
 */
export interface UpdateBusinessApplicationBeneficialOwnerAttributes {
    /**
     * 
     * @type {Occupation}
     * @memberof UpdateBusinessApplicationBeneficialOwnerAttributes
     */
    'occupation'?: Occupation;
    /**
     * 
     * @type {AnnualIncome}
     * @memberof UpdateBusinessApplicationBeneficialOwnerAttributes
     */
    'annualIncome'?: AnnualIncome;
    /**
     * 
     * @type {SourceOfIncome}
     * @memberof UpdateBusinessApplicationBeneficialOwnerAttributes
     */
    'sourceOfIncome'?: SourceOfIncome;
    /**
     * 
     * @type {ApplicationRelationship}
     * @memberof UpdateBusinessApplicationBeneficialOwnerAttributes
     */
    'relationships'?: ApplicationRelationship;
}


/**
 * 
 * @export
 * @interface UpdateBusinessBeneficialOwner
 */
export interface UpdateBusinessBeneficialOwner {
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessBeneficialOwner
     */
    'type': UpdateBusinessBeneficialOwnerTypeEnum;
    /**
     * 
     * @type {UpdateBusinessBeneficialOwnerAttributes}
     * @memberof UpdateBusinessBeneficialOwner
     */
    'attributes': UpdateBusinessBeneficialOwnerAttributes;
    /**
     * 
     * @type {UpdateBusinessBeneficialOwnerRelationships}
     * @memberof UpdateBusinessBeneficialOwner
     */
    'relationships': UpdateBusinessBeneficialOwnerRelationships;
}

export const UpdateBusinessBeneficialOwnerTypeEnum = {
    BeneficialOwner: 'beneficialOwner'
} as const;

export type UpdateBusinessBeneficialOwnerTypeEnum = typeof UpdateBusinessBeneficialOwnerTypeEnum[keyof typeof UpdateBusinessBeneficialOwnerTypeEnum];

/**
 * 
 * @export
 * @interface UpdateBusinessBeneficialOwnerAttributes
 */
export interface UpdateBusinessBeneficialOwnerAttributes {
    /**
     * 
     * @type {Occupation}
     * @memberof UpdateBusinessBeneficialOwnerAttributes
     */
    'occupation'?: Occupation;
    /**
     * 
     * @type {AnnualIncome}
     * @memberof UpdateBusinessBeneficialOwnerAttributes
     */
    'annualIncome'?: AnnualIncome;
    /**
     * 
     * @type {SourceOfIncome}
     * @memberof UpdateBusinessBeneficialOwnerAttributes
     */
    'sourceOfIncome'?: SourceOfIncome;
}


/**
 * 
 * @export
 * @interface UpdateBusinessBeneficialOwnerRelationships
 */
export interface UpdateBusinessBeneficialOwnerRelationships {
    /**
     * 
     * @type {ApplicationRelationship}
     * @memberof UpdateBusinessBeneficialOwnerRelationships
     */
    'application': ApplicationRelationship;
}
/**
 * 
 * @export
 * @interface UpdateBusinessBeneficialOwnerRequest
 */
export interface UpdateBusinessBeneficialOwnerRequest {
    /**
     * 
     * @type {UpdateBusinessBeneficialOwnerRequestData}
     * @memberof UpdateBusinessBeneficialOwnerRequest
     */
    'data': UpdateBusinessBeneficialOwnerRequestData;
}
/**
 * @type UpdateBusinessBeneficialOwnerRequestData
 * @export
 */
export type UpdateBusinessBeneficialOwnerRequestData = UpdateBusinessBeneficialOwner;

/**
 * 
 * @export
 * @interface UpdateBusinessCreditCard
 */
export interface UpdateBusinessCreditCard {
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessCreditCard
     */
    'type': UpdateBusinessCreditCardTypeEnum;
    /**
     * 
     * @type {UpdateBusinessDebitCardAttributes}
     * @memberof UpdateBusinessCreditCard
     */
    'attributes': UpdateBusinessDebitCardAttributes;
}

export const UpdateBusinessCreditCardTypeEnum = {
    BusinessCreditCard: 'businessCreditCard'
} as const;

export type UpdateBusinessCreditCardTypeEnum = typeof UpdateBusinessCreditCardTypeEnum[keyof typeof UpdateBusinessCreditCardTypeEnum];

/**
 * 
 * @export
 * @interface UpdateBusinessCustomer
 */
export interface UpdateBusinessCustomer {
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessCustomer
     */
    'type'?: UpdateBusinessCustomerTypeEnum;
    /**
     * 
     * @type {UpdateBusinessCustomerAttributes}
     * @memberof UpdateBusinessCustomer
     */
    'attributes'?: UpdateBusinessCustomerAttributes;
}

export const UpdateBusinessCustomerTypeEnum = {
    BusinessCustomer: 'businessCustomer'
} as const;

export type UpdateBusinessCustomerTypeEnum = typeof UpdateBusinessCustomerTypeEnum[keyof typeof UpdateBusinessCustomerTypeEnum];

/**
 * 
 * @export
 * @interface UpdateBusinessCustomerAttributes
 */
export interface UpdateBusinessCustomerAttributes {
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessCustomerAttributes
     */
    'dba'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessCustomerAttributes
     */
    'ein'?: string;
    /**
     * 
     * @type {Phone}
     * @memberof UpdateBusinessCustomerAttributes
     */
    'phone'?: Phone;
    /**
     * 
     * @type {Address}
     * @memberof UpdateBusinessCustomerAttributes
     */
    'address'?: Address;
    /**
     * 
     * @type {ResponseContact}
     * @memberof UpdateBusinessCustomerAttributes
     */
    'contact'?: ResponseContact;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UpdateBusinessCustomerAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<AuthorizedUser>}
     * @memberof UpdateBusinessCustomerAttributes
     */
    'authorizedUsers'?: Array<AuthorizedUser> | null;
}
/**
 * 
 * @export
 * @interface UpdateBusinessDebitCard
 */
export interface UpdateBusinessDebitCard {
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessDebitCard
     */
    'type': UpdateBusinessDebitCardTypeEnum;
    /**
     * 
     * @type {UpdateBusinessDebitCardAttributes}
     * @memberof UpdateBusinessDebitCard
     */
    'attributes': UpdateBusinessDebitCardAttributes;
}

export const UpdateBusinessDebitCardTypeEnum = {
    BusinessDebitCard: 'businessDebitCard'
} as const;

export type UpdateBusinessDebitCardTypeEnum = typeof UpdateBusinessDebitCardTypeEnum[keyof typeof UpdateBusinessDebitCardTypeEnum];

/**
 * 
 * @export
 * @interface UpdateBusinessDebitCardAttributes
 */
export interface UpdateBusinessDebitCardAttributes {
    /**
     * 
     * @type {Address}
     * @memberof UpdateBusinessDebitCardAttributes
     */
    'shippingAddress'?: Address;
    /**
     * 
     * @type {Address}
     * @memberof UpdateBusinessDebitCardAttributes
     */
    'address'?: Address;
    /**
     * 
     * @type {Phone}
     * @memberof UpdateBusinessDebitCardAttributes
     */
    'phone'?: Phone;
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessDebitCardAttributes
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessDebitCardAttributes
     */
    'design'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UpdateBusinessDebitCardAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {CardLevelLimits}
     * @memberof UpdateBusinessDebitCardAttributes
     */
    'limits'?: CardLevelLimits;
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessDebitCardAttributes
     */
    'defaultFundingAccountId'?: string;
}
/**
 * 
 * @export
 * @interface UpdateBusinessOfficer
 */
export interface UpdateBusinessOfficer {
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessOfficer
     */
    'type': UpdateBusinessOfficerTypeEnum;
    /**
     * 
     * @type {UpdateBusinessOfficerAttributes}
     * @memberof UpdateBusinessOfficer
     */
    'attributes': UpdateBusinessOfficerAttributes;
}

export const UpdateBusinessOfficerTypeEnum = {
    BusinessApplication: 'businessApplication'
} as const;

export type UpdateBusinessOfficerTypeEnum = typeof UpdateBusinessOfficerTypeEnum[keyof typeof UpdateBusinessOfficerTypeEnum];

/**
 * 
 * @export
 * @interface UpdateBusinessOfficerAttributes
 */
export interface UpdateBusinessOfficerAttributes {
    /**
     * 
     * @type {BusinessOfficer}
     * @memberof UpdateBusinessOfficerAttributes
     */
    'officer'?: BusinessOfficer;
}
/**
 * 
 * @export
 * @interface UpdateBusinessVirtualCreditCard
 */
export interface UpdateBusinessVirtualCreditCard {
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessVirtualCreditCard
     */
    'type': UpdateBusinessVirtualCreditCardTypeEnum;
    /**
     * 
     * @type {UpdateBusinessVirtualDebitCardAttributes}
     * @memberof UpdateBusinessVirtualCreditCard
     */
    'attributes': UpdateBusinessVirtualDebitCardAttributes;
}

export const UpdateBusinessVirtualCreditCardTypeEnum = {
    BusinessVirtualCreditCard: 'businessVirtualCreditCard'
} as const;

export type UpdateBusinessVirtualCreditCardTypeEnum = typeof UpdateBusinessVirtualCreditCardTypeEnum[keyof typeof UpdateBusinessVirtualCreditCardTypeEnum];

/**
 * 
 * @export
 * @interface UpdateBusinessVirtualDebitCard
 */
export interface UpdateBusinessVirtualDebitCard {
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessVirtualDebitCard
     */
    'type': UpdateBusinessVirtualDebitCardTypeEnum;
    /**
     * 
     * @type {UpdateBusinessVirtualDebitCardAttributes}
     * @memberof UpdateBusinessVirtualDebitCard
     */
    'attributes': UpdateBusinessVirtualDebitCardAttributes;
}

export const UpdateBusinessVirtualDebitCardTypeEnum = {
    BusinessVirtualDebitCard: 'businessVirtualDebitCard'
} as const;

export type UpdateBusinessVirtualDebitCardTypeEnum = typeof UpdateBusinessVirtualDebitCardTypeEnum[keyof typeof UpdateBusinessVirtualDebitCardTypeEnum];

/**
 * 
 * @export
 * @interface UpdateBusinessVirtualDebitCardAttributes
 */
export interface UpdateBusinessVirtualDebitCardAttributes {
    /**
     * 
     * @type {Address}
     * @memberof UpdateBusinessVirtualDebitCardAttributes
     */
    'address'?: Address;
    /**
     * 
     * @type {Phone}
     * @memberof UpdateBusinessVirtualDebitCardAttributes
     */
    'phone'?: Phone;
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessVirtualDebitCardAttributes
     */
    'email'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UpdateBusinessVirtualDebitCardAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {CardLevelLimits}
     * @memberof UpdateBusinessVirtualDebitCardAttributes
     */
    'limits'?: CardLevelLimits;
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessVirtualDebitCardAttributes
     */
    'defaultFundingAccountId'?: string;
}
/**
 * 
 * @export
 * @interface UpdateCardRequest
 */
export interface UpdateCardRequest {
    /**
     * 
     * @type {UpdateCardRequestData}
     * @memberof UpdateCardRequest
     */
    'data': UpdateCardRequestData;
}
/**
 * @type UpdateCardRequestData
 * @export
 */
export type UpdateCardRequestData = UpdateBusinessCreditCard | UpdateBusinessDebitCard | UpdateBusinessVirtualCreditCard | UpdateBusinessVirtualDebitCard | UpdateIndividualDebitCard | UpdateIndividualVirtualDebitCard;

/**
 * 
 * @export
 * @interface UpdateChargebackTransaction
 */
export interface UpdateChargebackTransaction {
    /**
     * 
     * @type {string}
     * @memberof UpdateChargebackTransaction
     */
    'type': UpdateChargebackTransactionTypeEnum;
    /**
     * 
     * @type {UpdateBookTransactionAttributes}
     * @memberof UpdateChargebackTransaction
     */
    'attributes': UpdateBookTransactionAttributes;
    /**
     * 
     * @type {UpdateTransactionRelationships}
     * @memberof UpdateChargebackTransaction
     */
    'relationships'?: UpdateTransactionRelationships;
}

export const UpdateChargebackTransactionTypeEnum = {
    ChargebackTransaction: 'chargebackTransaction'
} as const;

export type UpdateChargebackTransactionTypeEnum = typeof UpdateChargebackTransactionTypeEnum[keyof typeof UpdateChargebackTransactionTypeEnum];

/**
 * 
 * @export
 * @interface UpdateCheckDeposit
 */
export interface UpdateCheckDeposit {
    /**
     * 
     * @type {string}
     * @memberof UpdateCheckDeposit
     */
    'type': UpdateCheckDepositTypeEnum;
    /**
     * 
     * @type {UpdateCheckDepositAttributes}
     * @memberof UpdateCheckDeposit
     */
    'attributes': UpdateCheckDepositAttributes;
}

export const UpdateCheckDepositTypeEnum = {
    CheckDeposit: 'checkDeposit'
} as const;

export type UpdateCheckDepositTypeEnum = typeof UpdateCheckDepositTypeEnum[keyof typeof UpdateCheckDepositTypeEnum];

/**
 * 
 * @export
 * @interface UpdateCheckDepositAttributes
 */
export interface UpdateCheckDepositAttributes {
    /**
     * 
     * @type {number}
     * @memberof UpdateCheckDepositAttributes
     */
    'amount'?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UpdateCheckDepositAttributes
     */
    'tags'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface UpdateCheckDepositRequest
 */
export interface UpdateCheckDepositRequest {
    /**
     * 
     * @type {UpdateCheckDeposit}
     * @memberof UpdateCheckDepositRequest
     */
    'data': UpdateCheckDeposit;
}
/**
 * 
 * @export
 * @interface UpdateCounterparty
 */
export interface UpdateCounterparty {
    /**
     * 
     * @type {string}
     * @memberof UpdateCounterparty
     */
    'type': string;
    /**
     * 
     * @type {UpdateCounterpartyAttributes}
     * @memberof UpdateCounterparty
     */
    'attributes': UpdateCounterpartyAttributes;
}
/**
 * 
 * @export
 * @interface UpdateCounterpartyAttributes
 */
export interface UpdateCounterpartyAttributes {
    /**
     * 
     * @type {string}
     * @memberof UpdateCounterpartyAttributes
     */
    'plaidProcessorToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCounterpartyAttributes
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCounterpartyAttributes
     */
    'permissions'?: UpdateCounterpartyAttributesPermissionsEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateCounterpartyAttributes
     */
    'verifyName'?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UpdateCounterpartyAttributes
     */
    'tags'?: { [key: string]: string; };
}

export const UpdateCounterpartyAttributesPermissionsEnum = {
    CreditOnly: 'CreditOnly',
    DebitOnly: 'DebitOnly',
    CreditAndDebit: 'CreditAndDebit'
} as const;

export type UpdateCounterpartyAttributesPermissionsEnum = typeof UpdateCounterpartyAttributesPermissionsEnum[keyof typeof UpdateCounterpartyAttributesPermissionsEnum];

/**
 * 
 * @export
 * @interface UpdateCounterpartyRequest
 */
export interface UpdateCounterpartyRequest {
    /**
     * 
     * @type {UpdateCounterpartyRequestData}
     * @memberof UpdateCounterpartyRequest
     */
    'data': UpdateCounterpartyRequestData;
}
/**
 * @type UpdateCounterpartyRequestData
 * @export
 */
export type UpdateCounterpartyRequestData = UpdateCounterparty;

/**
 * 
 * @export
 * @interface UpdateCreditAccount
 */
export interface UpdateCreditAccount {
    /**
     * 
     * @type {string}
     * @memberof UpdateCreditAccount
     */
    'type': UpdateCreditAccountTypeEnum;
    /**
     * 
     * @type {UpdateCreditAccountAttributes}
     * @memberof UpdateCreditAccount
     */
    'attributes': UpdateCreditAccountAttributes;
}

export const UpdateCreditAccountTypeEnum = {
    CreditAccount: 'creditAccount'
} as const;

export type UpdateCreditAccountTypeEnum = typeof UpdateCreditAccountTypeEnum[keyof typeof UpdateCreditAccountTypeEnum];

/**
 * 
 * @export
 * @interface UpdateCreditAccountAttributes
 */
export interface UpdateCreditAccountAttributes {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UpdateCreditAccountAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof UpdateCreditAccountAttributes
     */
    'creditLimit'?: number;
}
/**
 * 
 * @export
 * @interface UpdateCustomerRequest
 */
export interface UpdateCustomerRequest {
    /**
     * 
     * @type {UpdateCustomerRequestData}
     * @memberof UpdateCustomerRequest
     */
    'data'?: UpdateCustomerRequestData;
}
/**
 * @type UpdateCustomerRequestData
 * @export
 */
export type UpdateCustomerRequestData = UpdateBusinessCustomer | UpdateIndividualCustomer;

/**
 * 
 * @export
 * @interface UpdateDepositAccount
 */
export interface UpdateDepositAccount {
    /**
     * 
     * @type {string}
     * @memberof UpdateDepositAccount
     */
    'type': UpdateDepositAccountTypeEnum;
    /**
     * 
     * @type {UpdateDepositAccountAttributes}
     * @memberof UpdateDepositAccount
     */
    'attributes': UpdateDepositAccountAttributes;
}

export const UpdateDepositAccountTypeEnum = {
    DepositAccount: 'depositAccount'
} as const;

export type UpdateDepositAccountTypeEnum = typeof UpdateDepositAccountTypeEnum[keyof typeof UpdateDepositAccountTypeEnum];

/**
 * 
 * @export
 * @interface UpdateDepositAccountAttributes
 */
export interface UpdateDepositAccountAttributes {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UpdateDepositAccountAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof UpdateDepositAccountAttributes
     */
    'depositProduct'?: string;
}
/**
 * 
 * @export
 * @interface UpdateIndividualApplication
 */
export interface UpdateIndividualApplication {
    /**
     * 
     * @type {string}
     * @memberof UpdateIndividualApplication
     */
    'type': UpdateIndividualApplicationTypeEnum;
    /**
     * 
     * @type {UpdateIndividualApplicationAttributes}
     * @memberof UpdateIndividualApplication
     */
    'attributes': UpdateIndividualApplicationAttributes;
}

export const UpdateIndividualApplicationTypeEnum = {
    IndividualApplication: 'individualApplication'
} as const;

export type UpdateIndividualApplicationTypeEnum = typeof UpdateIndividualApplicationTypeEnum[keyof typeof UpdateIndividualApplicationTypeEnum];

/**
 * 
 * @export
 * @interface UpdateIndividualApplicationAttributes
 */
export interface UpdateIndividualApplicationAttributes {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UpdateIndividualApplicationAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {Occupation}
     * @memberof UpdateIndividualApplicationAttributes
     */
    'occupation'?: Occupation;
    /**
     * 
     * @type {AnnualIncome}
     * @memberof UpdateIndividualApplicationAttributes
     */
    'annualIncome'?: AnnualIncome;
    /**
     * 
     * @type {SourceOfIncome}
     * @memberof UpdateIndividualApplicationAttributes
     */
    'sourceOfIncome'?: SourceOfIncome;
}


/**
 * 
 * @export
 * @interface UpdateIndividualCustomer
 */
export interface UpdateIndividualCustomer {
    /**
     * 
     * @type {string}
     * @memberof UpdateIndividualCustomer
     */
    'type'?: UpdateIndividualCustomerTypeEnum;
    /**
     * 
     * @type {UpdateIndividualCustomerAttributes}
     * @memberof UpdateIndividualCustomer
     */
    'attributes'?: UpdateIndividualCustomerAttributes;
}

export const UpdateIndividualCustomerTypeEnum = {
    IndividualCustomer: 'individualCustomer'
} as const;

export type UpdateIndividualCustomerTypeEnum = typeof UpdateIndividualCustomerTypeEnum[keyof typeof UpdateIndividualCustomerTypeEnum];

/**
 * 
 * @export
 * @interface UpdateIndividualCustomerAttributes
 */
export interface UpdateIndividualCustomerAttributes {
    /**
     * 
     * @type {string}
     * @memberof UpdateIndividualCustomerAttributes
     */
    'email'?: string;
    /**
     * 
     * @type {Phone}
     * @memberof UpdateIndividualCustomerAttributes
     */
    'phone'?: Phone;
    /**
     * 
     * @type {Address}
     * @memberof UpdateIndividualCustomerAttributes
     */
    'address'?: Address;
    /**
     * 
     * @type {string}
     * @memberof UpdateIndividualCustomerAttributes
     */
    'dba'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UpdateIndividualCustomerAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<AuthorizedUser>}
     * @memberof UpdateIndividualCustomerAttributes
     */
    'authorizedUsers'?: Array<AuthorizedUser> | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateIndividualCustomerAttributes
     */
    'jwtSubject'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateIndividualDebitCard
 */
export interface UpdateIndividualDebitCard {
    /**
     * 
     * @type {string}
     * @memberof UpdateIndividualDebitCard
     */
    'type': UpdateIndividualDebitCardTypeEnum;
    /**
     * 
     * @type {UpdateIndividualDebitCardAttributes}
     * @memberof UpdateIndividualDebitCard
     */
    'attributes': UpdateIndividualDebitCardAttributes;
}

export const UpdateIndividualDebitCardTypeEnum = {
    IndividualDebitCard: 'individualDebitCard'
} as const;

export type UpdateIndividualDebitCardTypeEnum = typeof UpdateIndividualDebitCardTypeEnum[keyof typeof UpdateIndividualDebitCardTypeEnum];

/**
 * 
 * @export
 * @interface UpdateIndividualDebitCardAttributes
 */
export interface UpdateIndividualDebitCardAttributes {
    /**
     * 
     * @type {Address}
     * @memberof UpdateIndividualDebitCardAttributes
     */
    'shippingAddress'?: Address;
    /**
     * 
     * @type {string}
     * @memberof UpdateIndividualDebitCardAttributes
     */
    'design'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UpdateIndividualDebitCardAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {CardLevelLimits}
     * @memberof UpdateIndividualDebitCardAttributes
     */
    'limits'?: CardLevelLimits;
    /**
     * 
     * @type {string}
     * @memberof UpdateIndividualDebitCardAttributes
     */
    'defaultFundingAccountId'?: string;
}
/**
 * 
 * @export
 * @interface UpdateIndividualVirtualDebitCard
 */
export interface UpdateIndividualVirtualDebitCard {
    /**
     * 
     * @type {string}
     * @memberof UpdateIndividualVirtualDebitCard
     */
    'type': UpdateIndividualVirtualDebitCardTypeEnum;
    /**
     * 
     * @type {UpdateIndividualVirtualDebitCardAttributes}
     * @memberof UpdateIndividualVirtualDebitCard
     */
    'attributes': UpdateIndividualVirtualDebitCardAttributes;
}

export const UpdateIndividualVirtualDebitCardTypeEnum = {
    IndividualVirtualDebitCard: 'individualVirtualDebitCard'
} as const;

export type UpdateIndividualVirtualDebitCardTypeEnum = typeof UpdateIndividualVirtualDebitCardTypeEnum[keyof typeof UpdateIndividualVirtualDebitCardTypeEnum];

/**
 * 
 * @export
 * @interface UpdateIndividualVirtualDebitCardAttributes
 */
export interface UpdateIndividualVirtualDebitCardAttributes {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UpdateIndividualVirtualDebitCardAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {CardLevelLimits}
     * @memberof UpdateIndividualVirtualDebitCardAttributes
     */
    'limits'?: CardLevelLimits;
    /**
     * 
     * @type {string}
     * @memberof UpdateIndividualVirtualDebitCardAttributes
     */
    'defaultFundingAccountId'?: string;
}
/**
 * 
 * @export
 * @interface UpdatePaymentRequest
 */
export interface UpdatePaymentRequest {
    /**
     * 
     * @type {UpdatePaymentRequestData}
     * @memberof UpdatePaymentRequest
     */
    'data': UpdatePaymentRequestData;
}
/**
 * @type UpdatePaymentRequestData
 * @export
 */
export type UpdatePaymentRequestData = UpdateAchPayment | UpdateBookPayment;

/**
 * 
 * @export
 * @interface UpdateReceivedPaymentRequest
 */
export interface UpdateReceivedPaymentRequest {
    /**
     * 
     * @type {UpdateReceivedPaymentRequestData}
     * @memberof UpdateReceivedPaymentRequest
     */
    'data': UpdateReceivedPaymentRequestData;
}
/**
 * @type UpdateReceivedPaymentRequestData
 * @export
 */
export type UpdateReceivedPaymentRequestData = UpdateAchReceivedPayment;

/**
 * 
 * @export
 * @interface UpdateSoleProprietorApplication
 */
export interface UpdateSoleProprietorApplication {
    /**
     * 
     * @type {string}
     * @memberof UpdateSoleProprietorApplication
     */
    'type': UpdateSoleProprietorApplicationTypeEnum;
    /**
     * 
     * @type {UpdateSoleProprietorApplicationAttributes}
     * @memberof UpdateSoleProprietorApplication
     */
    'attributes': UpdateSoleProprietorApplicationAttributes;
}

export const UpdateSoleProprietorApplicationTypeEnum = {
    IndividualApplication: 'individualApplication'
} as const;

export type UpdateSoleProprietorApplicationTypeEnum = typeof UpdateSoleProprietorApplicationTypeEnum[keyof typeof UpdateSoleProprietorApplicationTypeEnum];

/**
 * 
 * @export
 * @interface UpdateSoleProprietorApplicationAttributes
 */
export interface UpdateSoleProprietorApplicationAttributes {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UpdateSoleProprietorApplicationAttributes
     */
    'tags'?: { [key: string]: string; };
    /**
     * 
     * @type {SoleProprietorshipAnnualRevenue}
     * @memberof UpdateSoleProprietorApplicationAttributes
     */
    'annualRevenue'?: SoleProprietorshipAnnualRevenue;
    /**
     * 
     * @type {SoleProprietorshipNumberOfEmployees}
     * @memberof UpdateSoleProprietorApplicationAttributes
     */
    'numberOfEmployees'?: SoleProprietorshipNumberOfEmployees;
    /**
     * 
     * @type {BusinessVertical}
     * @memberof UpdateSoleProprietorApplicationAttributes
     */
    'businessVertical'?: BusinessVertical;
    /**
     * 
     * @type {string}
     * @memberof UpdateSoleProprietorApplicationAttributes
     */
    'website'?: string;
}


/**
 * 
 * @export
 * @interface UpdateStopPaymentRequest
 */
export interface UpdateStopPaymentRequest {
    /**
     * 
     * @type {UpdateAchStopPayment}
     * @memberof UpdateStopPaymentRequest
     */
    'data': UpdateAchStopPayment;
}
/**
 * 
 * @export
 * @interface UpdateTransactionRelationships
 */
export interface UpdateTransactionRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof UpdateTransactionRelationships
     */
    'account': AccountRelationship;
}
/**
 * 
 * @export
 * @interface UpdateTransactionRequest
 */
export interface UpdateTransactionRequest {
    /**
     * 
     * @type {UpdateTransactionRequestData}
     * @memberof UpdateTransactionRequest
     */
    'data': UpdateTransactionRequestData;
}
/**
 * @type UpdateTransactionRequestData
 * @export
 */
export type UpdateTransactionRequestData = UpdateBookTransaction | UpdateChargebackTransaction | UpdateTransactionTags;

/**
 * 
 * @export
 * @interface UpdateTransactionTags
 */
export interface UpdateTransactionTags {
    /**
     * 
     * @type {string}
     * @memberof UpdateTransactionTags
     */
    'type': UpdateTransactionTagsTypeEnum;
    /**
     * 
     * @type {UpdateTransactionTagsAttributes}
     * @memberof UpdateTransactionTags
     */
    'attributes': UpdateTransactionTagsAttributes;
}

export const UpdateTransactionTagsTypeEnum = {
    Transaction: 'transaction'
} as const;

export type UpdateTransactionTagsTypeEnum = typeof UpdateTransactionTagsTypeEnum[keyof typeof UpdateTransactionTagsTypeEnum];

/**
 * 
 * @export
 * @interface UpdateTransactionTagsAttributes
 */
export interface UpdateTransactionTagsAttributes {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UpdateTransactionTagsAttributes
     */
    'tags': { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface UpdateWebhookRequest
 */
export interface UpdateWebhookRequest {
    /**
     * 
     * @type {UpdateWebhookRequestData}
     * @memberof UpdateWebhookRequest
     */
    'data'?: UpdateWebhookRequestData;
}
/**
 * 
 * @export
 * @interface UpdateWebhookRequestData
 */
export interface UpdateWebhookRequestData {
    /**
     * 
     * @type {string}
     * @memberof UpdateWebhookRequestData
     */
    'type'?: string;
    /**
     * 
     * @type {UpdateWebhookRequestDataAttributes}
     * @memberof UpdateWebhookRequestData
     */
    'attributes'?: UpdateWebhookRequestDataAttributes;
}
/**
 * 
 * @export
 * @interface UpdateWebhookRequestDataAttributes
 */
export interface UpdateWebhookRequestDataAttributes {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UpdateWebhookRequestDataAttributes
     */
    'tags'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface VerifyDocument
 */
export interface VerifyDocument {
    /**
     * 
     * @type {string}
     * @memberof VerifyDocument
     */
    'jobId'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const VirtualCardStatus = {
    Active: 'Active',
    Inactive: 'Inactive',
    Stolen: 'Stolen',
    Lost: 'Lost',
    Frozen: 'Frozen',
    ClosedByCustomer: 'ClosedByCustomer',
    Unknown: 'Unknown',
    SuspectedFraud: 'SuspectedFraud'
} as const;

export type VirtualCardStatus = typeof VirtualCardStatus[keyof typeof VirtualCardStatus];


/**
 * 
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'type': WebhookTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'id': string;
    /**
     * 
     * @type {WebhookAttributes}
     * @memberof Webhook
     */
    'attributes': WebhookAttributes;
}

export const WebhookTypeEnum = {
    Webhook: 'webhook'
} as const;

export type WebhookTypeEnum = typeof WebhookTypeEnum[keyof typeof WebhookTypeEnum];

/**
 * 
 * @export
 * @interface WebhookAttributes
 */
export interface WebhookAttributes {
    /**
     * 
     * @type {string}
     * @memberof WebhookAttributes
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookAttributes
     */
    'label'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookAttributes
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookAttributes
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookAttributes
     */
    'contentType'?: WebhookAttributesContentTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof WebhookAttributes
     */
    'deliveryMode'?: WebhookAttributesDeliveryModeEnum;
    /**
     * 
     * @type {string}
     * @memberof WebhookAttributes
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookAttributes
     */
    'subscriptionType'?: string;
}

export const WebhookAttributesContentTypeEnum = {
    Json: 'Json',
    JsonApi: 'JsonAPI'
} as const;

export type WebhookAttributesContentTypeEnum = typeof WebhookAttributesContentTypeEnum[keyof typeof WebhookAttributesContentTypeEnum];
export const WebhookAttributesDeliveryModeEnum = {
    AtMostOnce: 'AtMostOnce',
    AtLeastOnce: 'AtLeastOnce'
} as const;

export type WebhookAttributesDeliveryModeEnum = typeof WebhookAttributesDeliveryModeEnum[keyof typeof WebhookAttributesDeliveryModeEnum];

/**
 * 
 * @export
 * @interface WebhookResponse
 */
export interface WebhookResponse {
    /**
     * 
     * @type {Webhook}
     * @memberof WebhookResponse
     */
    'data'?: Webhook;
}
/**
 * 
 * @export
 * @interface WeeklySchedule
 */
export interface WeeklySchedule {
    /**
     * 
     * @type {string}
     * @memberof WeeklySchedule
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof WeeklySchedule
     */
    'endTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof WeeklySchedule
     */
    'dayOfMonth'?: number;
    /**
     * 
     * @type {string}
     * @memberof WeeklySchedule
     */
    'nextScheduledAction': string;
    /**
     * 
     * @type {number}
     * @memberof WeeklySchedule
     */
    'totalNumberOfPayments'?: number;
    /**
     * 
     * @type {string}
     * @memberof WeeklySchedule
     */
    'interval': WeeklyScheduleIntervalEnum;
}

export const WeeklyScheduleIntervalEnum = {
    Weekly: 'Weekly'
} as const;

export type WeeklyScheduleIntervalEnum = typeof WeeklyScheduleIntervalEnum[keyof typeof WeeklyScheduleIntervalEnum];

/**
 * 
 * @export
 * @interface WirePayment
 */
export interface WirePayment extends Payment {
    /**
     * 
     * @type {WirePaymentAllOfAttributes}
     * @memberof WirePayment
     */
    'attributes': WirePaymentAllOfAttributes;
    /**
     * 
     * @type {WirePaymentRelationships}
     * @memberof WirePayment
     */
    'relationships': WirePaymentRelationships;
}


/**
 * 
 * @export
 * @interface WirePaymentAllOfAttributes
 */
export interface WirePaymentAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof WirePaymentAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {number}
     * @memberof WirePaymentAllOfAttributes
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof WirePaymentAllOfAttributes
     */
    'direction': WirePaymentAllOfAttributesDirectionEnum;
    /**
     * 
     * @type {string}
     * @memberof WirePaymentAllOfAttributes
     */
    'description': string;
    /**
     * 
     * @type {WirePaymentCounterparty}
     * @memberof WirePaymentAllOfAttributes
     */
    'counterparty'?: WirePaymentCounterparty;
    /**
     * 
     * @type {string}
     * @memberof WirePaymentAllOfAttributes
     */
    'status': WirePaymentAllOfAttributesStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof WirePaymentAllOfAttributes
     */
    'settlementDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof WirePaymentAllOfAttributes
     */
    'reason'?: string;
    /**
     * 
     * @type {WirePaymentAllOfAttributesImadOmad}
     * @memberof WirePaymentAllOfAttributes
     */
    'imadOmad'?: WirePaymentAllOfAttributesImadOmad;
}

export const WirePaymentAllOfAttributesDirectionEnum = {
    Credit: 'Credit'
} as const;

export type WirePaymentAllOfAttributesDirectionEnum = typeof WirePaymentAllOfAttributesDirectionEnum[keyof typeof WirePaymentAllOfAttributesDirectionEnum];
export const WirePaymentAllOfAttributesStatusEnum = {
    Pending: 'Pending',
    Rejected: 'Rejected',
    Clearing: 'Clearing',
    Sent: 'Sent',
    Canceled: 'Canceled',
    Returned: 'Returned'
} as const;

export type WirePaymentAllOfAttributesStatusEnum = typeof WirePaymentAllOfAttributesStatusEnum[keyof typeof WirePaymentAllOfAttributesStatusEnum];

/**
 * 
 * @export
 * @interface WirePaymentAllOfAttributesImadOmad
 */
export interface WirePaymentAllOfAttributesImadOmad {
    /**
     * 
     * @type {string}
     * @memberof WirePaymentAllOfAttributesImadOmad
     */
    'imad'?: string;
    /**
     * 
     * @type {string}
     * @memberof WirePaymentAllOfAttributesImadOmad
     */
    'omad'?: string;
}
/**
 * 
 * @export
 * @interface WirePaymentCounterparty
 */
export interface WirePaymentCounterparty {
    /**
     * 
     * @type {string}
     * @memberof WirePaymentCounterparty
     */
    'routingNumber': string;
    /**
     * 
     * @type {string}
     * @memberof WirePaymentCounterparty
     */
    'accountNumber': string;
    /**
     * 
     * @type {string}
     * @memberof WirePaymentCounterparty
     */
    'name': string;
    /**
     * 
     * @type {Address}
     * @memberof WirePaymentCounterparty
     */
    'address': Address;
}
/**
 * 
 * @export
 * @interface WirePaymentRelationships
 */
export interface WirePaymentRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof WirePaymentRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof WirePaymentRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof WirePaymentRelationships
     */
    'customers'?: CustomersRelationship;
    /**
     * 
     * @type {TransactionRelationship}
     * @memberof WirePaymentRelationships
     */
    'transaction': TransactionRelationship;
}
/**
 * 
 * @export
 * @interface WireTransaction
 */
export interface WireTransaction extends Transaction {
    /**
     * 
     * @type {WireTransactionAllOfAttributes}
     * @memberof WireTransaction
     */
    'attributes': WireTransactionAllOfAttributes;
    /**
     * 
     * @type {WireTransactionRelationships}
     * @memberof WireTransaction
     */
    'relationships': WireTransactionRelationships;
}


/**
 * 
 * @export
 * @interface WireTransactionAllOfAttributes
 */
export interface WireTransactionAllOfAttributes {
    /**
     * 
     * @type {string}
     * @memberof WireTransactionAllOfAttributes
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof WireTransactionAllOfAttributes
     */
    'direction': WireTransactionAllOfAttributesDirectionEnum;
    /**
     * 
     * @type {number}
     * @memberof WireTransactionAllOfAttributes
     */
    'amount': number;
    /**
     * 
     * @type {number}
     * @memberof WireTransactionAllOfAttributes
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof WireTransactionAllOfAttributes
     */
    'summary': string;
    /**
     * 
     * @type {PaymentCounterparty}
     * @memberof WireTransactionAllOfAttributes
     */
    'counterparty': PaymentCounterparty;
    /**
     * 
     * @type {string}
     * @memberof WireTransactionAllOfAttributes
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof WireTransactionAllOfAttributes
     */
    'senderReference'?: string;
    /**
     * 
     * @type {string}
     * @memberof WireTransactionAllOfAttributes
     */
    'referenceForBeneficiary'?: string;
    /**
     * 
     * @type {string}
     * @memberof WireTransactionAllOfAttributes
     */
    'originatorToBeneficiaryInformation'?: string;
    /**
     * 
     * @type {string}
     * @memberof WireTransactionAllOfAttributes
     */
    'beneficiaryInformation'?: string;
    /**
     * 
     * @type {string}
     * @memberof WireTransactionAllOfAttributes
     */
    'beneficiaryAdviceInformation'?: string;
    /**
     * 
     * @type {WirePaymentAllOfAttributesImadOmad}
     * @memberof WireTransactionAllOfAttributes
     */
    'imadOmad'?: WirePaymentAllOfAttributesImadOmad;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof WireTransactionAllOfAttributes
     */
    'tags'?: { [key: string]: string; };
}

export const WireTransactionAllOfAttributesDirectionEnum = {
    Credit: 'Credit',
    Debit: 'Debit'
} as const;

export type WireTransactionAllOfAttributesDirectionEnum = typeof WireTransactionAllOfAttributesDirectionEnum[keyof typeof WireTransactionAllOfAttributesDirectionEnum];

/**
 * 
 * @export
 * @interface WireTransactionRelationships
 */
export interface WireTransactionRelationships {
    /**
     * 
     * @type {AccountRelationship}
     * @memberof WireTransactionRelationships
     */
    'account': AccountRelationship;
    /**
     * 
     * @type {CustomerRelationship}
     * @memberof WireTransactionRelationships
     */
    'customer'?: CustomerRelationship;
    /**
     * 
     * @type {CustomersRelationship}
     * @memberof WireTransactionRelationships
     */
    'customers'?: CustomersRelationship;
}

/**
 * RepaymentInformationApi - axios parameter creator
 * @export
 */
export const RepaymentInformationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve the repayment information for a specific account via API
         * @summary Get Repayment Information
         * @param {string} accountId ID of the account to get repayment information for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        execute: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('execute', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/repayment-information`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepaymentInformationApi - functional programming interface
 * @export
 */
export const RepaymentInformationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RepaymentInformationApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve the repayment information for a specific account via API
         * @summary Get Repayment Information
         * @param {string} accountId ID of the account to get repayment information for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async execute(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitRepaymentInformationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.execute(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepaymentInformationApi.execute']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RepaymentInformationApi - factory interface
 * @export
 */
export const RepaymentInformationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RepaymentInformationApiFp(configuration)
    return {
        /**
         * Retrieve the repayment information for a specific account via API
         * @summary Get Repayment Information
         * @param {string} accountId ID of the account to get repayment information for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        execute(accountId: string, options?: any): AxiosPromise<UnitRepaymentInformationResponse> {
            return localVarFp.execute(accountId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepaymentInformationApi - object-oriented interface
 * @export
 * @class RepaymentInformationApi
 * @extends {BaseAPI}
 */
export class RepaymentInformationApi extends BaseAPI {
    /**
     * Retrieve the repayment information for a specific account via API
     * @summary Get Repayment Information
     * @param {string} accountId ID of the account to get repayment information for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepaymentInformationApi
     */
    public execute(accountId: string, options?: RawAxiosRequestConfig) {
        return RepaymentInformationApiFp(this.configuration).execute(accountId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UnitApi - axios parameter creator
 * @export
 */
export const UnitApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate Control Agreement for Account via API 
         * @summary Activate Account Control Agreement by Id
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateControlAgreementForAccount: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('activateControlAgreementForAccount', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/activate-daca`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add Authorized Users via API
         * @summary Add Authorized Users by Id
         * @param {string} customerId ID of the customer to add authorized users to
         * @param {AddAuthorizedUsersRequest} addAuthorizedUsersRequest Add Authorized Users Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAuthorizedUsers: async (customerId: string, addAuthorizedUsersRequest: AddAuthorizedUsersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('addAuthorizedUsers', 'customerId', customerId)
            // verify required parameter 'addAuthorizedUsersRequest' is not null or undefined
            assertParamExists('addAuthorizedUsers', 'addAuthorizedUsersRequest', addAuthorizedUsersRequest)
            const localVarPath = `/customers/{customerId}/authorized-users`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addAuthorizedUsersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Advance a Received Payment via API 
         * @summary Advance Received Payment by Id
         * @param {string} paymentId ID of the payment to advance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advanceReceivedPayment: async (paymentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('advanceReceivedPayment', 'paymentId', paymentId)
            const localVarPath = `/received-payments/{paymentId}/advance`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Approve a Authorization Request via API 
         * @summary Approve Authorization Request by Id
         * @param {string} authorizationId ID of the authorization request to approve
         * @param {ApproveAuthorizationRequest} approveAuthorizationRequest Approve Authorization Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveAuthorizationRequest: async (authorizationId: string, approveAuthorizationRequest: ApproveAuthorizationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorizationId' is not null or undefined
            assertParamExists('approveAuthorizationRequest', 'authorizationId', authorizationId)
            // verify required parameter 'approveAuthorizationRequest' is not null or undefined
            assertParamExists('approveAuthorizationRequest', 'approveAuthorizationRequest', approveAuthorizationRequest)
            const localVarPath = `/authorization-requests/{authorizationId}/approve`
                .replace(`{${"authorizationId"}}`, encodeURIComponent(String(authorizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(approveAuthorizationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Approve a Check Payment via API 
         * @summary Approve Check Payment by Id
         * @param {string} checkPaymentId ID of the check payment to approve
         * @param {ApproveCheckPaymentRequest} approveCheckPaymentRequest Approve Check Payment Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveCheckPayment: async (checkPaymentId: string, approveCheckPaymentRequest: ApproveCheckPaymentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkPaymentId' is not null or undefined
            assertParamExists('approveCheckPayment', 'checkPaymentId', checkPaymentId)
            // verify required parameter 'approveCheckPaymentRequest' is not null or undefined
            assertParamExists('approveCheckPayment', 'approveCheckPaymentRequest', approveCheckPaymentRequest)
            const localVarPath = `/check-payments/{checkPaymentId}/approve`
                .replace(`{${"checkPaymentId"}}`, encodeURIComponent(String(checkPaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(approveCheckPaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Archive a Customer via API 
         * @summary Archive Customer by Id
         * @param {string} customerId ID of the customer to archive
         * @param {ArchiveCustomerRequest} archiveCustomerRequest Archive Customer Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveCustomer: async (customerId: string, archiveCustomerRequest: ArchiveCustomerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('archiveCustomer', 'customerId', customerId)
            // verify required parameter 'archiveCustomerRequest' is not null or undefined
            assertParamExists('archiveCustomer', 'archiveCustomerRequest', archiveCustomerRequest)
            const localVarPath = `/customers/{customerId}/archive`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(archiveCustomerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel a Application via API 
         * @summary Cancel Application by Id
         * @param {string} applicationId ID of the application to get
         * @param {CancelApplicationRequest} cancelApplicationRequest Cancel Application Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelApplication: async (applicationId: string, cancelApplicationRequest: CancelApplicationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('cancelApplication', 'applicationId', applicationId)
            // verify required parameter 'cancelApplicationRequest' is not null or undefined
            assertParamExists('cancelApplication', 'cancelApplicationRequest', cancelApplicationRequest)
            const localVarPath = `/applications/{applicationId}/cancel`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelApplicationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel a Check Payment via API 
         * @summary Cancel Check Payment by Id
         * @param {string} checkPaymentId ID of the check payment to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelCheckPayment: async (checkPaymentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkPaymentId' is not null or undefined
            assertParamExists('cancelCheckPayment', 'checkPaymentId', checkPaymentId)
            const localVarPath = `/check-payments/{checkPaymentId}/cancel`
                .replace(`{${"checkPaymentId"}}`, encodeURIComponent(String(checkPaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel a Payment via API 
         * @summary Cancel a Payment by Id
         * @param {string} paymentId ID of the payment to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPayment: async (paymentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('cancelPayment', 'paymentId', paymentId)
            const localVarPath = `/payments/{paymentId}/cancel`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Close an Account via API 
         * @summary Close an Account by Id
         * @param {string} accountId ID of the account to close
         * @param {CloseAccountRequest} closeAccountRequest Close Account Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeAccount: async (accountId: string, closeAccountRequest: CloseAccountRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('closeAccount', 'accountId', accountId)
            // verify required parameter 'closeAccountRequest' is not null or undefined
            assertParamExists('closeAccount', 'closeAccountRequest', closeAccountRequest)
            const localVarPath = `/accounts/{accountId}/close`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(closeAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Close a Card via API 
         * @summary Close a Card
         * @param {string} cardId ID of the card to close
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeCard: async (cardId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cardId' is not null or undefined
            assertParamExists('closeCard', 'cardId', cardId)
            const localVarPath = `/cards/{cardId}/close`
                .replace(`{${"cardId"}}`, encodeURIComponent(String(cardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Confirm a Check Deposit from API 
         * @summary Confirm by Id
         * @param {string} checkDepositId ID of the check deposit to confirm
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmCheckDeposit: async (checkDepositId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkDepositId' is not null or undefined
            assertParamExists('confirmCheckDeposit', 'checkDepositId', checkDepositId)
            const localVarPath = `/check-deposits/{checkDepositId}/confirm`
                .replace(`{${"checkDepositId"}}`, encodeURIComponent(String(checkDepositId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create Account via API 
         * @summary Create Account
         * @param {CreateAccountRequest} createAccountRequest Create Account Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (createAccountRequest: CreateAccountRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAccountRequest' is not null or undefined
            assertParamExists('createAccount', 'createAccountRequest', createAccountRequest)
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an Org API Token via API 
         * @summary Create Org API Token
         * @param {string} userId ID of the user to create token for
         * @param {CreateApiTokenRequest} createApiTokenRequest Create Org API Token Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiToken: async (userId: string, createApiTokenRequest: CreateApiTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createApiToken', 'userId', userId)
            // verify required parameter 'createApiTokenRequest' is not null or undefined
            assertParamExists('createApiToken', 'createApiTokenRequest', createApiTokenRequest)
            const localVarPath = `/users/{userId}/api-tokens`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createApiTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an Application via API 
         * @summary Create Application
         * @param {CreateApplicationRequest} createApplicationRequest Create Application Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication: async (createApplicationRequest: CreateApplicationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createApplicationRequest' is not null or undefined
            assertParamExists('createApplication', 'createApplicationRequest', createApplicationRequest)
            const localVarPath = `/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createApplicationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an application document via API
         * @summary Create an application document
         * @param {string} applicationId ID of the application to create a file for
         * @param {DefaultContentType} contentType A workaround to properly assign the content type for the request body while providing no body, just set the one possible enum value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationDocument: async (applicationId: string, contentType: DefaultContentType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationDocument', 'applicationId', applicationId)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('createApplicationDocument', 'contentType', contentType)
            const localVarPath = `/applications/{applicationId}/documents`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = typeof contentType === 'string'
                    ? contentType
                    : JSON.stringify(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an Application Form via API 
         * @summary Create Application Form
         * @param {CreateApplicationFormRequest} createApplicationFormRequest Create Application Form Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationForm: async (createApplicationFormRequest: CreateApplicationFormRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createApplicationFormRequest' is not null or undefined
            assertParamExists('createApplicationForm', 'createApplicationFormRequest', createApplicationFormRequest)
            const localVarPath = `/application-forms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createApplicationFormRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Card via API 
         * @summary Create a Card
         * @param {CreateCardRequest} createCardRequest Create Card Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCard: async (createCardRequest: CreateCardRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCardRequest' is not null or undefined
            assertParamExists('createCard', 'createCardRequest', createCardRequest)
            const localVarPath = `/cards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Check Deposit via API 
         * @summary Create Check Deposit
         * @param {CreateCheckDepositRequest} createCheckDepositRequest Create Check Deposit Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckDeposit: async (createCheckDepositRequest: CreateCheckDepositRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCheckDepositRequest' is not null or undefined
            assertParamExists('createCheckDeposit', 'createCheckDepositRequest', createCheckDepositRequest)
            const localVarPath = `/check-deposits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCheckDepositRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create Check Payment via API 
         * @summary Create Check Payment
         * @param {CreateCheckPaymentRequest} createCheckPaymentRequest Create Check Payment Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckPayment: async (createCheckPaymentRequest: CreateCheckPaymentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCheckPaymentRequest' is not null or undefined
            assertParamExists('createCheckPayment', 'createCheckPaymentRequest', createCheckPaymentRequest)
            const localVarPath = `/check-payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCheckPaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a counterparty via API 
         * @summary Create Counterparty
         * @param {CreateCounterpartyRequest} createCounterpartyRequest Create Counterparty Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCounterparty: async (createCounterpartyRequest: CreateCounterpartyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCounterpartyRequest' is not null or undefined
            assertParamExists('createCounterparty', 'createCounterpartyRequest', createCounterpartyRequest)
            const localVarPath = `/counterparties`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCounterpartyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Customer Token via API 
         * @summary Create Customer Token
         * @param {string} customerId ID of the customer to create token for
         * @param {CreateCustomerTokenRequest} createCustomerTokenRequest Create Customer Token Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerToken: async (customerId: string, createCustomerTokenRequest: CreateCustomerTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('createCustomerToken', 'customerId', customerId)
            // verify required parameter 'createCustomerTokenRequest' is not null or undefined
            assertParamExists('createCustomerToken', 'createCustomerTokenRequest', createCustomerTokenRequest)
            const localVarPath = `/customers/{customerId}/token`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCustomerTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Customer Token Verification via API 
         * @summary Create Customer Token Verification
         * @param {string} customerId ID of the customer to create token for
         * @param {CreateCustomerTokenVerificationRequest} createCustomerTokenVerificationRequest Create Customer Token Verification Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerTokenVerification: async (customerId: string, createCustomerTokenVerificationRequest: CreateCustomerTokenVerificationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('createCustomerTokenVerification', 'customerId', customerId)
            // verify required parameter 'createCustomerTokenVerificationRequest' is not null or undefined
            assertParamExists('createCustomerTokenVerification', 'createCustomerTokenVerificationRequest', createCustomerTokenVerificationRequest)
            const localVarPath = `/customers/{customerId}/token/verification`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCustomerTokenVerificationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Fee via API 
         * @summary Create Fee
         * @param {CreateFeeRequest} createFeeRequest Create Fee Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFee: async (createFeeRequest: CreateFeeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createFeeRequest' is not null or undefined
            assertParamExists('createFee', 'createFeeRequest', createFeeRequest)
            const localVarPath = `/fees`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFeeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Payment via API 
         * @summary Create a Payment
         * @param {CreatePaymentRequest} createPaymentRequest Create Payment Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayment: async (createPaymentRequest: CreatePaymentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPaymentRequest' is not null or undefined
            assertParamExists('createPayment', 'createPaymentRequest', createPaymentRequest)
            const localVarPath = `/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Recurring Payment via API 
         * @summary Create Recurring Payment
         * @param {CreateRecurringPaymentRequest} createRecurringPaymentRequest Create Recurring Payment Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecurringPayment: async (createRecurringPaymentRequest: CreateRecurringPaymentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRecurringPaymentRequest' is not null or undefined
            assertParamExists('createRecurringPayment', 'createRecurringPaymentRequest', createRecurringPaymentRequest)
            const localVarPath = `/recurring-payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRecurringPaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Recurring Repayment via API
         * @summary Create a Recurring Repayment
         * @param {CreateRecurringRepaymentRequest} createRecurringRepaymentRequest Create a Recurring Repayment Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecurringRepayment: async (createRecurringRepaymentRequest: CreateRecurringRepaymentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRecurringRepaymentRequest' is not null or undefined
            assertParamExists('createRecurringRepayment', 'createRecurringRepaymentRequest', createRecurringRepaymentRequest)
            const localVarPath = `/recurring-repayments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRecurringRepaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Repayment via API 
         * @summary Create a Repayment
         * @param {CreateRepaymentRequest} createRepaymentRequest Create a Repayment Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepayment: async (createRepaymentRequest: CreateRepaymentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRepaymentRequest' is not null or undefined
            assertParamExists('createRepayment', 'createRepaymentRequest', createRepaymentRequest)
            const localVarPath = `/repayments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRepaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Reward via API 
         * @summary Create Reward
         * @param {CreateRewardRequest} createRewardRequest Create Reward Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReward: async (createRewardRequest: CreateRewardRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRewardRequest' is not null or undefined
            assertParamExists('createReward', 'createRewardRequest', createRewardRequest)
            const localVarPath = `/rewards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRewardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Stop Payment
         * @param {CreateStopPaymentRequest} createStopPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStopPayment: async (createStopPaymentRequest: CreateStopPaymentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createStopPaymentRequest' is not null or undefined
            assertParamExists('createStopPayment', 'createStopPaymentRequest', createStopPaymentRequest)
            const localVarPath = `/stop-payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createStopPaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Webhook via API 
         * @summary Create Webhook
         * @param {CreateWebhook} createWebhook Create Webhook Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook: async (createWebhook: CreateWebhook, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWebhook' is not null or undefined
            assertParamExists('createWebhook', 'createWebhook', createWebhook)
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWebhook, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deactivate Control Agreement for Account via API
         * @summary Deactivate Account Control Agreement by Id
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateControlAgreementForAccount: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('deactivateControlAgreementForAccount', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/deactivate-daca`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Decline Authorization Request via API 
         * @summary Decline Authorization Request
         * @param {string} authorizationId ID of the authorization request to decline
         * @param {DeclineAuthorizationRequest} declineAuthorizationRequest Decline Authorization Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        declineAuthorizationRequest: async (authorizationId: string, declineAuthorizationRequest: DeclineAuthorizationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorizationId' is not null or undefined
            assertParamExists('declineAuthorizationRequest', 'authorizationId', authorizationId)
            // verify required parameter 'declineAuthorizationRequest' is not null or undefined
            assertParamExists('declineAuthorizationRequest', 'declineAuthorizationRequest', declineAuthorizationRequest)
            const localVarPath = `/authorization-requests/{authorizationId}/decline`
                .replace(`{${"authorizationId"}}`, encodeURIComponent(String(authorizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(declineAuthorizationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Counterparty via API 
         * @summary Delete Counterparty by Id
         * @param {string} counterpartyId ID of the counterparty to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCounterparty: async (counterpartyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'counterpartyId' is not null or undefined
            assertParamExists('deleteCounterparty', 'counterpartyId', counterpartyId)
            const localVarPath = `/counterparties/{counterpartyId}`
                .replace(`{${"counterpartyId"}}`, encodeURIComponent(String(counterpartyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Reward from API 
         * @summary Get Reward by Id
         * @param {string} userId ID of the user to revoke token
         * @param {string} tokenId ID of the token to revoke
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken: async (userId: string, tokenId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteToken', 'userId', userId)
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('deleteToken', 'tokenId', tokenId)
            const localVarPath = `/users/{userId}/api-tokens/{tokenId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disable Recurring Payment via API 
         * @summary Disable Recurring Payment
         * @param {string} paymentId ID of the payment to disable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableRecurringPayment: async (paymentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('disableRecurringPayment', 'paymentId', paymentId)
            const localVarPath = `/recurring-payments/{paymentId}/disable`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disable a Recurring Repayment
         * @summary Disable Recurring Repayment by Id
         * @param {string} recurringRepaymentId ID of the recurring repayment to disable
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableRecurringRepayment: async (recurringRepaymentId: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recurringRepaymentId' is not null or undefined
            assertParamExists('disableRecurringRepayment', 'recurringRepaymentId', recurringRepaymentId)
            const localVarPath = `/recurring-repayments/{recurringRepaymentId}/disable`
                .replace(`{${"recurringRepaymentId"}}`, encodeURIComponent(String(recurringRepaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disable a stop payment
         * @param {string} stopPaymentId ID of the stop payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableStopPayment: async (stopPaymentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stopPaymentId' is not null or undefined
            assertParamExists('disableStopPayment', 'stopPaymentId', stopPaymentId)
            const localVarPath = `/stop-payments/{stopPaymentId}/disable`
                .replace(`{${"stopPaymentId"}}`, encodeURIComponent(String(stopPaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disable a Webhook via API 
         * @summary Disable a Webhook
         * @param {string} webhookId ID of the webhook to disable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableWebhook: async (webhookId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('disableWebhook', 'webhookId', webhookId)
            const localVarPath = `/webhooks/{webhookId}/disable`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download a Document - Back Side via API
         * @summary Download a Document - Back Side
         * @param {string} applicationId ID of the application
         * @param {string} documentId ID of the document to download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadApplicationBackSideDocument: async (applicationId: string, documentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('downloadApplicationBackSideDocument', 'applicationId', applicationId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('downloadApplicationBackSideDocument', 'documentId', documentId)
            const localVarPath = `/applications/{applicationId}/documents/{documentId}/download/back`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download a Document via API 
         * @summary Download a Document
         * @param {string} applicationId ID of the application
         * @param {string} documentId ID of the document to download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadApplicationDocument: async (applicationId: string, documentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('downloadApplicationDocument', 'applicationId', applicationId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('downloadApplicationDocument', 'documentId', documentId)
            const localVarPath = `/applications/{applicationId}/documents/{documentId}/download`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable Recurring Payment via API 
         * @summary Enable Recurring Payment
         * @param {string} paymentId ID of the payment to enable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableRecurringPayment: async (paymentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('enableRecurringPayment', 'paymentId', paymentId)
            const localVarPath = `/recurring-payments/{paymentId}/enable`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable a Recurring Repayment
         * @summary Enable Recurring Repayment by Id
         * @param {string} recurringRepaymentId ID of the recurring repayment to enable
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableRecurringRepayment: async (recurringRepaymentId: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recurringRepaymentId' is not null or undefined
            assertParamExists('enableRecurringRepayment', 'recurringRepaymentId', recurringRepaymentId)
            const localVarPath = `/recurring-repayments/{recurringRepaymentId}/enable`
                .replace(`{${"recurringRepaymentId"}}`, encodeURIComponent(String(recurringRepaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable a Webhook via API 
         * @summary Enable Webhook
         * @param {string} webhookId ID of the webhook to enable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableWebhook: async (webhookId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('enableWebhook', 'webhookId', webhookId)
            const localVarPath = `/webhooks/{webhookId}/enable`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enter Control Agreement for Account via API 
         * @summary Enter Account Control Agreement by Id
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enterControlAgreementForAccount: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('enterControlAgreementForAccount', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/enter-daca`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fire an Event via API 
         * @summary Fire Event by Id
         * @param {string} eventId ID of the event to fire
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fireEvent: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('fireEvent', 'eventId', eventId)
            const localVarPath = `/events/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Freeze Account via API 
         * @summary Freeze Account by Id
         * @param {string} accountId ID of the account to freeze
         * @param {FreezeAccountRequest} freezeAccountRequest Freeze Account Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        freezeAccount: async (accountId: string, freezeAccountRequest: FreezeAccountRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('freezeAccount', 'accountId', accountId)
            // verify required parameter 'freezeAccountRequest' is not null or undefined
            assertParamExists('freezeAccount', 'freezeAccountRequest', freezeAccountRequest)
            const localVarPath = `/accounts/{accountId}/freeze`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(freezeAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Freeze a Card via API 
         * @summary Freeze a Card
         * @param {string} cardId ID of the card to freeze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        freezeCard: async (cardId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cardId' is not null or undefined
            assertParamExists('freezeCard', 'cardId', cardId)
            const localVarPath = `/cards/{cardId}/freeze`
                .replace(`{${"cardId"}}`, encodeURIComponent(String(cardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an Account from API 
         * @summary Get Account by Id
         * @param {string} accountId ID of the account to get
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (accountId: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccount', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get AccountEndOfDay List from API 
         * @summary Get AccountEndOfDay List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountEndOfDay: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account-end-of-day`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Account Limits from API 
         * @summary Get Account Limits by Id
         * @param {string} accountId ID of the account to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountLimits: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountLimits', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/limits`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get List Accounts from API 
         * @summary Get List Accounts
         * @param {ListPageParameters} [page] 
         * @param {GetAccountsListFilterParameter} [filter] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsList: async (page?: ListPageParameters, filter?: GetAccountsListFilterParameter, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get List Org API Tokens from API 
         * @summary Get List Org API Tokens
         * @param {string} userId ID of the user to revoke token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiTokensList: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getApiTokensList', 'userId', userId)
            const localVarPath = `/users/{userId}/api-tokens`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an Application from API 
         * @summary Get Application by Id
         * @param {string} applicationId ID of the application to get
         * @param {string} [included] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication: async (applicationId: string, included?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplication', 'applicationId', applicationId)
            const localVarPath = `/applications/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (included !== undefined) {
                localVarQueryParameter['included'] = included;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get List of Documents via API 
         * @summary Get List of Documents
         * @param {string} applicationId ID of the application to get documents for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationDocuments: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationDocuments', 'applicationId', applicationId)
            const localVarPath = `/applications/{applicationId}/documents`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an Application Form from API 
         * @summary Get ApplicationForm by Id
         * @param {string} applicationFormId ID of the application form to get
         * @param {string} [included] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationForm: async (applicationFormId: string, included?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationFormId' is not null or undefined
            assertParamExists('getApplicationForm', 'applicationFormId', applicationFormId)
            const localVarPath = `/application-forms/{applicationFormId}`
                .replace(`{${"applicationFormId"}}`, encodeURIComponent(String(applicationFormId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (included !== undefined) {
                localVarQueryParameter['included'] = included;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get List Application Forms from API 
         * @summary Get List Application Forms
         * @param {ListPageParameters} [page] 
         * @param {GetApplicationFormsListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationFormsList: async (page?: ListPageParameters, filter?: GetApplicationFormsListFilterParameter, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/application-forms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get List Applications from API 
         * @summary Get List Application
         * @param {ListPageParameters} [page] 
         * @param {GetApplicationsListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationsList: async (page?: ListPageParameters, filter?: GetApplicationsListFilterParameter, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get List ATM Locations from API 
         * @summary Get List of ATM Locations
         * @param {GetAtmLocationsListFilterParameter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAtmLocationsList: async (filter?: GetAtmLocationsListFilterParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/atm-locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Authorization from API 
         * @summary Get Authorization by Id
         * @param {string} authorizationId ID of the authorization to get
         * @param {boolean} [includeNoneAuthorized] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorization: async (authorizationId: string, includeNoneAuthorized?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorizationId' is not null or undefined
            assertParamExists('getAuthorization', 'authorizationId', authorizationId)
            const localVarPath = `/authorizations/{authorizationId}`
                .replace(`{${"authorizationId"}}`, encodeURIComponent(String(authorizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (includeNoneAuthorized !== undefined) {
                localVarQueryParameter['includeNoneAuthorized'] = includeNoneAuthorized;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Authorization Request from API 
         * @summary Get Authorization Request by Id
         * @param {string} authorizationId ID of the authorization request to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorizationRequest: async (authorizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorizationId' is not null or undefined
            assertParamExists('getAuthorizationRequest', 'authorizationId', authorizationId)
            const localVarPath = `/authorization-requests/{authorizationId}`
                .replace(`{${"authorizationId"}}`, encodeURIComponent(String(authorizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get List Authorization Requests from API 
         * @summary Get List Authorization Requests
         * @param {ListPageParameters} [page] 
         * @param {GetAuthorizationRequestsListFilterParameter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorizationRequestsList: async (page?: ListPageParameters, filter?: GetAuthorizationRequestsListFilterParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authorization-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get List Authorizations from API 
         * @summary Get List authorizations
         * @param {ListPageParameters} [page] 
         * @param {GetAuthorizationsListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorizationsList: async (page?: ListPageParameters, filter?: GetAuthorizationsListFilterParameter, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authorizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Back Check Deposit Image from API 
         * @summary Get Back Check Deposit Image by Id
         * @param {string} checkDepositId ID of the check deposit to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackCheckDeposit: async (checkDepositId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkDepositId' is not null or undefined
            assertParamExists('getBackCheckDeposit', 'checkDepositId', checkDepositId)
            const localVarPath = `/check-deposits/{checkDepositId}/back`
                .replace(`{${"checkDepositId"}}`, encodeURIComponent(String(checkDepositId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Card from API 
         * @summary Get Card by Id
         * @param {string} cardId ID of the card to get
         * @param {string} [included] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCard: async (cardId: string, included?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cardId' is not null or undefined
            assertParamExists('getCard', 'cardId', cardId)
            const localVarPath = `/cards/{cardId}`
                .replace(`{${"cardId"}}`, encodeURIComponent(String(cardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (included !== undefined) {
                localVarQueryParameter['included'] = included;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Card Limits from API 
         * @summary Get Card Limit by Id
         * @param {string} cardId ID of the card to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardLimits: async (cardId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cardId' is not null or undefined
            assertParamExists('getCardLimits', 'cardId', cardId)
            const localVarPath = `/cards/{cardId}/limits`
                .replace(`{${"cardId"}}`, encodeURIComponent(String(cardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Card PIN Status via API 
         * @summary Get Card PIN Status
         * @param {string} cardId ID of the card to get PIN status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardPinStatus: async (cardId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cardId' is not null or undefined
            assertParamExists('getCardPinStatus', 'cardId', cardId)
            const localVarPath = `/cards/{cardId}/secure-data/pin/status`
                .replace(`{${"cardId"}}`, encodeURIComponent(String(cardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get List of Cards from API 
         * @summary Get List of Cards
         * @param {ListPageParameters} [page] 
         * @param {GetCardsListFilterParameter} [filter] 
         * @param {string} [include] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsList: async (page?: ListPageParameters, filter?: GetCardsListFilterParameter, include?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Check Deposit from API 
         * @summary Get Check Deposit by Id
         * @param {string} checkDepositId ID of the check deposit to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckDeposit: async (checkDepositId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkDepositId' is not null or undefined
            assertParamExists('getCheckDeposit', 'checkDepositId', checkDepositId)
            const localVarPath = `/check-deposits/{checkDepositId}`
                .replace(`{${"checkDepositId"}}`, encodeURIComponent(String(checkDepositId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get List Check Deposits from API 
         * @summary Get List Check Deposits
         * @param {ListPageParameters} [page] 
         * @param {GetCheckDepositsListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckDepositsList: async (page?: ListPageParameters, filter?: GetCheckDepositsListFilterParameter, sort?: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/check-deposits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Check Payment from API 
         * @summary Get Check Payment by Id
         * @param {string} checkPaymentId ID of the check payment to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckPayment: async (checkPaymentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkPaymentId' is not null or undefined
            assertParamExists('getCheckPayment', 'checkPaymentId', checkPaymentId)
            const localVarPath = `/check-payments/{checkPaymentId}`
                .replace(`{${"checkPaymentId"}}`, encodeURIComponent(String(checkPaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get back image via API 
         * @summary Get back image
         * @param {string} checkPaymentId ID of the check payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckPaymentBack: async (checkPaymentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkPaymentId' is not null or undefined
            assertParamExists('getCheckPaymentBack', 'checkPaymentId', checkPaymentId)
            const localVarPath = `/check-payments/{checkPaymentId}/back`
                .replace(`{${"checkPaymentId"}}`, encodeURIComponent(String(checkPaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get front image via API 
         * @summary Get front image
         * @param {string} checkPaymentId ID of the check payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckPaymentFront: async (checkPaymentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkPaymentId' is not null or undefined
            assertParamExists('getCheckPaymentFront', 'checkPaymentId', checkPaymentId)
            const localVarPath = `/check-payments/{checkPaymentId}/front`
                .replace(`{${"checkPaymentId"}}`, encodeURIComponent(String(checkPaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get List Check Payments from API 
         * @summary Get List Check Payments
         * @param {ListPageParameters} [page] 
         * @param {GetCheckPaymentsListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckPaymentsList: async (page?: ListPageParameters, filter?: GetCheckPaymentsListFilterParameter, sort?: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/check-payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                for (const [key, value] of Object.entries(filter)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Counterparties List from API 
         * @summary Get Counterparties List
         * @param {ListPageParameters} [page] 
         * @param {GetCounterpartiesListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCounterpartiesList: async (page?: ListPageParameters, filter?: GetCounterpartiesListFilterParameter, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/counterparties`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Counterparty from API 
         * @summary Get Counterparty by Id
         * @param {string} counterpartyId ID of the counterparty to get
         * @param {string} [included] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCounterparty: async (counterpartyId: string, included?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'counterpartyId' is not null or undefined
            assertParamExists('getCounterparty', 'counterpartyId', counterpartyId)
            const localVarPath = `/counterparties/{counterpartyId}`
                .replace(`{${"counterpartyId"}}`, encodeURIComponent(String(counterpartyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (included !== undefined) {
                localVarQueryParameter['included'] = included;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Recurring Payment from API 
         * @summary Get Counterparty Balance
         * @param {string} counterpartyId ID of the counterparty to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCounterpartyBalance: async (counterpartyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'counterpartyId' is not null or undefined
            assertParamExists('getCounterpartyBalance', 'counterpartyId', counterpartyId)
            const localVarPath = `/counterparties/{counterpartyId}/balance`
                .replace(`{${"counterpartyId"}}`, encodeURIComponent(String(counterpartyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Customer from API 
         * @summary Get Customer by Id
         * @param {string} customerId ID of the customer to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer: async (customerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('getCustomer', 'customerId', customerId)
            const localVarPath = `/customers/{customerId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Customers List from API 
         * @summary Get Customers List
         * @param {ListPageParameters} [page] 
         * @param {GetCustomersListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersList: async (page?: ListPageParameters, filter?: GetCustomersListFilterParameter, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Dispute from API 
         * @summary Get Dispute by Id
         * @param {string} disputeId ID of the dispute to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDispute: async (disputeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'disputeId' is not null or undefined
            assertParamExists('getDispute', 'disputeId', disputeId)
            const localVarPath = `/disputes/{disputeId}`
                .replace(`{${"disputeId"}}`, encodeURIComponent(String(disputeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get List Disputes from API 
         * @summary Get List Disputes
         * @param {ListPageParameters} [page] 
         * @param {GetDisputesListFilterParameter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisputesList: async (page?: ListPageParameters, filter?: GetDisputesListFilterParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/disputes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an Event from API 
         * @summary Get Event by Id
         * @param {string} eventId ID of the event to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEvent', 'eventId', eventId)
            const localVarPath = `/events/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Events List from API 
         * @summary Get Events List
         * @param {ListPageParameters} [page] 
         * @param {GetEventsListFilterParameter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsList: async (page?: ListPageParameters, filter?: GetEventsListFilterParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Front Check Deposit Image from API 
         * @summary Get Front Check Deposit Image by Id
         * @param {string} checkDepositId ID of the check deposit to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFrontCheckDeposit: async (checkDepositId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkDepositId' is not null or undefined
            assertParamExists('getFrontCheckDeposit', 'checkDepositId', checkDepositId)
            const localVarPath = `/check-deposits/{checkDepositId}/front`
                .replace(`{${"checkDepositId"}}`, encodeURIComponent(String(checkDepositId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an Institution from API 
         * @summary Get Institution by Routing Number
         * @param {string} routingNumber routingNumber of the institution to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstitution: async (routingNumber: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'routingNumber' is not null or undefined
            assertParamExists('getInstitution', 'routingNumber', routingNumber)
            const localVarPath = `/institutions/{routingNumber}`
                .replace(`{${"routingNumber"}}`, encodeURIComponent(String(routingNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Rewards List from API 
         * @summary Get Rewards List
         * @param {ListPageParameters} [page] 
         * @param {GetListRewardsFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListRewards: async (page?: ListPageParameters, filter?: GetListRewardsFilterParameter, sort?: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Payment from API 
         * @summary Get Payment by Id
         * @param {string} paymentId ID of the payment to get
         * @param {string} [included] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment: async (paymentId: string, included?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('getPayment', 'paymentId', paymentId)
            const localVarPath = `/payments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (included !== undefined) {
                localVarQueryParameter['included'] = included;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get List Payments from API 
         * @summary Get List Payments
         * @param {ListPageParameters} [page] 
         * @param {GetPaymentsListFilterParameter} [filter] 
         * @param {string} [include] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsList: async (page?: ListPageParameters, filter?: GetPaymentsListFilterParameter, include?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Received Payment from API 
         * @summary Get Received Payment by Id
         * @param {string} paymentId ID of the payment to get
         * @param {string} [included] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReceivedPayment: async (paymentId: string, included?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('getReceivedPayment', 'paymentId', paymentId)
            const localVarPath = `/received-payments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (included !== undefined) {
                localVarQueryParameter['included'] = included;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Received Payments from API 
         * @summary Get Received Payments List
         * @param {string} [included] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReceivedPaymentsList: async (included?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/received-payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (included !== undefined) {
                localVarQueryParameter['included'] = included;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Recurring Payment from API 
         * @summary Get Recurring Payment
         * @param {string} paymentId ID of the payment to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecurringPayment: async (paymentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('getRecurringPayment', 'paymentId', paymentId)
            const localVarPath = `/recurring-payments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Recurring Payments List from API 
         * @summary Get Recurring Payments List
         * @param {ListPageParameters} [page] 
         * @param {GetRecurringPaymentsListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecurringPaymentsList: async (page?: ListPageParameters, filter?: GetRecurringPaymentsListFilterParameter, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/recurring-payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Recurring Repayment from API 
         * @summary Get Recurring Repayment by Id
         * @param {string} recurringRepaymentId ID of the recurring repayment to get
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecurringRepayment: async (recurringRepaymentId: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recurringRepaymentId' is not null or undefined
            assertParamExists('getRecurringRepayment', 'recurringRepaymentId', recurringRepaymentId)
            const localVarPath = `/recurring-repayments/{recurringRepaymentId}`
                .replace(`{${"recurringRepaymentId"}}`, encodeURIComponent(String(recurringRepaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get List Recurring Repayments from API 
         * @summary Get List Recurring Repayments
         * @param {ListPageParameters} [page] 
         * @param {GetRecurringRepaymentsListFilterParameter} [filter] 
         * @param {GetRecurringRepaymentsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecurringRepaymentsList: async (page?: ListPageParameters, filter?: GetRecurringRepaymentsListFilterParameter, sort?: GetRecurringRepaymentsListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/recurring-repayments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an Repayment from API 
         * @summary Get Repayment by Id
         * @param {string} repaymentId ID of the repayment to get
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepayment: async (repaymentId: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repaymentId' is not null or undefined
            assertParamExists('getRepayment', 'repaymentId', repaymentId)
            const localVarPath = `/repayments/{repaymentId}`
                .replace(`{${"repaymentId"}}`, encodeURIComponent(String(repaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get List Repayments from API 
         * @summary Get List Repayments
         * @param {ListPageParameters} [page] 
         * @param {GetRepaymentsListFilterParameter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepaymentsList: async (page?: ListPageParameters, filter?: GetRepaymentsListFilterParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/repayments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Reward from API 
         * @summary Get Reward by Id
         * @param {string} rewardId ID of the reward to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReward: async (rewardId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rewardId' is not null or undefined
            assertParamExists('getReward', 'rewardId', rewardId)
            const localVarPath = `/rewards/{rewardId}`
                .replace(`{${"rewardId"}}`, encodeURIComponent(String(rewardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Get Bank verification PDF from API 
         * @summary Get Bank verification PDF
         * @param {string} accountId ID of the account to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatementBankPdf: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getStatementBankPdf', 'accountId', accountId)
            const localVarPath = `/statements/{accountId}/bank/pdf`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a HTML Statement from API 
         * @summary Get HTML Statement by Id
         * @param {string} statementId ID of the statement to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatementHtml: async (statementId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'statementId' is not null or undefined
            assertParamExists('getStatementHtml', 'statementId', statementId)
            const localVarPath = `/statements/{statementId}/html`
                .replace(`{${"statementId"}}`, encodeURIComponent(String(statementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a PDF Statement from API 
         * @summary Get PDF Statement by Id
         * @param {string} statementId ID of the statement to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatementPdf: async (statementId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'statementId' is not null or undefined
            assertParamExists('getStatementPdf', 'statementId', statementId)
            const localVarPath = `/statements/{statementId}/pdf`
                .replace(`{${"statementId"}}`, encodeURIComponent(String(statementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get List Statements from API 
         * @summary Get List Statements
         * @param {ListPageParameters} [page] 
         * @param {GetStatementsListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatementsList: async (page?: ListPageParameters, filter?: GetStatementsListFilterParameter, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/statements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details of a specific stop payment
         * @param {string} stopPaymentId ID of the stop payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStopPayment: async (stopPaymentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stopPaymentId' is not null or undefined
            assertParamExists('getStopPayment', 'stopPaymentId', stopPaymentId)
            const localVarPath = `/stop-payments/{stopPaymentId}`
                .replace(`{${"stopPaymentId"}}`, encodeURIComponent(String(stopPaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of stop payments
         * @param {ListPageParameters} [page] 
         * @param {GetStopPaymentsListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStopPaymentsList: async (page?: ListPageParameters, filter?: GetStopPaymentsListFilterParameter, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stop-payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                for (const [key, value] of Object.entries(filter)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Transaction from API 
         * @summary Get Transaction by Id
         * @param {string} accountId ID of the account to get transaction from
         * @param {string} transactionId ID of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction: async (accountId: string, transactionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getTransaction', 'accountId', accountId)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('getTransaction', 'transactionId', transactionId)
            const localVarPath = `/accounts/{accountId}/transactions/{transactionId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get List Transactions from API 
         * @summary Get List Transactions
         * @param {ListPageParameters} [page] 
         * @param {GetTransactionsListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsList: async (page?: ListPageParameters, filter?: GetTransactionsListFilterParameter, sort?: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Webhook from API 
         * @summary Get Webhook Id
         * @param {string} webhookId ID of the webhook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook: async (webhookId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('getWebhook', 'webhookId', webhookId)
            const localVarPath = `/webhooks/{webhookId}`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get List Webhooks from API 
         * @summary Get List Webhooks
         * @param {ListPageParameters} [page] 
         * @param {GetWebhooksListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooksList: async (page?: ListPageParameters, filter?: GetWebhooksListFilterParameter, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Received Payment via API 
         * @summary Update Received Payment
         * @param {string} paymentId ID of the payment to update
         * @param {UpdateReceivedPaymentRequest} updateReceivedPaymentRequest Update Received Payment Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receivedPaymentsPaymentIdPatch: async (paymentId: string, updateReceivedPaymentRequest: UpdateReceivedPaymentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('receivedPaymentsPaymentIdPatch', 'paymentId', paymentId)
            // verify required parameter 'updateReceivedPaymentRequest' is not null or undefined
            assertParamExists('receivedPaymentsPaymentIdPatch', 'updateReceivedPaymentRequest', updateReceivedPaymentRequest)
            const localVarPath = `/received-payments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateReceivedPaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove Authorized Users via API
         * @summary Remove Authorized Users by Id
         * @param {string} customerId ID of the customer to remove authorized users from
         * @param {RemoveAuthorizedUsersRequest} removeAuthorizedUsersRequest Add Authorized Users Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAuthorizedUsers: async (customerId: string, removeAuthorizedUsersRequest: RemoveAuthorizedUsersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('removeAuthorizedUsers', 'customerId', customerId)
            // verify required parameter 'removeAuthorizedUsersRequest' is not null or undefined
            assertParamExists('removeAuthorizedUsers', 'removeAuthorizedUsersRequest', removeAuthorizedUsersRequest)
            const localVarPath = `/customers/{customerId}/authorized-users`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeAuthorizedUsersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reopen an Account via API 
         * @summary Reopen an Account by Id
         * @param {string} accountId ID of the account to close
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reopenAccount: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('reopenAccount', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/reopen`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Report lost as stolen via API 
         * @summary Report lost as stolen
         * @param {string} cardId ID of the card
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportCardAsLost: async (cardId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cardId' is not null or undefined
            assertParamExists('reportCardAsLost', 'cardId', cardId)
            const localVarPath = `/cards/{cardId}/report-lost`
                .replace(`{${"cardId"}}`, encodeURIComponent(String(cardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Report card as stolen via API 
         * @summary Report card as stolen
         * @param {string} cardId ID of the card
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportCardAsStolen: async (cardId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cardId' is not null or undefined
            assertParamExists('reportCardAsStolen', 'cardId', cardId)
            const localVarPath = `/cards/{cardId}/report-stolen`
                .replace(`{${"cardId"}}`, encodeURIComponent(String(cardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a Check Payment via API 
         * @summary Return Check Payment by Id
         * @param {string} checkPaymentId ID of the check payment to return
         * @param {ReturnCheckPaymentRequest} returnCheckPaymentRequest Return Check Payment Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnCheckPayment: async (checkPaymentId: string, returnCheckPaymentRequest: ReturnCheckPaymentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkPaymentId' is not null or undefined
            assertParamExists('returnCheckPayment', 'checkPaymentId', checkPaymentId)
            // verify required parameter 'returnCheckPaymentRequest' is not null or undefined
            assertParamExists('returnCheckPayment', 'returnCheckPaymentRequest', returnCheckPaymentRequest)
            const localVarPath = `/check-payments/{checkPaymentId}/return`
                .replace(`{${"checkPaymentId"}}`, encodeURIComponent(String(checkPaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(returnCheckPaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unfreeze an Account via API 
         * @summary Unfreeze Account by Id
         * @param {string} accountId ID of the account to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfreezeAccount: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('unfreezeAccount', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/unfreeze`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unfreeze a Card via API 
         * @summary Unfreeze a Card
         * @param {string} cardId ID of the card to unfreeze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfreezeCard: async (cardId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cardId' is not null or undefined
            assertParamExists('unfreezeCard', 'cardId', cardId)
            const localVarPath = `/cards/{cardId}/unfreeze`
                .replace(`{${"cardId"}}`, encodeURIComponent(String(cardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an Account via API 
         * @summary Update Account
         * @param {string} accountId ID of the account to update
         * @param {UpdateAccountRequest} updateAccountRequest Update Account Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount: async (accountId: string, updateAccountRequest: UpdateAccountRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updateAccount', 'accountId', accountId)
            // verify required parameter 'updateAccountRequest' is not null or undefined
            assertParamExists('updateAccount', 'updateAccountRequest', updateAccountRequest)
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an Application via API 
         * @summary Update Application
         * @param {string} applicationId ID of the application to update
         * @param {UpdateApplicationRequest} updateApplicationRequest Update Application Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplication: async (applicationId: string, updateApplicationRequest: UpdateApplicationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('updateApplication', 'applicationId', applicationId)
            // verify required parameter 'updateApplicationRequest' is not null or undefined
            assertParamExists('updateApplication', 'updateApplicationRequest', updateApplicationRequest)
            const localVarPath = `/applications/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateApplicationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Business Beneficial Owner
         * @summary Update a Business Beneficial Owner via API
         * @param {string} beneficialOwnerId ID of the beneficial owner to update
         * @param {UpdateBusinessBeneficialOwnerRequest} updateBusinessBeneficialOwnerRequest Update Business Beneficial Owner Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBusinessBeneficialOwner: async (beneficialOwnerId: string, updateBusinessBeneficialOwnerRequest: UpdateBusinessBeneficialOwnerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'beneficialOwnerId' is not null or undefined
            assertParamExists('updateBusinessBeneficialOwner', 'beneficialOwnerId', beneficialOwnerId)
            // verify required parameter 'updateBusinessBeneficialOwnerRequest' is not null or undefined
            assertParamExists('updateBusinessBeneficialOwner', 'updateBusinessBeneficialOwnerRequest', updateBusinessBeneficialOwnerRequest)
            const localVarPath = `/beneficial-owner/{beneficialOwnerId}`
                .replace(`{${"beneficialOwnerId"}}`, encodeURIComponent(String(beneficialOwnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateBusinessBeneficialOwnerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Card via API 
         * @summary Update Card
         * @param {string} cardId ID of the card to update
         * @param {UpdateCardRequest} updateCardRequest Update Card Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCard: async (cardId: string, updateCardRequest: UpdateCardRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cardId' is not null or undefined
            assertParamExists('updateCard', 'cardId', cardId)
            // verify required parameter 'updateCardRequest' is not null or undefined
            assertParamExists('updateCard', 'updateCardRequest', updateCardRequest)
            const localVarPath = `/cards/{cardId}`
                .replace(`{${"cardId"}}`, encodeURIComponent(String(cardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Check Deposit via API 
         * @summary Update Check Deposit
         * @param {string} checkDepositId ID of the check deposit to update
         * @param {UpdateCheckDepositRequest} updateCheckDepositRequest Update Check Deposit Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCheckDeposit: async (checkDepositId: string, updateCheckDepositRequest: UpdateCheckDepositRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkDepositId' is not null or undefined
            assertParamExists('updateCheckDeposit', 'checkDepositId', checkDepositId)
            // verify required parameter 'updateCheckDepositRequest' is not null or undefined
            assertParamExists('updateCheckDeposit', 'updateCheckDepositRequest', updateCheckDepositRequest)
            const localVarPath = `/check-deposits/{checkDepositId}`
                .replace(`{${"checkDepositId"}}`, encodeURIComponent(String(checkDepositId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCheckDepositRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Counterparty via API 
         * @summary Update Counterparty
         * @param {string} counterpartyId ID of the counterparty to update
         * @param {UpdateCounterpartyRequest} updateCounterpartyRequest Update Counterparty Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCounterparty: async (counterpartyId: string, updateCounterpartyRequest: UpdateCounterpartyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'counterpartyId' is not null or undefined
            assertParamExists('updateCounterparty', 'counterpartyId', counterpartyId)
            // verify required parameter 'updateCounterpartyRequest' is not null or undefined
            assertParamExists('updateCounterparty', 'updateCounterpartyRequest', updateCounterpartyRequest)
            const localVarPath = `/counterparties/{counterpartyId}`
                .replace(`{${"counterpartyId"}}`, encodeURIComponent(String(counterpartyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCounterpartyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an Customer via API 
         * @summary Update Customer
         * @param {string} customerId ID of the customer to update
         * @param {UpdateCustomerRequest} updateCustomerRequest Update Customer Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomer: async (customerId: string, updateCustomerRequest: UpdateCustomerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('updateCustomer', 'customerId', customerId)
            // verify required parameter 'updateCustomerRequest' is not null or undefined
            assertParamExists('updateCustomer', 'updateCustomerRequest', updateCustomerRequest)
            const localVarPath = `/customers/{customerId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCustomerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an Payment via API 
         * @summary Update Payment
         * @param {string} paymentId ID of the payment to update
         * @param {UpdatePaymentRequest} updatePaymentRequest Update Payment Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePayment: async (paymentId: string, updatePaymentRequest: UpdatePaymentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('updatePayment', 'paymentId', paymentId)
            // verify required parameter 'updatePaymentRequest' is not null or undefined
            assertParamExists('updatePayment', 'updatePaymentRequest', updatePaymentRequest)
            const localVarPath = `/payments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a stop payment
         * @param {string} stopPaymentId ID of the stop payment
         * @param {UpdateStopPaymentRequest} updateStopPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStopPayment: async (stopPaymentId: string, updateStopPaymentRequest: UpdateStopPaymentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stopPaymentId' is not null or undefined
            assertParamExists('updateStopPayment', 'stopPaymentId', stopPaymentId)
            // verify required parameter 'updateStopPaymentRequest' is not null or undefined
            assertParamExists('updateStopPayment', 'updateStopPaymentRequest', updateStopPaymentRequest)
            const localVarPath = `/stop-payments/{stopPaymentId}`
                .replace(`{${"stopPaymentId"}}`, encodeURIComponent(String(stopPaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateStopPaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Transaction via API 
         * @summary Update Transaction
         * @param {string} accountId ID of the account to update transaction from
         * @param {string} transactionId ID of the transaction to update
         * @param {UpdateTransactionRequest} updateTransactionRequest Update Transaction Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction: async (accountId: string, transactionId: string, updateTransactionRequest: UpdateTransactionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updateTransaction', 'accountId', accountId)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('updateTransaction', 'transactionId', transactionId)
            // verify required parameter 'updateTransactionRequest' is not null or undefined
            assertParamExists('updateTransaction', 'updateTransactionRequest', updateTransactionRequest)
            const localVarPath = `/accounts/{accountId}/transactions/{transactionId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTransactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Webhook via API 
         * @summary Update Webhook
         * @param {string} webhookId ID of the Webhook to update
         * @param {UpdateWebhookRequest} updateWebhookRequest Update Webhook Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook: async (webhookId: string, updateWebhookRequest: UpdateWebhookRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('updateWebhook', 'webhookId', webhookId)
            // verify required parameter 'updateWebhookRequest' is not null or undefined
            assertParamExists('updateWebhook', 'updateWebhookRequest', updateWebhookRequest)
            const localVarPath = `/webhooks/{webhookId}`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWebhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload an application document file. Supports PDF, PNG and JPG files
         * @param {string} applicationId ID of the application to upload a file to
         * @param {string} documentId ID of the document to upload a file for
         * @param {File} body An application document file. SDK only temporarily supports only ... files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadApplicationDocumentFile: async (applicationId: string, documentId: string, body: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('uploadApplicationDocumentFile', 'applicationId', applicationId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('uploadApplicationDocumentFile', 'documentId', documentId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('uploadApplicationDocumentFile', 'body', body)
            const localVarPath = `/applications/{applicationId}/documents/{documentId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/pdf';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload an application file via API - Back Side. Supports PDF, PNG and JPG files
         * @summary Upload an application document file - Back Side. Supports PDF, PNG and JPG files
         * @param {string} applicationId ID of the application to upload a file to
         * @param {string} documentId ID of the document to upload a file for
         * @param {object} body Upload an application document file - Back Side. Supports PDF, PNG and JPG files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadApplicationDocumentFileBackSide: async (applicationId: string, documentId: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('uploadApplicationDocumentFileBackSide', 'applicationId', applicationId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('uploadApplicationDocumentFileBackSide', 'documentId', documentId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('uploadApplicationDocumentFileBackSide', 'body', body)
            const localVarPath = `/applications/{applicationId}/documents/{documentId}/back`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/pdf';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify a document via API 
         * @summary Verify a document
         * @param {string} applicationId ID of the application to verify a file for
         * @param {string} documentId ID of the document to verify
         * @param {VerifyDocument} verifyDocument Verify Document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyApplicationDocument: async (applicationId: string, documentId: string, verifyDocument: VerifyDocument, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('verifyApplicationDocument', 'applicationId', applicationId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('verifyApplicationDocument', 'documentId', documentId)
            // verify required parameter 'verifyDocument' is not null or undefined
            assertParamExists('verifyApplicationDocument', 'verifyDocument', verifyDocument)
            const localVarPath = `/applications/{applicationId}/documents/{documentId}/verify`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UnitApi - functional programming interface
 * @export
 */
export const UnitApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UnitApiAxiosParamCreator(configuration)
    return {
        /**
         * Activate Control Agreement for Account via API 
         * @summary Activate Account Control Agreement by Id
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateControlAgreementForAccount(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateControlAgreementForAccount(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.activateControlAgreementForAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add Authorized Users via API
         * @summary Add Authorized Users by Id
         * @param {string} customerId ID of the customer to add authorized users to
         * @param {AddAuthorizedUsersRequest} addAuthorizedUsersRequest Add Authorized Users Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAuthorizedUsers(customerId: string, addAuthorizedUsersRequest: AddAuthorizedUsersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitCustomerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAuthorizedUsers(customerId, addAuthorizedUsersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.addAuthorizedUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Advance a Received Payment via API 
         * @summary Advance Received Payment by Id
         * @param {string} paymentId ID of the payment to advance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async advanceReceivedPayment(paymentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitReceivedPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.advanceReceivedPayment(paymentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.advanceReceivedPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Approve a Authorization Request via API 
         * @summary Approve Authorization Request by Id
         * @param {string} authorizationId ID of the authorization request to approve
         * @param {ApproveAuthorizationRequest} approveAuthorizationRequest Approve Authorization Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveAuthorizationRequest(authorizationId: string, approveAuthorizationRequest: ApproveAuthorizationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitAuthorizationRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveAuthorizationRequest(authorizationId, approveAuthorizationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.approveAuthorizationRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Approve a Check Payment via API 
         * @summary Approve Check Payment by Id
         * @param {string} checkPaymentId ID of the check payment to approve
         * @param {ApproveCheckPaymentRequest} approveCheckPaymentRequest Approve Check Payment Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveCheckPayment(checkPaymentId: string, approveCheckPaymentRequest: ApproveCheckPaymentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitCheckPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveCheckPayment(checkPaymentId, approveCheckPaymentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.approveCheckPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Archive a Customer via API 
         * @summary Archive Customer by Id
         * @param {string} customerId ID of the customer to archive
         * @param {ArchiveCustomerRequest} archiveCustomerRequest Archive Customer Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveCustomer(customerId: string, archiveCustomerRequest: ArchiveCustomerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitCustomerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archiveCustomer(customerId, archiveCustomerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.archiveCustomer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel a Application via API 
         * @summary Cancel Application by Id
         * @param {string} applicationId ID of the application to get
         * @param {CancelApplicationRequest} cancelApplicationRequest Cancel Application Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelApplication(applicationId: string, cancelApplicationRequest: CancelApplicationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitCancelApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelApplication(applicationId, cancelApplicationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.cancelApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel a Check Payment via API 
         * @summary Cancel Check Payment by Id
         * @param {string} checkPaymentId ID of the check payment to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelCheckPayment(checkPaymentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitCheckPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelCheckPayment(checkPaymentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.cancelCheckPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel a Payment via API 
         * @summary Cancel a Payment by Id
         * @param {string} paymentId ID of the payment to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelPayment(paymentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelPayment(paymentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.cancelPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Close an Account via API 
         * @summary Close an Account by Id
         * @param {string} accountId ID of the account to close
         * @param {CloseAccountRequest} closeAccountRequest Close Account Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async closeAccount(accountId: string, closeAccountRequest: CloseAccountRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.closeAccount(accountId, closeAccountRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.closeAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Close a Card via API 
         * @summary Close a Card
         * @param {string} cardId ID of the card to close
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async closeCard(cardId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitCloseCardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.closeCard(cardId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.closeCard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Confirm a Check Deposit from API 
         * @summary Confirm by Id
         * @param {string} checkDepositId ID of the check deposit to confirm
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmCheckDeposit(checkDepositId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitConfirmCheckDepositResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmCheckDeposit(checkDepositId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.confirmCheckDeposit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create Account via API 
         * @summary Create Account
         * @param {CreateAccountRequest} createAccountRequest Create Account Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(createAccountRequest: CreateAccountRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(createAccountRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.createAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an Org API Token via API 
         * @summary Create Org API Token
         * @param {string} userId ID of the user to create token for
         * @param {CreateApiTokenRequest} createApiTokenRequest Create Org API Token Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApiToken(userId: string, createApiTokenRequest: CreateApiTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitApiTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApiToken(userId, createApiTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.createApiToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an Application via API 
         * @summary Create Application
         * @param {CreateApplicationRequest} createApplicationRequest Create Application Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplication(createApplicationRequest: CreateApplicationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitCreateApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplication(createApplicationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.createApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an application document via API
         * @summary Create an application document
         * @param {string} applicationId ID of the application to create a file for
         * @param {DefaultContentType} contentType A workaround to properly assign the content type for the request body while providing no body, just set the one possible enum value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationDocument(applicationId: string, contentType: DefaultContentType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitDocumentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationDocument(applicationId, contentType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.createApplicationDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an Application Form via API 
         * @summary Create Application Form
         * @param {CreateApplicationFormRequest} createApplicationFormRequest Create Application Form Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationForm(createApplicationFormRequest: CreateApplicationFormRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitApplicationFormResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationForm(createApplicationFormRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.createApplicationForm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a Card via API 
         * @summary Create a Card
         * @param {CreateCardRequest} createCardRequest Create Card Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCard(createCardRequest: CreateCardRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitCardsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCard(createCardRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.createCard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a Check Deposit via API 
         * @summary Create Check Deposit
         * @param {CreateCheckDepositRequest} createCheckDepositRequest Create Check Deposit Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCheckDeposit(createCheckDepositRequest: CreateCheckDepositRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitListCheckDepositsResponse1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCheckDeposit(createCheckDepositRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.createCheckDeposit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create Check Payment via API 
         * @summary Create Check Payment
         * @param {CreateCheckPaymentRequest} createCheckPaymentRequest Create Check Payment Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCheckPayment(createCheckPaymentRequest: CreateCheckPaymentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitCheckPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCheckPayment(createCheckPaymentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.createCheckPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a counterparty via API 
         * @summary Create Counterparty
         * @param {CreateCounterpartyRequest} createCounterpartyRequest Create Counterparty Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCounterparty(createCounterpartyRequest: CreateCounterpartyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitCounterpartyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCounterparty(createCounterpartyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.createCounterparty']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a Customer Token via API 
         * @summary Create Customer Token
         * @param {string} customerId ID of the customer to create token for
         * @param {CreateCustomerTokenRequest} createCustomerTokenRequest Create Customer Token Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomerToken(customerId: string, createCustomerTokenRequest: CreateCustomerTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitCustomerTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomerToken(customerId, createCustomerTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.createCustomerToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a Customer Token Verification via API 
         * @summary Create Customer Token Verification
         * @param {string} customerId ID of the customer to create token for
         * @param {CreateCustomerTokenVerificationRequest} createCustomerTokenVerificationRequest Create Customer Token Verification Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomerTokenVerification(customerId: string, createCustomerTokenVerificationRequest: CreateCustomerTokenVerificationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitCustomerTokenVerificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomerTokenVerification(customerId, createCustomerTokenVerificationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.createCustomerTokenVerification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a Fee via API 
         * @summary Create Fee
         * @param {CreateFeeRequest} createFeeRequest Create Fee Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFee(createFeeRequest: CreateFeeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitFeeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFee(createFeeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.createFee']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a Payment via API 
         * @summary Create a Payment
         * @param {CreatePaymentRequest} createPaymentRequest Create Payment Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPayment(createPaymentRequest: CreatePaymentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPayment(createPaymentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.createPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a Recurring Payment via API 
         * @summary Create Recurring Payment
         * @param {CreateRecurringPaymentRequest} createRecurringPaymentRequest Create Recurring Payment Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRecurringPayment(createRecurringPaymentRequest: CreateRecurringPaymentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitRecurringPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRecurringPayment(createRecurringPaymentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.createRecurringPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a Recurring Repayment via API
         * @summary Create a Recurring Repayment
         * @param {CreateRecurringRepaymentRequest} createRecurringRepaymentRequest Create a Recurring Repayment Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRecurringRepayment(createRecurringRepaymentRequest: CreateRecurringRepaymentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitRecurringRepaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRecurringRepayment(createRecurringRepaymentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.createRecurringRepayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a Repayment via API 
         * @summary Create a Repayment
         * @param {CreateRepaymentRequest} createRepaymentRequest Create a Repayment Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRepayment(createRepaymentRequest: CreateRepaymentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitRepaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRepayment(createRepaymentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.createRepayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a Reward via API 
         * @summary Create Reward
         * @param {CreateRewardRequest} createRewardRequest Create Reward Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReward(createRewardRequest: CreateRewardRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitRewardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReward(createRewardRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.createReward']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Stop Payment
         * @param {CreateStopPaymentRequest} createStopPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStopPayment(createStopPaymentRequest: CreateStopPaymentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StopPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStopPayment(createStopPaymentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.createStopPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a Webhook via API 
         * @summary Create Webhook
         * @param {CreateWebhook} createWebhook Create Webhook Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWebhook(createWebhook: CreateWebhook, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWebhook(createWebhook, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.createWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deactivate Control Agreement for Account via API
         * @summary Deactivate Account Control Agreement by Id
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateControlAgreementForAccount(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateControlAgreementForAccount(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.deactivateControlAgreementForAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Decline Authorization Request via API 
         * @summary Decline Authorization Request
         * @param {string} authorizationId ID of the authorization request to decline
         * @param {DeclineAuthorizationRequest} declineAuthorizationRequest Decline Authorization Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async declineAuthorizationRequest(authorizationId: string, declineAuthorizationRequest: DeclineAuthorizationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitAuthorizationRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.declineAuthorizationRequest(authorizationId, declineAuthorizationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.declineAuthorizationRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete Counterparty via API 
         * @summary Delete Counterparty by Id
         * @param {string} counterpartyId ID of the counterparty to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCounterparty(counterpartyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCounterparty(counterpartyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.deleteCounterparty']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a Reward from API 
         * @summary Get Reward by Id
         * @param {string} userId ID of the user to revoke token
         * @param {string} tokenId ID of the token to revoke
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteToken(userId: string, tokenId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitApiTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteToken(userId, tokenId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.deleteToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Disable Recurring Payment via API 
         * @summary Disable Recurring Payment
         * @param {string} paymentId ID of the payment to disable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableRecurringPayment(paymentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitRecurringPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableRecurringPayment(paymentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.disableRecurringPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Disable a Recurring Repayment
         * @summary Disable Recurring Repayment by Id
         * @param {string} recurringRepaymentId ID of the recurring repayment to disable
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableRecurringRepayment(recurringRepaymentId: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitRecurringRepaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableRecurringRepayment(recurringRepaymentId, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.disableRecurringRepayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Disable a stop payment
         * @param {string} stopPaymentId ID of the stop payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableStopPayment(stopPaymentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StopPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableStopPayment(stopPaymentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.disableStopPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Disable a Webhook via API 
         * @summary Disable a Webhook
         * @param {string} webhookId ID of the webhook to disable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableWebhook(webhookId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableWebhook(webhookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.disableWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Download a Document - Back Side via API
         * @summary Download a Document - Back Side
         * @param {string} applicationId ID of the application
         * @param {string} documentId ID of the document to download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadApplicationBackSideDocument(applicationId: string, documentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadApplicationBackSideDocument(applicationId, documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.downloadApplicationBackSideDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Download a Document via API 
         * @summary Download a Document
         * @param {string} applicationId ID of the application
         * @param {string} documentId ID of the document to download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadApplicationDocument(applicationId: string, documentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadApplicationDocument(applicationId, documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.downloadApplicationDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Enable Recurring Payment via API 
         * @summary Enable Recurring Payment
         * @param {string} paymentId ID of the payment to enable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableRecurringPayment(paymentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitRecurringPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableRecurringPayment(paymentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.enableRecurringPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Enable a Recurring Repayment
         * @summary Enable Recurring Repayment by Id
         * @param {string} recurringRepaymentId ID of the recurring repayment to enable
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableRecurringRepayment(recurringRepaymentId: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitRecurringRepaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableRecurringRepayment(recurringRepaymentId, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.enableRecurringRepayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Enable a Webhook via API 
         * @summary Enable Webhook
         * @param {string} webhookId ID of the webhook to enable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableWebhook(webhookId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableWebhook(webhookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.enableWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Enter Control Agreement for Account via API 
         * @summary Enter Account Control Agreement by Id
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enterControlAgreementForAccount(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enterControlAgreementForAccount(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.enterControlAgreementForAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fire an Event via API 
         * @summary Fire Event by Id
         * @param {string} eventId ID of the event to fire
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fireEvent(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fireEvent(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.fireEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Freeze Account via API 
         * @summary Freeze Account by Id
         * @param {string} accountId ID of the account to freeze
         * @param {FreezeAccountRequest} freezeAccountRequest Freeze Account Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async freezeAccount(accountId: string, freezeAccountRequest: FreezeAccountRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.freezeAccount(accountId, freezeAccountRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.freezeAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Freeze a Card via API 
         * @summary Freeze a Card
         * @param {string} cardId ID of the card to freeze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async freezeCard(cardId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitFreezeCardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.freezeCard(cardId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.freezeCard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an Account from API 
         * @summary Get Account by Id
         * @param {string} accountId ID of the account to get
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(accountId: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitAccountResponseWithIncluded>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(accountId, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get AccountEndOfDay List from API 
         * @summary Get AccountEndOfDay List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountEndOfDay(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitGetAccountEndOfDayListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountEndOfDay(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getAccountEndOfDay']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Account Limits from API 
         * @summary Get Account Limits by Id
         * @param {string} accountId ID of the account to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountLimits(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitGetAccountLimitsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountLimits(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getAccountLimits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get List Accounts from API 
         * @summary Get List Accounts
         * @param {ListPageParameters} [page] 
         * @param {GetAccountsListFilterParameter} [filter] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountsList(page?: ListPageParameters, filter?: GetAccountsListFilterParameter, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitAccountsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountsList(page, filter, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getAccountsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get List Org API Tokens from API 
         * @summary Get List Org API Tokens
         * @param {string} userId ID of the user to revoke token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiTokensList(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitOrgApiTokensListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiTokensList(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getApiTokensList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an Application from API 
         * @summary Get Application by Id
         * @param {string} applicationId ID of the application to get
         * @param {string} [included] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplication(applicationId: string, included?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitApplicationResponseWithIncluded>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplication(applicationId, included, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get List of Documents via API 
         * @summary Get List of Documents
         * @param {string} applicationId ID of the application to get documents for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationDocuments(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitListDocumentsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationDocuments(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getApplicationDocuments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an Application Form from API 
         * @summary Get ApplicationForm by Id
         * @param {string} applicationFormId ID of the application form to get
         * @param {string} [included] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationForm(applicationFormId: string, included?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitApplicationFormResponseWithIncluded>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationForm(applicationFormId, included, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getApplicationForm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get List Application Forms from API 
         * @summary Get List Application Forms
         * @param {ListPageParameters} [page] 
         * @param {GetApplicationFormsListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationFormsList(page?: ListPageParameters, filter?: GetApplicationFormsListFilterParameter, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitApplicationFormsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationFormsList(page, filter, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getApplicationFormsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get List Applications from API 
         * @summary Get List Application
         * @param {ListPageParameters} [page] 
         * @param {GetApplicationsListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationsList(page?: ListPageParameters, filter?: GetApplicationsListFilterParameter, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitListApplicationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationsList(page, filter, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getApplicationsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get List ATM Locations from API 
         * @summary Get List of ATM Locations
         * @param {GetAtmLocationsListFilterParameter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAtmLocationsList(filter?: GetAtmLocationsListFilterParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AtmLocation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAtmLocationsList(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getAtmLocationsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a Authorization from API 
         * @summary Get Authorization by Id
         * @param {string} authorizationId ID of the authorization to get
         * @param {boolean} [includeNoneAuthorized] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthorization(authorizationId: string, includeNoneAuthorized?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitAuthorizationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthorization(authorizationId, includeNoneAuthorized, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getAuthorization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a Authorization Request from API 
         * @summary Get Authorization Request by Id
         * @param {string} authorizationId ID of the authorization request to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthorizationRequest(authorizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitAuthorizationRequestsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthorizationRequest(authorizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getAuthorizationRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get List Authorization Requests from API 
         * @summary Get List Authorization Requests
         * @param {ListPageParameters} [page] 
         * @param {GetAuthorizationRequestsListFilterParameter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthorizationRequestsList(page?: ListPageParameters, filter?: GetAuthorizationRequestsListFilterParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitListAuthorizationRequestsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthorizationRequestsList(page, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getAuthorizationRequestsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get List Authorizations from API 
         * @summary Get List authorizations
         * @param {ListPageParameters} [page] 
         * @param {GetAuthorizationsListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthorizationsList(page?: ListPageParameters, filter?: GetAuthorizationsListFilterParameter, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitListAuthorizationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthorizationsList(page, filter, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getAuthorizationsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Back Check Deposit Image from API 
         * @summary Get Back Check Deposit Image by Id
         * @param {string} checkDepositId ID of the check deposit to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBackCheckDeposit(checkDepositId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitBackCheckDepositResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBackCheckDeposit(checkDepositId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getBackCheckDeposit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a Card from API 
         * @summary Get Card by Id
         * @param {string} cardId ID of the card to get
         * @param {string} [included] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCard(cardId: string, included?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitCardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCard(cardId, included, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getCard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a Card Limits from API 
         * @summary Get Card Limit by Id
         * @param {string} cardId ID of the card to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCardLimits(cardId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitCardLimitsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCardLimits(cardId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getCardLimits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Card PIN Status via API 
         * @summary Get Card PIN Status
         * @param {string} cardId ID of the card to get PIN status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCardPinStatus(cardId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitPinStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCardPinStatus(cardId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getCardPinStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get List of Cards from API 
         * @summary Get List of Cards
         * @param {ListPageParameters} [page] 
         * @param {GetCardsListFilterParameter} [filter] 
         * @param {string} [include] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCardsList(page?: ListPageParameters, filter?: GetCardsListFilterParameter, include?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitCardResponseCardsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCardsList(page, filter, include, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getCardsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a Check Deposit from API 
         * @summary Get Check Deposit by Id
         * @param {string} checkDepositId ID of the check deposit to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCheckDeposit(checkDepositId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitCheckDepositResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCheckDeposit(checkDepositId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getCheckDeposit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get List Check Deposits from API 
         * @summary Get List Check Deposits
         * @param {ListPageParameters} [page] 
         * @param {GetCheckDepositsListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCheckDepositsList(page?: ListPageParameters, filter?: GetCheckDepositsListFilterParameter, sort?: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitListCheckDepositsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCheckDepositsList(page, filter, sort, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getCheckDepositsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a Check Payment from API 
         * @summary Get Check Payment by Id
         * @param {string} checkPaymentId ID of the check payment to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCheckPayment(checkPaymentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitCheckPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCheckPayment(checkPaymentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getCheckPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get back image via API 
         * @summary Get back image
         * @param {string} checkPaymentId ID of the check payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCheckPaymentBack(checkPaymentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCheckPaymentBack(checkPaymentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getCheckPaymentBack']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get front image via API 
         * @summary Get front image
         * @param {string} checkPaymentId ID of the check payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCheckPaymentFront(checkPaymentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCheckPaymentFront(checkPaymentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getCheckPaymentFront']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get List Check Payments from API 
         * @summary Get List Check Payments
         * @param {ListPageParameters} [page] 
         * @param {GetCheckPaymentsListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCheckPaymentsList(page?: ListPageParameters, filter?: GetCheckPaymentsListFilterParameter, sort?: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitListCheckPaymentsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCheckPaymentsList(page, filter, sort, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getCheckPaymentsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Counterparties List from API 
         * @summary Get Counterparties List
         * @param {ListPageParameters} [page] 
         * @param {GetCounterpartiesListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCounterpartiesList(page?: ListPageParameters, filter?: GetCounterpartiesListFilterParameter, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitCounterpartiesListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCounterpartiesList(page, filter, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getCounterpartiesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a Counterparty from API 
         * @summary Get Counterparty by Id
         * @param {string} counterpartyId ID of the counterparty to get
         * @param {string} [included] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCounterparty(counterpartyId: string, included?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitCounterpartyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCounterparty(counterpartyId, included, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getCounterparty']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Recurring Payment from API 
         * @summary Get Counterparty Balance
         * @param {string} counterpartyId ID of the counterparty to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCounterpartyBalance(counterpartyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitCounterpartyResponse1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCounterpartyBalance(counterpartyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getCounterpartyBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a Customer from API 
         * @summary Get Customer by Id
         * @param {string} customerId ID of the customer to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomer(customerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitCustomerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomer(customerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getCustomer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Customers List from API 
         * @summary Get Customers List
         * @param {ListPageParameters} [page] 
         * @param {GetCustomersListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomersList(page?: ListPageParameters, filter?: GetCustomersListFilterParameter, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitCustomersListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomersList(page, filter, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getCustomersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a Dispute from API 
         * @summary Get Dispute by Id
         * @param {string} disputeId ID of the dispute to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDispute(disputeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitDisputeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDispute(disputeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getDispute']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get List Disputes from API 
         * @summary Get List Disputes
         * @param {ListPageParameters} [page] 
         * @param {GetDisputesListFilterParameter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDisputesList(page?: ListPageParameters, filter?: GetDisputesListFilterParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dispute>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDisputesList(page, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getDisputesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an Event from API 
         * @summary Get Event by Id
         * @param {string} eventId ID of the event to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvent(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvent(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Events List from API 
         * @summary Get Events List
         * @param {ListPageParameters} [page] 
         * @param {GetEventsListFilterParameter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventsList(page?: ListPageParameters, filter?: GetEventsListFilterParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitEventListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventsList(page, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getEventsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Front Check Deposit Image from API 
         * @summary Get Front Check Deposit Image by Id
         * @param {string} checkDepositId ID of the check deposit to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFrontCheckDeposit(checkDepositId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitFrontCheckDepositResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFrontCheckDeposit(checkDepositId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getFrontCheckDeposit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an Institution from API 
         * @summary Get Institution by Routing Number
         * @param {string} routingNumber routingNumber of the institution to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstitution(routingNumber: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitInstitutionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInstitution(routingNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getInstitution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Rewards List from API 
         * @summary Get Rewards List
         * @param {ListPageParameters} [page] 
         * @param {GetListRewardsFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListRewards(page?: ListPageParameters, filter?: GetListRewardsFilterParameter, sort?: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitRewardsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListRewards(page, filter, sort, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getListRewards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a Payment from API 
         * @summary Get Payment by Id
         * @param {string} paymentId ID of the payment to get
         * @param {string} [included] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayment(paymentId: string, included?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitPaymentResponseWithIncluded>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayment(paymentId, included, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get List Payments from API 
         * @summary Get List Payments
         * @param {ListPageParameters} [page] 
         * @param {GetPaymentsListFilterParameter} [filter] 
         * @param {string} [include] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentsList(page?: ListPageParameters, filter?: GetPaymentsListFilterParameter, include?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitPaymentsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentsList(page, filter, include, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getPaymentsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a Received Payment from API 
         * @summary Get Received Payment by Id
         * @param {string} paymentId ID of the payment to get
         * @param {string} [included] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReceivedPayment(paymentId: string, included?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitReceivedPaymentResponseWithIncluded>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReceivedPayment(paymentId, included, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getReceivedPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Received Payments from API 
         * @summary Get Received Payments List
         * @param {string} [included] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReceivedPaymentsList(included?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitReceivedPaymentListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReceivedPaymentsList(included, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getReceivedPaymentsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Recurring Payment from API 
         * @summary Get Recurring Payment
         * @param {string} paymentId ID of the payment to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecurringPayment(paymentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitRecurringPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecurringPayment(paymentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getRecurringPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Recurring Payments List from API 
         * @summary Get Recurring Payments List
         * @param {ListPageParameters} [page] 
         * @param {GetRecurringPaymentsListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecurringPaymentsList(page?: ListPageParameters, filter?: GetRecurringPaymentsListFilterParameter, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitRecurringPaymentListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecurringPaymentsList(page, filter, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getRecurringPaymentsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a Recurring Repayment from API 
         * @summary Get Recurring Repayment by Id
         * @param {string} recurringRepaymentId ID of the recurring repayment to get
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecurringRepayment(recurringRepaymentId: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitRecurringRepaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecurringRepayment(recurringRepaymentId, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getRecurringRepayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get List Recurring Repayments from API 
         * @summary Get List Recurring Repayments
         * @param {ListPageParameters} [page] 
         * @param {GetRecurringRepaymentsListFilterParameter} [filter] 
         * @param {GetRecurringRepaymentsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecurringRepaymentsList(page?: ListPageParameters, filter?: GetRecurringRepaymentsListFilterParameter, sort?: GetRecurringRepaymentsListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitRecurringRepaymentsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecurringRepaymentsList(page, filter, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getRecurringRepaymentsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an Repayment from API 
         * @summary Get Repayment by Id
         * @param {string} repaymentId ID of the repayment to get
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepayment(repaymentId: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitRepaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepayment(repaymentId, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getRepayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get List Repayments from API 
         * @summary Get List Repayments
         * @param {ListPageParameters} [page] 
         * @param {GetRepaymentsListFilterParameter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepaymentsList(page?: ListPageParameters, filter?: GetRepaymentsListFilterParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitRepaymentsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepaymentsList(page, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getRepaymentsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a Reward from API 
         * @summary Get Reward by Id
         * @param {string} rewardId ID of the reward to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReward(rewardId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitRewardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReward(rewardId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getReward']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Get Bank verification PDF from API 
         * @summary Get Bank verification PDF
         * @param {string} accountId ID of the account to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatementBankPdf(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatementBankPdf(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getStatementBankPdf']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a HTML Statement from API 
         * @summary Get HTML Statement by Id
         * @param {string} statementId ID of the statement to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatementHtml(statementId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatementHtml(statementId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getStatementHtml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a PDF Statement from API 
         * @summary Get PDF Statement by Id
         * @param {string} statementId ID of the statement to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatementPdf(statementId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatementPdf(statementId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getStatementPdf']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get List Statements from API 
         * @summary Get List Statements
         * @param {ListPageParameters} [page] 
         * @param {GetStatementsListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatementsList(page?: ListPageParameters, filter?: GetStatementsListFilterParameter, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitStatementsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatementsList(page, filter, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getStatementsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get details of a specific stop payment
         * @param {string} stopPaymentId ID of the stop payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStopPayment(stopPaymentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StopPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStopPayment(stopPaymentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getStopPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of stop payments
         * @param {ListPageParameters} [page] 
         * @param {GetStopPaymentsListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStopPaymentsList(page?: ListPageParameters, filter?: GetStopPaymentsListFilterParameter, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StopPaymentListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStopPaymentsList(page, filter, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getStopPaymentsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a Transaction from API 
         * @summary Get Transaction by Id
         * @param {string} accountId ID of the account to get transaction from
         * @param {string} transactionId ID of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransaction(accountId: string, transactionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitTransactionResponseWithIncludedResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransaction(accountId, transactionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get List Transactions from API 
         * @summary Get List Transactions
         * @param {ListPageParameters} [page] 
         * @param {GetTransactionsListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionsList(page?: ListPageParameters, filter?: GetTransactionsListFilterParameter, sort?: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitTransactionsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionsList(page, filter, sort, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getTransactionsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a Webhook from API 
         * @summary Get Webhook Id
         * @param {string} webhookId ID of the webhook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhook(webhookId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhook(webhookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get List Webhooks from API 
         * @summary Get List Webhooks
         * @param {ListPageParameters} [page] 
         * @param {GetWebhooksListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhooksList(page?: ListPageParameters, filter?: GetWebhooksListFilterParameter, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitWebhooksListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhooksList(page, filter, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getWebhooksList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a Received Payment via API 
         * @summary Update Received Payment
         * @param {string} paymentId ID of the payment to update
         * @param {UpdateReceivedPaymentRequest} updateReceivedPaymentRequest Update Received Payment Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async receivedPaymentsPaymentIdPatch(paymentId: string, updateReceivedPaymentRequest: UpdateReceivedPaymentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitReceivedPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.receivedPaymentsPaymentIdPatch(paymentId, updateReceivedPaymentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.receivedPaymentsPaymentIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove Authorized Users via API
         * @summary Remove Authorized Users by Id
         * @param {string} customerId ID of the customer to remove authorized users from
         * @param {RemoveAuthorizedUsersRequest} removeAuthorizedUsersRequest Add Authorized Users Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAuthorizedUsers(customerId: string, removeAuthorizedUsersRequest: RemoveAuthorizedUsersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitCustomerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAuthorizedUsers(customerId, removeAuthorizedUsersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.removeAuthorizedUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reopen an Account via API 
         * @summary Reopen an Account by Id
         * @param {string} accountId ID of the account to close
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reopenAccount(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reopenAccount(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.reopenAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Report lost as stolen via API 
         * @summary Report lost as stolen
         * @param {string} cardId ID of the card
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportCardAsLost(cardId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitReportLostCardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportCardAsLost(cardId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.reportCardAsLost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Report card as stolen via API 
         * @summary Report card as stolen
         * @param {string} cardId ID of the card
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportCardAsStolen(cardId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitReportStolenCardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportCardAsStolen(cardId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.reportCardAsStolen']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a Check Payment via API 
         * @summary Return Check Payment by Id
         * @param {string} checkPaymentId ID of the check payment to return
         * @param {ReturnCheckPaymentRequest} returnCheckPaymentRequest Return Check Payment Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async returnCheckPayment(checkPaymentId: string, returnCheckPaymentRequest: ReturnCheckPaymentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitCheckPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.returnCheckPayment(checkPaymentId, returnCheckPaymentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.returnCheckPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unfreeze an Account via API 
         * @summary Unfreeze Account by Id
         * @param {string} accountId ID of the account to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unfreezeAccount(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unfreezeAccount(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.unfreezeAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unfreeze a Card via API 
         * @summary Unfreeze a Card
         * @param {string} cardId ID of the card to unfreeze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unfreezeCard(cardId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitUnfreezeCardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unfreezeCard(cardId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.unfreezeCard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an Account via API 
         * @summary Update Account
         * @param {string} accountId ID of the account to update
         * @param {UpdateAccountRequest} updateAccountRequest Update Account Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccount(accountId: string, updateAccountRequest: UpdateAccountRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccount(accountId, updateAccountRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.updateAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an Application via API 
         * @summary Update Application
         * @param {string} applicationId ID of the application to update
         * @param {UpdateApplicationRequest} updateApplicationRequest Update Application Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateApplication(applicationId: string, updateApplicationRequest: UpdateApplicationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitApplicationResponseWithIncluded>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateApplication(applicationId, updateApplicationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.updateApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a Business Beneficial Owner
         * @summary Update a Business Beneficial Owner via API
         * @param {string} beneficialOwnerId ID of the beneficial owner to update
         * @param {UpdateBusinessBeneficialOwnerRequest} updateBusinessBeneficialOwnerRequest Update Business Beneficial Owner Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBusinessBeneficialOwner(beneficialOwnerId: string, updateBusinessBeneficialOwnerRequest: UpdateBusinessBeneficialOwnerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitBeneficialOwnerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBusinessBeneficialOwner(beneficialOwnerId, updateBusinessBeneficialOwnerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.updateBusinessBeneficialOwner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a Card via API 
         * @summary Update Card
         * @param {string} cardId ID of the card to update
         * @param {UpdateCardRequest} updateCardRequest Update Card Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCard(cardId: string, updateCardRequest: UpdateCardRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitUpdateCardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCard(cardId, updateCardRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.updateCard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a Check Deposit via API 
         * @summary Update Check Deposit
         * @param {string} checkDepositId ID of the check deposit to update
         * @param {UpdateCheckDepositRequest} updateCheckDepositRequest Update Check Deposit Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCheckDeposit(checkDepositId: string, updateCheckDepositRequest: UpdateCheckDepositRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitUpdateCheckDepositResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCheckDeposit(checkDepositId, updateCheckDepositRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.updateCheckDeposit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a Counterparty via API 
         * @summary Update Counterparty
         * @param {string} counterpartyId ID of the counterparty to update
         * @param {UpdateCounterpartyRequest} updateCounterpartyRequest Update Counterparty Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCounterparty(counterpartyId: string, updateCounterpartyRequest: UpdateCounterpartyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitCounterpartyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCounterparty(counterpartyId, updateCounterpartyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.updateCounterparty']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an Customer via API 
         * @summary Update Customer
         * @param {string} customerId ID of the customer to update
         * @param {UpdateCustomerRequest} updateCustomerRequest Update Customer Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomer(customerId: string, updateCustomerRequest: UpdateCustomerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitCustomerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomer(customerId, updateCustomerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.updateCustomer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an Payment via API 
         * @summary Update Payment
         * @param {string} paymentId ID of the payment to update
         * @param {UpdatePaymentRequest} updatePaymentRequest Update Payment Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePayment(paymentId: string, updatePaymentRequest: UpdatePaymentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePayment(paymentId, updatePaymentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.updatePayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a stop payment
         * @param {string} stopPaymentId ID of the stop payment
         * @param {UpdateStopPaymentRequest} updateStopPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStopPayment(stopPaymentId: string, updateStopPaymentRequest: UpdateStopPaymentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StopPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStopPayment(stopPaymentId, updateStopPaymentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.updateStopPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a Transaction via API 
         * @summary Update Transaction
         * @param {string} accountId ID of the account to update transaction from
         * @param {string} transactionId ID of the transaction to update
         * @param {UpdateTransactionRequest} updateTransactionRequest Update Transaction Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTransaction(accountId: string, transactionId: string, updateTransactionRequest: UpdateTransactionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTransaction(accountId, transactionId, updateTransactionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.updateTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a Webhook via API 
         * @summary Update Webhook
         * @param {string} webhookId ID of the Webhook to update
         * @param {UpdateWebhookRequest} updateWebhookRequest Update Webhook Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWebhook(webhookId: string, updateWebhookRequest: UpdateWebhookRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhook(webhookId, updateWebhookRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.updateWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload an application document file. Supports PDF, PNG and JPG files
         * @param {string} applicationId ID of the application to upload a file to
         * @param {string} documentId ID of the document to upload a file for
         * @param {File} body An application document file. SDK only temporarily supports only ... files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadApplicationDocumentFile(applicationId: string, documentId: string, body: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitDocumentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadApplicationDocumentFile(applicationId, documentId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.uploadApplicationDocumentFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload an application file via API - Back Side. Supports PDF, PNG and JPG files
         * @summary Upload an application document file - Back Side. Supports PDF, PNG and JPG files
         * @param {string} applicationId ID of the application to upload a file to
         * @param {string} documentId ID of the document to upload a file for
         * @param {object} body Upload an application document file - Back Side. Supports PDF, PNG and JPG files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadApplicationDocumentFileBackSide(applicationId: string, documentId: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitDocumentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadApplicationDocumentFileBackSide(applicationId, documentId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.uploadApplicationDocumentFileBackSide']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verify a document via API 
         * @summary Verify a document
         * @param {string} applicationId ID of the application to verify a file for
         * @param {string} documentId ID of the document to verify
         * @param {VerifyDocument} verifyDocument Verify Document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyApplicationDocument(applicationId: string, documentId: string, verifyDocument: VerifyDocument, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitDocumentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyApplicationDocument(applicationId, documentId, verifyDocument, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.verifyApplicationDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UnitApi - factory interface
 * @export
 */
export const UnitApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UnitApiFp(configuration)
    return {
        /**
         * Activate Control Agreement for Account via API 
         * @summary Activate Account Control Agreement by Id
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateControlAgreementForAccount(accountId: string, options?: any): AxiosPromise<UnitAccountResponse> {
            return localVarFp.activateControlAgreementForAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Add Authorized Users via API
         * @summary Add Authorized Users by Id
         * @param {string} customerId ID of the customer to add authorized users to
         * @param {AddAuthorizedUsersRequest} addAuthorizedUsersRequest Add Authorized Users Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAuthorizedUsers(customerId: string, addAuthorizedUsersRequest: AddAuthorizedUsersRequest, options?: any): AxiosPromise<UnitCustomerResponse> {
            return localVarFp.addAuthorizedUsers(customerId, addAuthorizedUsersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Advance a Received Payment via API 
         * @summary Advance Received Payment by Id
         * @param {string} paymentId ID of the payment to advance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advanceReceivedPayment(paymentId: string, options?: any): AxiosPromise<UnitReceivedPaymentResponse> {
            return localVarFp.advanceReceivedPayment(paymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Approve a Authorization Request via API 
         * @summary Approve Authorization Request by Id
         * @param {string} authorizationId ID of the authorization request to approve
         * @param {ApproveAuthorizationRequest} approveAuthorizationRequest Approve Authorization Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveAuthorizationRequest(authorizationId: string, approveAuthorizationRequest: ApproveAuthorizationRequest, options?: any): AxiosPromise<UnitAuthorizationRequestResponse> {
            return localVarFp.approveAuthorizationRequest(authorizationId, approveAuthorizationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Approve a Check Payment via API 
         * @summary Approve Check Payment by Id
         * @param {string} checkPaymentId ID of the check payment to approve
         * @param {ApproveCheckPaymentRequest} approveCheckPaymentRequest Approve Check Payment Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveCheckPayment(checkPaymentId: string, approveCheckPaymentRequest: ApproveCheckPaymentRequest, options?: any): AxiosPromise<UnitCheckPaymentResponse> {
            return localVarFp.approveCheckPayment(checkPaymentId, approveCheckPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Archive a Customer via API 
         * @summary Archive Customer by Id
         * @param {string} customerId ID of the customer to archive
         * @param {ArchiveCustomerRequest} archiveCustomerRequest Archive Customer Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveCustomer(customerId: string, archiveCustomerRequest: ArchiveCustomerRequest, options?: any): AxiosPromise<UnitCustomerResponse> {
            return localVarFp.archiveCustomer(customerId, archiveCustomerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel a Application via API 
         * @summary Cancel Application by Id
         * @param {string} applicationId ID of the application to get
         * @param {CancelApplicationRequest} cancelApplicationRequest Cancel Application Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelApplication(applicationId: string, cancelApplicationRequest: CancelApplicationRequest, options?: any): AxiosPromise<UnitCancelApplicationResponse> {
            return localVarFp.cancelApplication(applicationId, cancelApplicationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel a Check Payment via API 
         * @summary Cancel Check Payment by Id
         * @param {string} checkPaymentId ID of the check payment to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelCheckPayment(checkPaymentId: string, options?: any): AxiosPromise<UnitCheckPaymentResponse> {
            return localVarFp.cancelCheckPayment(checkPaymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel a Payment via API 
         * @summary Cancel a Payment by Id
         * @param {string} paymentId ID of the payment to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPayment(paymentId: string, options?: any): AxiosPromise<UnitPaymentResponse> {
            return localVarFp.cancelPayment(paymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Close an Account via API 
         * @summary Close an Account by Id
         * @param {string} accountId ID of the account to close
         * @param {CloseAccountRequest} closeAccountRequest Close Account Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeAccount(accountId: string, closeAccountRequest: CloseAccountRequest, options?: any): AxiosPromise<UnitAccountResponse> {
            return localVarFp.closeAccount(accountId, closeAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Close a Card via API 
         * @summary Close a Card
         * @param {string} cardId ID of the card to close
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeCard(cardId: string, options?: any): AxiosPromise<UnitCloseCardResponse> {
            return localVarFp.closeCard(cardId, options).then((request) => request(axios, basePath));
        },
        /**
         * Confirm a Check Deposit from API 
         * @summary Confirm by Id
         * @param {string} checkDepositId ID of the check deposit to confirm
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmCheckDeposit(checkDepositId: string, options?: any): AxiosPromise<UnitConfirmCheckDepositResponse> {
            return localVarFp.confirmCheckDeposit(checkDepositId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create Account via API 
         * @summary Create Account
         * @param {CreateAccountRequest} createAccountRequest Create Account Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(createAccountRequest: CreateAccountRequest, options?: any): AxiosPromise<UnitAccountResponse> {
            return localVarFp.createAccount(createAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an Org API Token via API 
         * @summary Create Org API Token
         * @param {string} userId ID of the user to create token for
         * @param {CreateApiTokenRequest} createApiTokenRequest Create Org API Token Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiToken(userId: string, createApiTokenRequest: CreateApiTokenRequest, options?: any): AxiosPromise<UnitApiTokenResponse> {
            return localVarFp.createApiToken(userId, createApiTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an Application via API 
         * @summary Create Application
         * @param {CreateApplicationRequest} createApplicationRequest Create Application Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication(createApplicationRequest: CreateApplicationRequest, options?: any): AxiosPromise<UnitCreateApplicationResponse> {
            return localVarFp.createApplication(createApplicationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an application document via API
         * @summary Create an application document
         * @param {string} applicationId ID of the application to create a file for
         * @param {DefaultContentType} contentType A workaround to properly assign the content type for the request body while providing no body, just set the one possible enum value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationDocument(applicationId: string, contentType: DefaultContentType, options?: any): AxiosPromise<UnitDocumentResponse> {
            return localVarFp.createApplicationDocument(applicationId, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an Application Form via API 
         * @summary Create Application Form
         * @param {CreateApplicationFormRequest} createApplicationFormRequest Create Application Form Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationForm(createApplicationFormRequest: CreateApplicationFormRequest, options?: any): AxiosPromise<UnitApplicationFormResponse> {
            return localVarFp.createApplicationForm(createApplicationFormRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Card via API 
         * @summary Create a Card
         * @param {CreateCardRequest} createCardRequest Create Card Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCard(createCardRequest: CreateCardRequest, options?: any): AxiosPromise<UnitCardsListResponse> {
            return localVarFp.createCard(createCardRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Check Deposit via API 
         * @summary Create Check Deposit
         * @param {CreateCheckDepositRequest} createCheckDepositRequest Create Check Deposit Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckDeposit(createCheckDepositRequest: CreateCheckDepositRequest, options?: any): AxiosPromise<UnitListCheckDepositsResponse1> {
            return localVarFp.createCheckDeposit(createCheckDepositRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create Check Payment via API 
         * @summary Create Check Payment
         * @param {CreateCheckPaymentRequest} createCheckPaymentRequest Create Check Payment Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckPayment(createCheckPaymentRequest: CreateCheckPaymentRequest, options?: any): AxiosPromise<UnitCheckPaymentResponse> {
            return localVarFp.createCheckPayment(createCheckPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a counterparty via API 
         * @summary Create Counterparty
         * @param {CreateCounterpartyRequest} createCounterpartyRequest Create Counterparty Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCounterparty(createCounterpartyRequest: CreateCounterpartyRequest, options?: any): AxiosPromise<UnitCounterpartyResponse> {
            return localVarFp.createCounterparty(createCounterpartyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Customer Token via API 
         * @summary Create Customer Token
         * @param {string} customerId ID of the customer to create token for
         * @param {CreateCustomerTokenRequest} createCustomerTokenRequest Create Customer Token Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerToken(customerId: string, createCustomerTokenRequest: CreateCustomerTokenRequest, options?: any): AxiosPromise<UnitCustomerTokenResponse> {
            return localVarFp.createCustomerToken(customerId, createCustomerTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Customer Token Verification via API 
         * @summary Create Customer Token Verification
         * @param {string} customerId ID of the customer to create token for
         * @param {CreateCustomerTokenVerificationRequest} createCustomerTokenVerificationRequest Create Customer Token Verification Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerTokenVerification(customerId: string, createCustomerTokenVerificationRequest: CreateCustomerTokenVerificationRequest, options?: any): AxiosPromise<UnitCustomerTokenVerificationResponse> {
            return localVarFp.createCustomerTokenVerification(customerId, createCustomerTokenVerificationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Fee via API 
         * @summary Create Fee
         * @param {CreateFeeRequest} createFeeRequest Create Fee Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFee(createFeeRequest: CreateFeeRequest, options?: any): AxiosPromise<UnitFeeResponse> {
            return localVarFp.createFee(createFeeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Payment via API 
         * @summary Create a Payment
         * @param {CreatePaymentRequest} createPaymentRequest Create Payment Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayment(createPaymentRequest: CreatePaymentRequest, options?: any): AxiosPromise<UnitPaymentResponse> {
            return localVarFp.createPayment(createPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Recurring Payment via API 
         * @summary Create Recurring Payment
         * @param {CreateRecurringPaymentRequest} createRecurringPaymentRequest Create Recurring Payment Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecurringPayment(createRecurringPaymentRequest: CreateRecurringPaymentRequest, options?: any): AxiosPromise<UnitRecurringPaymentResponse> {
            return localVarFp.createRecurringPayment(createRecurringPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Recurring Repayment via API
         * @summary Create a Recurring Repayment
         * @param {CreateRecurringRepaymentRequest} createRecurringRepaymentRequest Create a Recurring Repayment Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecurringRepayment(createRecurringRepaymentRequest: CreateRecurringRepaymentRequest, options?: any): AxiosPromise<UnitRecurringRepaymentResponse> {
            return localVarFp.createRecurringRepayment(createRecurringRepaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Repayment via API 
         * @summary Create a Repayment
         * @param {CreateRepaymentRequest} createRepaymentRequest Create a Repayment Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepayment(createRepaymentRequest: CreateRepaymentRequest, options?: any): AxiosPromise<UnitRepaymentResponse> {
            return localVarFp.createRepayment(createRepaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Reward via API 
         * @summary Create Reward
         * @param {CreateRewardRequest} createRewardRequest Create Reward Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReward(createRewardRequest: CreateRewardRequest, options?: any): AxiosPromise<UnitRewardResponse> {
            return localVarFp.createReward(createRewardRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Stop Payment
         * @param {CreateStopPaymentRequest} createStopPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStopPayment(createStopPaymentRequest: CreateStopPaymentRequest, options?: any): AxiosPromise<StopPaymentResponse> {
            return localVarFp.createStopPayment(createStopPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Webhook via API 
         * @summary Create Webhook
         * @param {CreateWebhook} createWebhook Create Webhook Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(createWebhook: CreateWebhook, options?: any): AxiosPromise<WebhookResponse> {
            return localVarFp.createWebhook(createWebhook, options).then((request) => request(axios, basePath));
        },
        /**
         * Deactivate Control Agreement for Account via API
         * @summary Deactivate Account Control Agreement by Id
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateControlAgreementForAccount(accountId: string, options?: any): AxiosPromise<UnitAccountResponse> {
            return localVarFp.deactivateControlAgreementForAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Decline Authorization Request via API 
         * @summary Decline Authorization Request
         * @param {string} authorizationId ID of the authorization request to decline
         * @param {DeclineAuthorizationRequest} declineAuthorizationRequest Decline Authorization Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        declineAuthorizationRequest(authorizationId: string, declineAuthorizationRequest: DeclineAuthorizationRequest, options?: any): AxiosPromise<UnitAuthorizationRequestResponse> {
            return localVarFp.declineAuthorizationRequest(authorizationId, declineAuthorizationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Counterparty via API 
         * @summary Delete Counterparty by Id
         * @param {string} counterpartyId ID of the counterparty to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCounterparty(counterpartyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCounterparty(counterpartyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Reward from API 
         * @summary Get Reward by Id
         * @param {string} userId ID of the user to revoke token
         * @param {string} tokenId ID of the token to revoke
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken(userId: string, tokenId: string, options?: any): AxiosPromise<UnitApiTokenResponse> {
            return localVarFp.deleteToken(userId, tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * Disable Recurring Payment via API 
         * @summary Disable Recurring Payment
         * @param {string} paymentId ID of the payment to disable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableRecurringPayment(paymentId: string, options?: any): AxiosPromise<UnitRecurringPaymentResponse> {
            return localVarFp.disableRecurringPayment(paymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Disable a Recurring Repayment
         * @summary Disable Recurring Repayment by Id
         * @param {string} recurringRepaymentId ID of the recurring repayment to disable
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableRecurringRepayment(recurringRepaymentId: string, include?: string, options?: any): AxiosPromise<UnitRecurringRepaymentResponse> {
            return localVarFp.disableRecurringRepayment(recurringRepaymentId, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Disable a stop payment
         * @param {string} stopPaymentId ID of the stop payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableStopPayment(stopPaymentId: string, options?: any): AxiosPromise<StopPaymentResponse> {
            return localVarFp.disableStopPayment(stopPaymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Disable a Webhook via API 
         * @summary Disable a Webhook
         * @param {string} webhookId ID of the webhook to disable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableWebhook(webhookId: string, options?: any): AxiosPromise<WebhookResponse> {
            return localVarFp.disableWebhook(webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * Download a Document - Back Side via API
         * @summary Download a Document - Back Side
         * @param {string} applicationId ID of the application
         * @param {string} documentId ID of the document to download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadApplicationBackSideDocument(applicationId: string, documentId: string, options?: any): AxiosPromise<File> {
            return localVarFp.downloadApplicationBackSideDocument(applicationId, documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Download a Document via API 
         * @summary Download a Document
         * @param {string} applicationId ID of the application
         * @param {string} documentId ID of the document to download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadApplicationDocument(applicationId: string, documentId: string, options?: any): AxiosPromise<File> {
            return localVarFp.downloadApplicationDocument(applicationId, documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable Recurring Payment via API 
         * @summary Enable Recurring Payment
         * @param {string} paymentId ID of the payment to enable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableRecurringPayment(paymentId: string, options?: any): AxiosPromise<UnitRecurringPaymentResponse> {
            return localVarFp.enableRecurringPayment(paymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable a Recurring Repayment
         * @summary Enable Recurring Repayment by Id
         * @param {string} recurringRepaymentId ID of the recurring repayment to enable
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableRecurringRepayment(recurringRepaymentId: string, include?: string, options?: any): AxiosPromise<UnitRecurringRepaymentResponse> {
            return localVarFp.enableRecurringRepayment(recurringRepaymentId, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable a Webhook via API 
         * @summary Enable Webhook
         * @param {string} webhookId ID of the webhook to enable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableWebhook(webhookId: string, options?: any): AxiosPromise<WebhookResponse> {
            return localVarFp.enableWebhook(webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * Enter Control Agreement for Account via API 
         * @summary Enter Account Control Agreement by Id
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enterControlAgreementForAccount(accountId: string, options?: any): AxiosPromise<UnitAccountResponse> {
            return localVarFp.enterControlAgreementForAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fire an Event via API 
         * @summary Fire Event by Id
         * @param {string} eventId ID of the event to fire
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fireEvent(eventId: string, options?: any): AxiosPromise<UnitEventResponse> {
            return localVarFp.fireEvent(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Freeze Account via API 
         * @summary Freeze Account by Id
         * @param {string} accountId ID of the account to freeze
         * @param {FreezeAccountRequest} freezeAccountRequest Freeze Account Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        freezeAccount(accountId: string, freezeAccountRequest: FreezeAccountRequest, options?: any): AxiosPromise<UnitAccountResponse> {
            return localVarFp.freezeAccount(accountId, freezeAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Freeze a Card via API 
         * @summary Freeze a Card
         * @param {string} cardId ID of the card to freeze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        freezeCard(cardId: string, options?: any): AxiosPromise<UnitFreezeCardResponse> {
            return localVarFp.freezeCard(cardId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an Account from API 
         * @summary Get Account by Id
         * @param {string} accountId ID of the account to get
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(accountId: string, include?: string, options?: any): AxiosPromise<UnitAccountResponseWithIncluded> {
            return localVarFp.getAccount(accountId, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Get AccountEndOfDay List from API 
         * @summary Get AccountEndOfDay List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountEndOfDay(options?: any): AxiosPromise<UnitGetAccountEndOfDayListResponse> {
            return localVarFp.getAccountEndOfDay(options).then((request) => request(axios, basePath));
        },
        /**
         * Get Account Limits from API 
         * @summary Get Account Limits by Id
         * @param {string} accountId ID of the account to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountLimits(accountId: string, options?: any): AxiosPromise<UnitGetAccountLimitsResponse> {
            return localVarFp.getAccountLimits(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get List Accounts from API 
         * @summary Get List Accounts
         * @param {ListPageParameters} [page] 
         * @param {GetAccountsListFilterParameter} [filter] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsList(page?: ListPageParameters, filter?: GetAccountsListFilterParameter, include?: string, options?: any): AxiosPromise<UnitAccountsListResponse> {
            return localVarFp.getAccountsList(page, filter, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Get List Org API Tokens from API 
         * @summary Get List Org API Tokens
         * @param {string} userId ID of the user to revoke token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiTokensList(userId: string, options?: any): AxiosPromise<UnitOrgApiTokensListResponse> {
            return localVarFp.getApiTokensList(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an Application from API 
         * @summary Get Application by Id
         * @param {string} applicationId ID of the application to get
         * @param {string} [included] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication(applicationId: string, included?: string, options?: any): AxiosPromise<UnitApplicationResponseWithIncluded> {
            return localVarFp.getApplication(applicationId, included, options).then((request) => request(axios, basePath));
        },
        /**
         * Get List of Documents via API 
         * @summary Get List of Documents
         * @param {string} applicationId ID of the application to get documents for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationDocuments(applicationId: string, options?: any): AxiosPromise<UnitListDocumentsResponse> {
            return localVarFp.getApplicationDocuments(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an Application Form from API 
         * @summary Get ApplicationForm by Id
         * @param {string} applicationFormId ID of the application form to get
         * @param {string} [included] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationForm(applicationFormId: string, included?: string, options?: any): AxiosPromise<UnitApplicationFormResponseWithIncluded> {
            return localVarFp.getApplicationForm(applicationFormId, included, options).then((request) => request(axios, basePath));
        },
        /**
         * Get List Application Forms from API 
         * @summary Get List Application Forms
         * @param {ListPageParameters} [page] 
         * @param {GetApplicationFormsListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationFormsList(page?: ListPageParameters, filter?: GetApplicationFormsListFilterParameter, sort?: string, options?: any): AxiosPromise<UnitApplicationFormsListResponse> {
            return localVarFp.getApplicationFormsList(page, filter, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get List Applications from API 
         * @summary Get List Application
         * @param {ListPageParameters} [page] 
         * @param {GetApplicationsListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationsList(page?: ListPageParameters, filter?: GetApplicationsListFilterParameter, sort?: string, options?: any): AxiosPromise<UnitListApplicationsResponse> {
            return localVarFp.getApplicationsList(page, filter, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get List ATM Locations from API 
         * @summary Get List of ATM Locations
         * @param {GetAtmLocationsListFilterParameter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAtmLocationsList(filter?: GetAtmLocationsListFilterParameter, options?: any): AxiosPromise<Array<AtmLocation>> {
            return localVarFp.getAtmLocationsList(filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Authorization from API 
         * @summary Get Authorization by Id
         * @param {string} authorizationId ID of the authorization to get
         * @param {boolean} [includeNoneAuthorized] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorization(authorizationId: string, includeNoneAuthorized?: boolean, options?: any): AxiosPromise<UnitAuthorizationResponse> {
            return localVarFp.getAuthorization(authorizationId, includeNoneAuthorized, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Authorization Request from API 
         * @summary Get Authorization Request by Id
         * @param {string} authorizationId ID of the authorization request to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorizationRequest(authorizationId: string, options?: any): AxiosPromise<UnitAuthorizationRequestsResponse> {
            return localVarFp.getAuthorizationRequest(authorizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get List Authorization Requests from API 
         * @summary Get List Authorization Requests
         * @param {ListPageParameters} [page] 
         * @param {GetAuthorizationRequestsListFilterParameter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorizationRequestsList(page?: ListPageParameters, filter?: GetAuthorizationRequestsListFilterParameter, options?: any): AxiosPromise<UnitListAuthorizationRequestsResponse> {
            return localVarFp.getAuthorizationRequestsList(page, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Get List Authorizations from API 
         * @summary Get List authorizations
         * @param {ListPageParameters} [page] 
         * @param {GetAuthorizationsListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorizationsList(page?: ListPageParameters, filter?: GetAuthorizationsListFilterParameter, sort?: string, options?: any): AxiosPromise<UnitListAuthorizationsResponse> {
            return localVarFp.getAuthorizationsList(page, filter, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Back Check Deposit Image from API 
         * @summary Get Back Check Deposit Image by Id
         * @param {string} checkDepositId ID of the check deposit to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackCheckDeposit(checkDepositId: string, options?: any): AxiosPromise<UnitBackCheckDepositResponse> {
            return localVarFp.getBackCheckDeposit(checkDepositId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Card from API 
         * @summary Get Card by Id
         * @param {string} cardId ID of the card to get
         * @param {string} [included] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCard(cardId: string, included?: string, options?: any): AxiosPromise<UnitCardResponse> {
            return localVarFp.getCard(cardId, included, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Card Limits from API 
         * @summary Get Card Limit by Id
         * @param {string} cardId ID of the card to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardLimits(cardId: string, options?: any): AxiosPromise<UnitCardLimitsResponse> {
            return localVarFp.getCardLimits(cardId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Card PIN Status via API 
         * @summary Get Card PIN Status
         * @param {string} cardId ID of the card to get PIN status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardPinStatus(cardId: string, options?: any): AxiosPromise<UnitPinStatusResponse> {
            return localVarFp.getCardPinStatus(cardId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get List of Cards from API 
         * @summary Get List of Cards
         * @param {ListPageParameters} [page] 
         * @param {GetCardsListFilterParameter} [filter] 
         * @param {string} [include] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsList(page?: ListPageParameters, filter?: GetCardsListFilterParameter, include?: string, sort?: string, options?: any): AxiosPromise<UnitCardResponseCardsList> {
            return localVarFp.getCardsList(page, filter, include, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Check Deposit from API 
         * @summary Get Check Deposit by Id
         * @param {string} checkDepositId ID of the check deposit to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckDeposit(checkDepositId: string, options?: any): AxiosPromise<UnitCheckDepositResponse> {
            return localVarFp.getCheckDeposit(checkDepositId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get List Check Deposits from API 
         * @summary Get List Check Deposits
         * @param {ListPageParameters} [page] 
         * @param {GetCheckDepositsListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckDepositsList(page?: ListPageParameters, filter?: GetCheckDepositsListFilterParameter, sort?: string, include?: string, options?: any): AxiosPromise<UnitListCheckDepositsResponse> {
            return localVarFp.getCheckDepositsList(page, filter, sort, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Check Payment from API 
         * @summary Get Check Payment by Id
         * @param {string} checkPaymentId ID of the check payment to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckPayment(checkPaymentId: string, options?: any): AxiosPromise<UnitCheckPaymentResponse> {
            return localVarFp.getCheckPayment(checkPaymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get back image via API 
         * @summary Get back image
         * @param {string} checkPaymentId ID of the check payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckPaymentBack(checkPaymentId: string, options?: any): AxiosPromise<File> {
            return localVarFp.getCheckPaymentBack(checkPaymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get front image via API 
         * @summary Get front image
         * @param {string} checkPaymentId ID of the check payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckPaymentFront(checkPaymentId: string, options?: any): AxiosPromise<File> {
            return localVarFp.getCheckPaymentFront(checkPaymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get List Check Payments from API 
         * @summary Get List Check Payments
         * @param {ListPageParameters} [page] 
         * @param {GetCheckPaymentsListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckPaymentsList(page?: ListPageParameters, filter?: GetCheckPaymentsListFilterParameter, sort?: string, include?: string, options?: any): AxiosPromise<UnitListCheckPaymentsResponse> {
            return localVarFp.getCheckPaymentsList(page, filter, sort, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Counterparties List from API 
         * @summary Get Counterparties List
         * @param {ListPageParameters} [page] 
         * @param {GetCounterpartiesListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCounterpartiesList(page?: ListPageParameters, filter?: GetCounterpartiesListFilterParameter, sort?: string, options?: any): AxiosPromise<UnitCounterpartiesListResponse> {
            return localVarFp.getCounterpartiesList(page, filter, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Counterparty from API 
         * @summary Get Counterparty by Id
         * @param {string} counterpartyId ID of the counterparty to get
         * @param {string} [included] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCounterparty(counterpartyId: string, included?: string, options?: any): AxiosPromise<UnitCounterpartyResponse> {
            return localVarFp.getCounterparty(counterpartyId, included, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Recurring Payment from API 
         * @summary Get Counterparty Balance
         * @param {string} counterpartyId ID of the counterparty to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCounterpartyBalance(counterpartyId: string, options?: any): AxiosPromise<UnitCounterpartyResponse1> {
            return localVarFp.getCounterpartyBalance(counterpartyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Customer from API 
         * @summary Get Customer by Id
         * @param {string} customerId ID of the customer to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer(customerId: string, options?: any): AxiosPromise<UnitCustomerResponse> {
            return localVarFp.getCustomer(customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Customers List from API 
         * @summary Get Customers List
         * @param {ListPageParameters} [page] 
         * @param {GetCustomersListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersList(page?: ListPageParameters, filter?: GetCustomersListFilterParameter, sort?: string, options?: any): AxiosPromise<UnitCustomersListResponse> {
            return localVarFp.getCustomersList(page, filter, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Dispute from API 
         * @summary Get Dispute by Id
         * @param {string} disputeId ID of the dispute to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDispute(disputeId: string, options?: any): AxiosPromise<UnitDisputeResponse> {
            return localVarFp.getDispute(disputeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get List Disputes from API 
         * @summary Get List Disputes
         * @param {ListPageParameters} [page] 
         * @param {GetDisputesListFilterParameter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisputesList(page?: ListPageParameters, filter?: GetDisputesListFilterParameter, options?: any): AxiosPromise<Array<Dispute>> {
            return localVarFp.getDisputesList(page, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an Event from API 
         * @summary Get Event by Id
         * @param {string} eventId ID of the event to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent(eventId: string, options?: any): AxiosPromise<UnitEventResponse> {
            return localVarFp.getEvent(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Events List from API 
         * @summary Get Events List
         * @param {ListPageParameters} [page] 
         * @param {GetEventsListFilterParameter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsList(page?: ListPageParameters, filter?: GetEventsListFilterParameter, options?: any): AxiosPromise<UnitEventListResponse> {
            return localVarFp.getEventsList(page, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Front Check Deposit Image from API 
         * @summary Get Front Check Deposit Image by Id
         * @param {string} checkDepositId ID of the check deposit to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFrontCheckDeposit(checkDepositId: string, options?: any): AxiosPromise<UnitFrontCheckDepositResponse> {
            return localVarFp.getFrontCheckDeposit(checkDepositId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an Institution from API 
         * @summary Get Institution by Routing Number
         * @param {string} routingNumber routingNumber of the institution to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstitution(routingNumber: string, options?: any): AxiosPromise<UnitInstitutionResponse> {
            return localVarFp.getInstitution(routingNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Rewards List from API 
         * @summary Get Rewards List
         * @param {ListPageParameters} [page] 
         * @param {GetListRewardsFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListRewards(page?: ListPageParameters, filter?: GetListRewardsFilterParameter, sort?: string, include?: string, options?: any): AxiosPromise<UnitRewardsListResponse> {
            return localVarFp.getListRewards(page, filter, sort, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Payment from API 
         * @summary Get Payment by Id
         * @param {string} paymentId ID of the payment to get
         * @param {string} [included] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment(paymentId: string, included?: string, options?: any): AxiosPromise<UnitPaymentResponseWithIncluded> {
            return localVarFp.getPayment(paymentId, included, options).then((request) => request(axios, basePath));
        },
        /**
         * Get List Payments from API 
         * @summary Get List Payments
         * @param {ListPageParameters} [page] 
         * @param {GetPaymentsListFilterParameter} [filter] 
         * @param {string} [include] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsList(page?: ListPageParameters, filter?: GetPaymentsListFilterParameter, include?: string, sort?: string, options?: any): AxiosPromise<UnitPaymentsListResponse> {
            return localVarFp.getPaymentsList(page, filter, include, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Received Payment from API 
         * @summary Get Received Payment by Id
         * @param {string} paymentId ID of the payment to get
         * @param {string} [included] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReceivedPayment(paymentId: string, included?: string, options?: any): AxiosPromise<UnitReceivedPaymentResponseWithIncluded> {
            return localVarFp.getReceivedPayment(paymentId, included, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Received Payments from API 
         * @summary Get Received Payments List
         * @param {string} [included] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReceivedPaymentsList(included?: string, options?: any): AxiosPromise<UnitReceivedPaymentListResponse> {
            return localVarFp.getReceivedPaymentsList(included, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Recurring Payment from API 
         * @summary Get Recurring Payment
         * @param {string} paymentId ID of the payment to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecurringPayment(paymentId: string, options?: any): AxiosPromise<UnitRecurringPaymentResponse> {
            return localVarFp.getRecurringPayment(paymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Recurring Payments List from API 
         * @summary Get Recurring Payments List
         * @param {ListPageParameters} [page] 
         * @param {GetRecurringPaymentsListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecurringPaymentsList(page?: ListPageParameters, filter?: GetRecurringPaymentsListFilterParameter, sort?: string, options?: any): AxiosPromise<UnitRecurringPaymentListResponse> {
            return localVarFp.getRecurringPaymentsList(page, filter, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Recurring Repayment from API 
         * @summary Get Recurring Repayment by Id
         * @param {string} recurringRepaymentId ID of the recurring repayment to get
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecurringRepayment(recurringRepaymentId: string, include?: string, options?: any): AxiosPromise<UnitRecurringRepaymentResponse> {
            return localVarFp.getRecurringRepayment(recurringRepaymentId, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Get List Recurring Repayments from API 
         * @summary Get List Recurring Repayments
         * @param {ListPageParameters} [page] 
         * @param {GetRecurringRepaymentsListFilterParameter} [filter] 
         * @param {GetRecurringRepaymentsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecurringRepaymentsList(page?: ListPageParameters, filter?: GetRecurringRepaymentsListFilterParameter, sort?: GetRecurringRepaymentsListSortEnum, options?: any): AxiosPromise<UnitRecurringRepaymentsListResponse> {
            return localVarFp.getRecurringRepaymentsList(page, filter, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an Repayment from API 
         * @summary Get Repayment by Id
         * @param {string} repaymentId ID of the repayment to get
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepayment(repaymentId: string, include?: string, options?: any): AxiosPromise<UnitRepaymentResponse> {
            return localVarFp.getRepayment(repaymentId, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Get List Repayments from API 
         * @summary Get List Repayments
         * @param {ListPageParameters} [page] 
         * @param {GetRepaymentsListFilterParameter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepaymentsList(page?: ListPageParameters, filter?: GetRepaymentsListFilterParameter, options?: any): AxiosPromise<UnitRepaymentsListResponse> {
            return localVarFp.getRepaymentsList(page, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Reward from API 
         * @summary Get Reward by Id
         * @param {string} rewardId ID of the reward to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReward(rewardId: string, options?: any): AxiosPromise<UnitRewardResponse> {
            return localVarFp.getReward(rewardId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Get Bank verification PDF from API 
         * @summary Get Bank verification PDF
         * @param {string} accountId ID of the account to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatementBankPdf(accountId: string, options?: any): AxiosPromise<File> {
            return localVarFp.getStatementBankPdf(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a HTML Statement from API 
         * @summary Get HTML Statement by Id
         * @param {string} statementId ID of the statement to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatementHtml(statementId: string, options?: any): AxiosPromise<string> {
            return localVarFp.getStatementHtml(statementId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a PDF Statement from API 
         * @summary Get PDF Statement by Id
         * @param {string} statementId ID of the statement to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatementPdf(statementId: string, options?: any): AxiosPromise<File> {
            return localVarFp.getStatementPdf(statementId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get List Statements from API 
         * @summary Get List Statements
         * @param {ListPageParameters} [page] 
         * @param {GetStatementsListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatementsList(page?: ListPageParameters, filter?: GetStatementsListFilterParameter, sort?: string, options?: any): AxiosPromise<UnitStatementsResponse> {
            return localVarFp.getStatementsList(page, filter, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details of a specific stop payment
         * @param {string} stopPaymentId ID of the stop payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStopPayment(stopPaymentId: string, options?: any): AxiosPromise<StopPaymentResponse> {
            return localVarFp.getStopPayment(stopPaymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of stop payments
         * @param {ListPageParameters} [page] 
         * @param {GetStopPaymentsListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStopPaymentsList(page?: ListPageParameters, filter?: GetStopPaymentsListFilterParameter, sort?: string, options?: any): AxiosPromise<StopPaymentListResponse> {
            return localVarFp.getStopPaymentsList(page, filter, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Transaction from API 
         * @summary Get Transaction by Id
         * @param {string} accountId ID of the account to get transaction from
         * @param {string} transactionId ID of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction(accountId: string, transactionId: string, options?: any): AxiosPromise<UnitTransactionResponseWithIncludedResource> {
            return localVarFp.getTransaction(accountId, transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get List Transactions from API 
         * @summary Get List Transactions
         * @param {ListPageParameters} [page] 
         * @param {GetTransactionsListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsList(page?: ListPageParameters, filter?: GetTransactionsListFilterParameter, sort?: string, include?: string, options?: any): AxiosPromise<UnitTransactionsListResponse> {
            return localVarFp.getTransactionsList(page, filter, sort, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Webhook from API 
         * @summary Get Webhook Id
         * @param {string} webhookId ID of the webhook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(webhookId: string, options?: any): AxiosPromise<WebhookResponse> {
            return localVarFp.getWebhook(webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get List Webhooks from API 
         * @summary Get List Webhooks
         * @param {ListPageParameters} [page] 
         * @param {GetWebhooksListFilterParameter} [filter] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooksList(page?: ListPageParameters, filter?: GetWebhooksListFilterParameter, sort?: string, options?: any): AxiosPromise<UnitWebhooksListResponse> {
            return localVarFp.getWebhooksList(page, filter, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Received Payment via API 
         * @summary Update Received Payment
         * @param {string} paymentId ID of the payment to update
         * @param {UpdateReceivedPaymentRequest} updateReceivedPaymentRequest Update Received Payment Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receivedPaymentsPaymentIdPatch(paymentId: string, updateReceivedPaymentRequest: UpdateReceivedPaymentRequest, options?: any): AxiosPromise<UnitReceivedPaymentResponse> {
            return localVarFp.receivedPaymentsPaymentIdPatch(paymentId, updateReceivedPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove Authorized Users via API
         * @summary Remove Authorized Users by Id
         * @param {string} customerId ID of the customer to remove authorized users from
         * @param {RemoveAuthorizedUsersRequest} removeAuthorizedUsersRequest Add Authorized Users Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAuthorizedUsers(customerId: string, removeAuthorizedUsersRequest: RemoveAuthorizedUsersRequest, options?: any): AxiosPromise<UnitCustomerResponse> {
            return localVarFp.removeAuthorizedUsers(customerId, removeAuthorizedUsersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Reopen an Account via API 
         * @summary Reopen an Account by Id
         * @param {string} accountId ID of the account to close
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reopenAccount(accountId: string, options?: any): AxiosPromise<UnitAccountResponse> {
            return localVarFp.reopenAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Report lost as stolen via API 
         * @summary Report lost as stolen
         * @param {string} cardId ID of the card
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportCardAsLost(cardId: string, options?: any): AxiosPromise<UnitReportLostCardResponse> {
            return localVarFp.reportCardAsLost(cardId, options).then((request) => request(axios, basePath));
        },
        /**
         * Report card as stolen via API 
         * @summary Report card as stolen
         * @param {string} cardId ID of the card
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportCardAsStolen(cardId: string, options?: any): AxiosPromise<UnitReportStolenCardResponse> {
            return localVarFp.reportCardAsStolen(cardId, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a Check Payment via API 
         * @summary Return Check Payment by Id
         * @param {string} checkPaymentId ID of the check payment to return
         * @param {ReturnCheckPaymentRequest} returnCheckPaymentRequest Return Check Payment Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnCheckPayment(checkPaymentId: string, returnCheckPaymentRequest: ReturnCheckPaymentRequest, options?: any): AxiosPromise<UnitCheckPaymentResponse> {
            return localVarFp.returnCheckPayment(checkPaymentId, returnCheckPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Unfreeze an Account via API 
         * @summary Unfreeze Account by Id
         * @param {string} accountId ID of the account to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfreezeAccount(accountId: string, options?: any): AxiosPromise<UnitAccountResponse> {
            return localVarFp.unfreezeAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Unfreeze a Card via API 
         * @summary Unfreeze a Card
         * @param {string} cardId ID of the card to unfreeze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfreezeCard(cardId: string, options?: any): AxiosPromise<UnitUnfreezeCardResponse> {
            return localVarFp.unfreezeCard(cardId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an Account via API 
         * @summary Update Account
         * @param {string} accountId ID of the account to update
         * @param {UpdateAccountRequest} updateAccountRequest Update Account Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(accountId: string, updateAccountRequest: UpdateAccountRequest, options?: any): AxiosPromise<UnitAccountResponse> {
            return localVarFp.updateAccount(accountId, updateAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an Application via API 
         * @summary Update Application
         * @param {string} applicationId ID of the application to update
         * @param {UpdateApplicationRequest} updateApplicationRequest Update Application Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplication(applicationId: string, updateApplicationRequest: UpdateApplicationRequest, options?: any): AxiosPromise<UnitApplicationResponseWithIncluded> {
            return localVarFp.updateApplication(applicationId, updateApplicationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Business Beneficial Owner
         * @summary Update a Business Beneficial Owner via API
         * @param {string} beneficialOwnerId ID of the beneficial owner to update
         * @param {UpdateBusinessBeneficialOwnerRequest} updateBusinessBeneficialOwnerRequest Update Business Beneficial Owner Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBusinessBeneficialOwner(beneficialOwnerId: string, updateBusinessBeneficialOwnerRequest: UpdateBusinessBeneficialOwnerRequest, options?: any): AxiosPromise<UnitBeneficialOwnerResponse> {
            return localVarFp.updateBusinessBeneficialOwner(beneficialOwnerId, updateBusinessBeneficialOwnerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Card via API 
         * @summary Update Card
         * @param {string} cardId ID of the card to update
         * @param {UpdateCardRequest} updateCardRequest Update Card Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCard(cardId: string, updateCardRequest: UpdateCardRequest, options?: any): AxiosPromise<UnitUpdateCardResponse> {
            return localVarFp.updateCard(cardId, updateCardRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Check Deposit via API 
         * @summary Update Check Deposit
         * @param {string} checkDepositId ID of the check deposit to update
         * @param {UpdateCheckDepositRequest} updateCheckDepositRequest Update Check Deposit Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCheckDeposit(checkDepositId: string, updateCheckDepositRequest: UpdateCheckDepositRequest, options?: any): AxiosPromise<UnitUpdateCheckDepositResponse> {
            return localVarFp.updateCheckDeposit(checkDepositId, updateCheckDepositRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Counterparty via API 
         * @summary Update Counterparty
         * @param {string} counterpartyId ID of the counterparty to update
         * @param {UpdateCounterpartyRequest} updateCounterpartyRequest Update Counterparty Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCounterparty(counterpartyId: string, updateCounterpartyRequest: UpdateCounterpartyRequest, options?: any): AxiosPromise<UnitCounterpartyResponse> {
            return localVarFp.updateCounterparty(counterpartyId, updateCounterpartyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an Customer via API 
         * @summary Update Customer
         * @param {string} customerId ID of the customer to update
         * @param {UpdateCustomerRequest} updateCustomerRequest Update Customer Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomer(customerId: string, updateCustomerRequest: UpdateCustomerRequest, options?: any): AxiosPromise<UnitCustomerResponse> {
            return localVarFp.updateCustomer(customerId, updateCustomerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an Payment via API 
         * @summary Update Payment
         * @param {string} paymentId ID of the payment to update
         * @param {UpdatePaymentRequest} updatePaymentRequest Update Payment Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePayment(paymentId: string, updatePaymentRequest: UpdatePaymentRequest, options?: any): AxiosPromise<UnitPaymentResponse> {
            return localVarFp.updatePayment(paymentId, updatePaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a stop payment
         * @param {string} stopPaymentId ID of the stop payment
         * @param {UpdateStopPaymentRequest} updateStopPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStopPayment(stopPaymentId: string, updateStopPaymentRequest: UpdateStopPaymentRequest, options?: any): AxiosPromise<StopPaymentResponse> {
            return localVarFp.updateStopPayment(stopPaymentId, updateStopPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Transaction via API 
         * @summary Update Transaction
         * @param {string} accountId ID of the account to update transaction from
         * @param {string} transactionId ID of the transaction to update
         * @param {UpdateTransactionRequest} updateTransactionRequest Update Transaction Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction(accountId: string, transactionId: string, updateTransactionRequest: UpdateTransactionRequest, options?: any): AxiosPromise<UnitTransactionResponse> {
            return localVarFp.updateTransaction(accountId, transactionId, updateTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Webhook via API 
         * @summary Update Webhook
         * @param {string} webhookId ID of the Webhook to update
         * @param {UpdateWebhookRequest} updateWebhookRequest Update Webhook Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(webhookId: string, updateWebhookRequest: UpdateWebhookRequest, options?: any): AxiosPromise<WebhookResponse> {
            return localVarFp.updateWebhook(webhookId, updateWebhookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload an application document file. Supports PDF, PNG and JPG files
         * @param {string} applicationId ID of the application to upload a file to
         * @param {string} documentId ID of the document to upload a file for
         * @param {File} body An application document file. SDK only temporarily supports only ... files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadApplicationDocumentFile(applicationId: string, documentId: string, body: File, options?: any): AxiosPromise<UnitDocumentResponse> {
            return localVarFp.uploadApplicationDocumentFile(applicationId, documentId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload an application file via API - Back Side. Supports PDF, PNG and JPG files
         * @summary Upload an application document file - Back Side. Supports PDF, PNG and JPG files
         * @param {string} applicationId ID of the application to upload a file to
         * @param {string} documentId ID of the document to upload a file for
         * @param {object} body Upload an application document file - Back Side. Supports PDF, PNG and JPG files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadApplicationDocumentFileBackSide(applicationId: string, documentId: string, body: object, options?: any): AxiosPromise<UnitDocumentResponse> {
            return localVarFp.uploadApplicationDocumentFileBackSide(applicationId, documentId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify a document via API 
         * @summary Verify a document
         * @param {string} applicationId ID of the application to verify a file for
         * @param {string} documentId ID of the document to verify
         * @param {VerifyDocument} verifyDocument Verify Document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyApplicationDocument(applicationId: string, documentId: string, verifyDocument: VerifyDocument, options?: any): AxiosPromise<UnitDocumentResponse> {
            return localVarFp.verifyApplicationDocument(applicationId, documentId, verifyDocument, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UnitApi - object-oriented interface
 * @export
 * @class UnitApi
 * @extends {BaseAPI}
 */
export class UnitApi extends BaseAPI {
    /**
     * Activate Control Agreement for Account via API 
     * @summary Activate Account Control Agreement by Id
     * @param {string} accountId ID of the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public activateControlAgreementForAccount(accountId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).activateControlAgreementForAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add Authorized Users via API
     * @summary Add Authorized Users by Id
     * @param {string} customerId ID of the customer to add authorized users to
     * @param {AddAuthorizedUsersRequest} addAuthorizedUsersRequest Add Authorized Users Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public addAuthorizedUsers(customerId: string, addAuthorizedUsersRequest: AddAuthorizedUsersRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).addAuthorizedUsers(customerId, addAuthorizedUsersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Advance a Received Payment via API 
     * @summary Advance Received Payment by Id
     * @param {string} paymentId ID of the payment to advance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public advanceReceivedPayment(paymentId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).advanceReceivedPayment(paymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Approve a Authorization Request via API 
     * @summary Approve Authorization Request by Id
     * @param {string} authorizationId ID of the authorization request to approve
     * @param {ApproveAuthorizationRequest} approveAuthorizationRequest Approve Authorization Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public approveAuthorizationRequest(authorizationId: string, approveAuthorizationRequest: ApproveAuthorizationRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).approveAuthorizationRequest(authorizationId, approveAuthorizationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Approve a Check Payment via API 
     * @summary Approve Check Payment by Id
     * @param {string} checkPaymentId ID of the check payment to approve
     * @param {ApproveCheckPaymentRequest} approveCheckPaymentRequest Approve Check Payment Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public approveCheckPayment(checkPaymentId: string, approveCheckPaymentRequest: ApproveCheckPaymentRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).approveCheckPayment(checkPaymentId, approveCheckPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Archive a Customer via API 
     * @summary Archive Customer by Id
     * @param {string} customerId ID of the customer to archive
     * @param {ArchiveCustomerRequest} archiveCustomerRequest Archive Customer Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public archiveCustomer(customerId: string, archiveCustomerRequest: ArchiveCustomerRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).archiveCustomer(customerId, archiveCustomerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel a Application via API 
     * @summary Cancel Application by Id
     * @param {string} applicationId ID of the application to get
     * @param {CancelApplicationRequest} cancelApplicationRequest Cancel Application Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public cancelApplication(applicationId: string, cancelApplicationRequest: CancelApplicationRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).cancelApplication(applicationId, cancelApplicationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel a Check Payment via API 
     * @summary Cancel Check Payment by Id
     * @param {string} checkPaymentId ID of the check payment to cancel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public cancelCheckPayment(checkPaymentId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).cancelCheckPayment(checkPaymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel a Payment via API 
     * @summary Cancel a Payment by Id
     * @param {string} paymentId ID of the payment to cancel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public cancelPayment(paymentId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).cancelPayment(paymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Close an Account via API 
     * @summary Close an Account by Id
     * @param {string} accountId ID of the account to close
     * @param {CloseAccountRequest} closeAccountRequest Close Account Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public closeAccount(accountId: string, closeAccountRequest: CloseAccountRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).closeAccount(accountId, closeAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Close a Card via API 
     * @summary Close a Card
     * @param {string} cardId ID of the card to close
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public closeCard(cardId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).closeCard(cardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Confirm a Check Deposit from API 
     * @summary Confirm by Id
     * @param {string} checkDepositId ID of the check deposit to confirm
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public confirmCheckDeposit(checkDepositId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).confirmCheckDeposit(checkDepositId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create Account via API 
     * @summary Create Account
     * @param {CreateAccountRequest} createAccountRequest Create Account Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public createAccount(createAccountRequest: CreateAccountRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).createAccount(createAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an Org API Token via API 
     * @summary Create Org API Token
     * @param {string} userId ID of the user to create token for
     * @param {CreateApiTokenRequest} createApiTokenRequest Create Org API Token Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public createApiToken(userId: string, createApiTokenRequest: CreateApiTokenRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).createApiToken(userId, createApiTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an Application via API 
     * @summary Create Application
     * @param {CreateApplicationRequest} createApplicationRequest Create Application Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public createApplication(createApplicationRequest: CreateApplicationRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).createApplication(createApplicationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an application document via API
     * @summary Create an application document
     * @param {string} applicationId ID of the application to create a file for
     * @param {DefaultContentType} contentType A workaround to properly assign the content type for the request body while providing no body, just set the one possible enum value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public createApplicationDocument(applicationId: string, contentType: DefaultContentType, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).createApplicationDocument(applicationId, contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an Application Form via API 
     * @summary Create Application Form
     * @param {CreateApplicationFormRequest} createApplicationFormRequest Create Application Form Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public createApplicationForm(createApplicationFormRequest: CreateApplicationFormRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).createApplicationForm(createApplicationFormRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a Card via API 
     * @summary Create a Card
     * @param {CreateCardRequest} createCardRequest Create Card Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public createCard(createCardRequest: CreateCardRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).createCard(createCardRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a Check Deposit via API 
     * @summary Create Check Deposit
     * @param {CreateCheckDepositRequest} createCheckDepositRequest Create Check Deposit Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public createCheckDeposit(createCheckDepositRequest: CreateCheckDepositRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).createCheckDeposit(createCheckDepositRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create Check Payment via API 
     * @summary Create Check Payment
     * @param {CreateCheckPaymentRequest} createCheckPaymentRequest Create Check Payment Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public createCheckPayment(createCheckPaymentRequest: CreateCheckPaymentRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).createCheckPayment(createCheckPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a counterparty via API 
     * @summary Create Counterparty
     * @param {CreateCounterpartyRequest} createCounterpartyRequest Create Counterparty Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public createCounterparty(createCounterpartyRequest: CreateCounterpartyRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).createCounterparty(createCounterpartyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a Customer Token via API 
     * @summary Create Customer Token
     * @param {string} customerId ID of the customer to create token for
     * @param {CreateCustomerTokenRequest} createCustomerTokenRequest Create Customer Token Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public createCustomerToken(customerId: string, createCustomerTokenRequest: CreateCustomerTokenRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).createCustomerToken(customerId, createCustomerTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a Customer Token Verification via API 
     * @summary Create Customer Token Verification
     * @param {string} customerId ID of the customer to create token for
     * @param {CreateCustomerTokenVerificationRequest} createCustomerTokenVerificationRequest Create Customer Token Verification Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public createCustomerTokenVerification(customerId: string, createCustomerTokenVerificationRequest: CreateCustomerTokenVerificationRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).createCustomerTokenVerification(customerId, createCustomerTokenVerificationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a Fee via API 
     * @summary Create Fee
     * @param {CreateFeeRequest} createFeeRequest Create Fee Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public createFee(createFeeRequest: CreateFeeRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).createFee(createFeeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a Payment via API 
     * @summary Create a Payment
     * @param {CreatePaymentRequest} createPaymentRequest Create Payment Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public createPayment(createPaymentRequest: CreatePaymentRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).createPayment(createPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a Recurring Payment via API 
     * @summary Create Recurring Payment
     * @param {CreateRecurringPaymentRequest} createRecurringPaymentRequest Create Recurring Payment Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public createRecurringPayment(createRecurringPaymentRequest: CreateRecurringPaymentRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).createRecurringPayment(createRecurringPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a Recurring Repayment via API
     * @summary Create a Recurring Repayment
     * @param {CreateRecurringRepaymentRequest} createRecurringRepaymentRequest Create a Recurring Repayment Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public createRecurringRepayment(createRecurringRepaymentRequest: CreateRecurringRepaymentRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).createRecurringRepayment(createRecurringRepaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a Repayment via API 
     * @summary Create a Repayment
     * @param {CreateRepaymentRequest} createRepaymentRequest Create a Repayment Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public createRepayment(createRepaymentRequest: CreateRepaymentRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).createRepayment(createRepaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a Reward via API 
     * @summary Create Reward
     * @param {CreateRewardRequest} createRewardRequest Create Reward Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public createReward(createRewardRequest: CreateRewardRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).createReward(createRewardRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Stop Payment
     * @param {CreateStopPaymentRequest} createStopPaymentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public createStopPayment(createStopPaymentRequest: CreateStopPaymentRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).createStopPayment(createStopPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a Webhook via API 
     * @summary Create Webhook
     * @param {CreateWebhook} createWebhook Create Webhook Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public createWebhook(createWebhook: CreateWebhook, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).createWebhook(createWebhook, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deactivate Control Agreement for Account via API
     * @summary Deactivate Account Control Agreement by Id
     * @param {string} accountId ID of the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public deactivateControlAgreementForAccount(accountId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).deactivateControlAgreementForAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Decline Authorization Request via API 
     * @summary Decline Authorization Request
     * @param {string} authorizationId ID of the authorization request to decline
     * @param {DeclineAuthorizationRequest} declineAuthorizationRequest Decline Authorization Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public declineAuthorizationRequest(authorizationId: string, declineAuthorizationRequest: DeclineAuthorizationRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).declineAuthorizationRequest(authorizationId, declineAuthorizationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Counterparty via API 
     * @summary Delete Counterparty by Id
     * @param {string} counterpartyId ID of the counterparty to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public deleteCounterparty(counterpartyId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).deleteCounterparty(counterpartyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Reward from API 
     * @summary Get Reward by Id
     * @param {string} userId ID of the user to revoke token
     * @param {string} tokenId ID of the token to revoke
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public deleteToken(userId: string, tokenId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).deleteToken(userId, tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disable Recurring Payment via API 
     * @summary Disable Recurring Payment
     * @param {string} paymentId ID of the payment to disable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public disableRecurringPayment(paymentId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).disableRecurringPayment(paymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disable a Recurring Repayment
     * @summary Disable Recurring Repayment by Id
     * @param {string} recurringRepaymentId ID of the recurring repayment to disable
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public disableRecurringRepayment(recurringRepaymentId: string, include?: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).disableRecurringRepayment(recurringRepaymentId, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Disable a stop payment
     * @param {string} stopPaymentId ID of the stop payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public disableStopPayment(stopPaymentId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).disableStopPayment(stopPaymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disable a Webhook via API 
     * @summary Disable a Webhook
     * @param {string} webhookId ID of the webhook to disable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public disableWebhook(webhookId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).disableWebhook(webhookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download a Document - Back Side via API
     * @summary Download a Document - Back Side
     * @param {string} applicationId ID of the application
     * @param {string} documentId ID of the document to download
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public downloadApplicationBackSideDocument(applicationId: string, documentId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).downloadApplicationBackSideDocument(applicationId, documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download a Document via API 
     * @summary Download a Document
     * @param {string} applicationId ID of the application
     * @param {string} documentId ID of the document to download
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public downloadApplicationDocument(applicationId: string, documentId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).downloadApplicationDocument(applicationId, documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable Recurring Payment via API 
     * @summary Enable Recurring Payment
     * @param {string} paymentId ID of the payment to enable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public enableRecurringPayment(paymentId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).enableRecurringPayment(paymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable a Recurring Repayment
     * @summary Enable Recurring Repayment by Id
     * @param {string} recurringRepaymentId ID of the recurring repayment to enable
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public enableRecurringRepayment(recurringRepaymentId: string, include?: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).enableRecurringRepayment(recurringRepaymentId, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable a Webhook via API 
     * @summary Enable Webhook
     * @param {string} webhookId ID of the webhook to enable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public enableWebhook(webhookId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).enableWebhook(webhookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enter Control Agreement for Account via API 
     * @summary Enter Account Control Agreement by Id
     * @param {string} accountId ID of the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public enterControlAgreementForAccount(accountId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).enterControlAgreementForAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fire an Event via API 
     * @summary Fire Event by Id
     * @param {string} eventId ID of the event to fire
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public fireEvent(eventId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).fireEvent(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Freeze Account via API 
     * @summary Freeze Account by Id
     * @param {string} accountId ID of the account to freeze
     * @param {FreezeAccountRequest} freezeAccountRequest Freeze Account Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public freezeAccount(accountId: string, freezeAccountRequest: FreezeAccountRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).freezeAccount(accountId, freezeAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Freeze a Card via API 
     * @summary Freeze a Card
     * @param {string} cardId ID of the card to freeze
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public freezeCard(cardId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).freezeCard(cardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an Account from API 
     * @summary Get Account by Id
     * @param {string} accountId ID of the account to get
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getAccount(accountId: string, include?: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getAccount(accountId, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get AccountEndOfDay List from API 
     * @summary Get AccountEndOfDay List
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getAccountEndOfDay(options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getAccountEndOfDay(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Account Limits from API 
     * @summary Get Account Limits by Id
     * @param {string} accountId ID of the account to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getAccountLimits(accountId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getAccountLimits(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get List Accounts from API 
     * @summary Get List Accounts
     * @param {ListPageParameters} [page] 
     * @param {GetAccountsListFilterParameter} [filter] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getAccountsList(page?: ListPageParameters, filter?: GetAccountsListFilterParameter, include?: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getAccountsList(page, filter, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get List Org API Tokens from API 
     * @summary Get List Org API Tokens
     * @param {string} userId ID of the user to revoke token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getApiTokensList(userId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getApiTokensList(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an Application from API 
     * @summary Get Application by Id
     * @param {string} applicationId ID of the application to get
     * @param {string} [included] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getApplication(applicationId: string, included?: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getApplication(applicationId, included, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get List of Documents via API 
     * @summary Get List of Documents
     * @param {string} applicationId ID of the application to get documents for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getApplicationDocuments(applicationId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getApplicationDocuments(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an Application Form from API 
     * @summary Get ApplicationForm by Id
     * @param {string} applicationFormId ID of the application form to get
     * @param {string} [included] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getApplicationForm(applicationFormId: string, included?: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getApplicationForm(applicationFormId, included, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get List Application Forms from API 
     * @summary Get List Application Forms
     * @param {ListPageParameters} [page] 
     * @param {GetApplicationFormsListFilterParameter} [filter] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getApplicationFormsList(page?: ListPageParameters, filter?: GetApplicationFormsListFilterParameter, sort?: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getApplicationFormsList(page, filter, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get List Applications from API 
     * @summary Get List Application
     * @param {ListPageParameters} [page] 
     * @param {GetApplicationsListFilterParameter} [filter] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getApplicationsList(page?: ListPageParameters, filter?: GetApplicationsListFilterParameter, sort?: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getApplicationsList(page, filter, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get List ATM Locations from API 
     * @summary Get List of ATM Locations
     * @param {GetAtmLocationsListFilterParameter} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getAtmLocationsList(filter?: GetAtmLocationsListFilterParameter, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getAtmLocationsList(filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Authorization from API 
     * @summary Get Authorization by Id
     * @param {string} authorizationId ID of the authorization to get
     * @param {boolean} [includeNoneAuthorized] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getAuthorization(authorizationId: string, includeNoneAuthorized?: boolean, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getAuthorization(authorizationId, includeNoneAuthorized, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Authorization Request from API 
     * @summary Get Authorization Request by Id
     * @param {string} authorizationId ID of the authorization request to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getAuthorizationRequest(authorizationId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getAuthorizationRequest(authorizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get List Authorization Requests from API 
     * @summary Get List Authorization Requests
     * @param {ListPageParameters} [page] 
     * @param {GetAuthorizationRequestsListFilterParameter} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getAuthorizationRequestsList(page?: ListPageParameters, filter?: GetAuthorizationRequestsListFilterParameter, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getAuthorizationRequestsList(page, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get List Authorizations from API 
     * @summary Get List authorizations
     * @param {ListPageParameters} [page] 
     * @param {GetAuthorizationsListFilterParameter} [filter] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getAuthorizationsList(page?: ListPageParameters, filter?: GetAuthorizationsListFilterParameter, sort?: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getAuthorizationsList(page, filter, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Back Check Deposit Image from API 
     * @summary Get Back Check Deposit Image by Id
     * @param {string} checkDepositId ID of the check deposit to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getBackCheckDeposit(checkDepositId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getBackCheckDeposit(checkDepositId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Card from API 
     * @summary Get Card by Id
     * @param {string} cardId ID of the card to get
     * @param {string} [included] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getCard(cardId: string, included?: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getCard(cardId, included, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Card Limits from API 
     * @summary Get Card Limit by Id
     * @param {string} cardId ID of the card to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getCardLimits(cardId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getCardLimits(cardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Card PIN Status via API 
     * @summary Get Card PIN Status
     * @param {string} cardId ID of the card to get PIN status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getCardPinStatus(cardId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getCardPinStatus(cardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get List of Cards from API 
     * @summary Get List of Cards
     * @param {ListPageParameters} [page] 
     * @param {GetCardsListFilterParameter} [filter] 
     * @param {string} [include] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getCardsList(page?: ListPageParameters, filter?: GetCardsListFilterParameter, include?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getCardsList(page, filter, include, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Check Deposit from API 
     * @summary Get Check Deposit by Id
     * @param {string} checkDepositId ID of the check deposit to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getCheckDeposit(checkDepositId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getCheckDeposit(checkDepositId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get List Check Deposits from API 
     * @summary Get List Check Deposits
     * @param {ListPageParameters} [page] 
     * @param {GetCheckDepositsListFilterParameter} [filter] 
     * @param {string} [sort] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getCheckDepositsList(page?: ListPageParameters, filter?: GetCheckDepositsListFilterParameter, sort?: string, include?: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getCheckDepositsList(page, filter, sort, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Check Payment from API 
     * @summary Get Check Payment by Id
     * @param {string} checkPaymentId ID of the check payment to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getCheckPayment(checkPaymentId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getCheckPayment(checkPaymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get back image via API 
     * @summary Get back image
     * @param {string} checkPaymentId ID of the check payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getCheckPaymentBack(checkPaymentId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getCheckPaymentBack(checkPaymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get front image via API 
     * @summary Get front image
     * @param {string} checkPaymentId ID of the check payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getCheckPaymentFront(checkPaymentId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getCheckPaymentFront(checkPaymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get List Check Payments from API 
     * @summary Get List Check Payments
     * @param {ListPageParameters} [page] 
     * @param {GetCheckPaymentsListFilterParameter} [filter] 
     * @param {string} [sort] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getCheckPaymentsList(page?: ListPageParameters, filter?: GetCheckPaymentsListFilterParameter, sort?: string, include?: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getCheckPaymentsList(page, filter, sort, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Counterparties List from API 
     * @summary Get Counterparties List
     * @param {ListPageParameters} [page] 
     * @param {GetCounterpartiesListFilterParameter} [filter] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getCounterpartiesList(page?: ListPageParameters, filter?: GetCounterpartiesListFilterParameter, sort?: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getCounterpartiesList(page, filter, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Counterparty from API 
     * @summary Get Counterparty by Id
     * @param {string} counterpartyId ID of the counterparty to get
     * @param {string} [included] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getCounterparty(counterpartyId: string, included?: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getCounterparty(counterpartyId, included, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Recurring Payment from API 
     * @summary Get Counterparty Balance
     * @param {string} counterpartyId ID of the counterparty to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getCounterpartyBalance(counterpartyId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getCounterpartyBalance(counterpartyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Customer from API 
     * @summary Get Customer by Id
     * @param {string} customerId ID of the customer to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getCustomer(customerId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getCustomer(customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Customers List from API 
     * @summary Get Customers List
     * @param {ListPageParameters} [page] 
     * @param {GetCustomersListFilterParameter} [filter] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getCustomersList(page?: ListPageParameters, filter?: GetCustomersListFilterParameter, sort?: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getCustomersList(page, filter, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Dispute from API 
     * @summary Get Dispute by Id
     * @param {string} disputeId ID of the dispute to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getDispute(disputeId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getDispute(disputeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get List Disputes from API 
     * @summary Get List Disputes
     * @param {ListPageParameters} [page] 
     * @param {GetDisputesListFilterParameter} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getDisputesList(page?: ListPageParameters, filter?: GetDisputesListFilterParameter, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getDisputesList(page, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an Event from API 
     * @summary Get Event by Id
     * @param {string} eventId ID of the event to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getEvent(eventId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getEvent(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Events List from API 
     * @summary Get Events List
     * @param {ListPageParameters} [page] 
     * @param {GetEventsListFilterParameter} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getEventsList(page?: ListPageParameters, filter?: GetEventsListFilterParameter, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getEventsList(page, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Front Check Deposit Image from API 
     * @summary Get Front Check Deposit Image by Id
     * @param {string} checkDepositId ID of the check deposit to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getFrontCheckDeposit(checkDepositId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getFrontCheckDeposit(checkDepositId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an Institution from API 
     * @summary Get Institution by Routing Number
     * @param {string} routingNumber routingNumber of the institution to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getInstitution(routingNumber: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getInstitution(routingNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Rewards List from API 
     * @summary Get Rewards List
     * @param {ListPageParameters} [page] 
     * @param {GetListRewardsFilterParameter} [filter] 
     * @param {string} [sort] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getListRewards(page?: ListPageParameters, filter?: GetListRewardsFilterParameter, sort?: string, include?: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getListRewards(page, filter, sort, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Payment from API 
     * @summary Get Payment by Id
     * @param {string} paymentId ID of the payment to get
     * @param {string} [included] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getPayment(paymentId: string, included?: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getPayment(paymentId, included, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get List Payments from API 
     * @summary Get List Payments
     * @param {ListPageParameters} [page] 
     * @param {GetPaymentsListFilterParameter} [filter] 
     * @param {string} [include] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getPaymentsList(page?: ListPageParameters, filter?: GetPaymentsListFilterParameter, include?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getPaymentsList(page, filter, include, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Received Payment from API 
     * @summary Get Received Payment by Id
     * @param {string} paymentId ID of the payment to get
     * @param {string} [included] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getReceivedPayment(paymentId: string, included?: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getReceivedPayment(paymentId, included, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Received Payments from API 
     * @summary Get Received Payments List
     * @param {string} [included] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getReceivedPaymentsList(included?: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getReceivedPaymentsList(included, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Recurring Payment from API 
     * @summary Get Recurring Payment
     * @param {string} paymentId ID of the payment to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getRecurringPayment(paymentId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getRecurringPayment(paymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Recurring Payments List from API 
     * @summary Get Recurring Payments List
     * @param {ListPageParameters} [page] 
     * @param {GetRecurringPaymentsListFilterParameter} [filter] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getRecurringPaymentsList(page?: ListPageParameters, filter?: GetRecurringPaymentsListFilterParameter, sort?: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getRecurringPaymentsList(page, filter, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Recurring Repayment from API 
     * @summary Get Recurring Repayment by Id
     * @param {string} recurringRepaymentId ID of the recurring repayment to get
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getRecurringRepayment(recurringRepaymentId: string, include?: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getRecurringRepayment(recurringRepaymentId, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get List Recurring Repayments from API 
     * @summary Get List Recurring Repayments
     * @param {ListPageParameters} [page] 
     * @param {GetRecurringRepaymentsListFilterParameter} [filter] 
     * @param {GetRecurringRepaymentsListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getRecurringRepaymentsList(page?: ListPageParameters, filter?: GetRecurringRepaymentsListFilterParameter, sort?: GetRecurringRepaymentsListSortEnum, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getRecurringRepaymentsList(page, filter, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an Repayment from API 
     * @summary Get Repayment by Id
     * @param {string} repaymentId ID of the repayment to get
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getRepayment(repaymentId: string, include?: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getRepayment(repaymentId, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get List Repayments from API 
     * @summary Get List Repayments
     * @param {ListPageParameters} [page] 
     * @param {GetRepaymentsListFilterParameter} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getRepaymentsList(page?: ListPageParameters, filter?: GetRepaymentsListFilterParameter, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getRepaymentsList(page, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Reward from API 
     * @summary Get Reward by Id
     * @param {string} rewardId ID of the reward to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getReward(rewardId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getReward(rewardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Get Bank verification PDF from API 
     * @summary Get Bank verification PDF
     * @param {string} accountId ID of the account to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getStatementBankPdf(accountId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getStatementBankPdf(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a HTML Statement from API 
     * @summary Get HTML Statement by Id
     * @param {string} statementId ID of the statement to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getStatementHtml(statementId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getStatementHtml(statementId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a PDF Statement from API 
     * @summary Get PDF Statement by Id
     * @param {string} statementId ID of the statement to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getStatementPdf(statementId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getStatementPdf(statementId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get List Statements from API 
     * @summary Get List Statements
     * @param {ListPageParameters} [page] 
     * @param {GetStatementsListFilterParameter} [filter] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getStatementsList(page?: ListPageParameters, filter?: GetStatementsListFilterParameter, sort?: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getStatementsList(page, filter, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details of a specific stop payment
     * @param {string} stopPaymentId ID of the stop payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getStopPayment(stopPaymentId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getStopPayment(stopPaymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of stop payments
     * @param {ListPageParameters} [page] 
     * @param {GetStopPaymentsListFilterParameter} [filter] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getStopPaymentsList(page?: ListPageParameters, filter?: GetStopPaymentsListFilterParameter, sort?: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getStopPaymentsList(page, filter, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Transaction from API 
     * @summary Get Transaction by Id
     * @param {string} accountId ID of the account to get transaction from
     * @param {string} transactionId ID of the transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getTransaction(accountId: string, transactionId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getTransaction(accountId, transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get List Transactions from API 
     * @summary Get List Transactions
     * @param {ListPageParameters} [page] 
     * @param {GetTransactionsListFilterParameter} [filter] 
     * @param {string} [sort] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getTransactionsList(page?: ListPageParameters, filter?: GetTransactionsListFilterParameter, sort?: string, include?: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getTransactionsList(page, filter, sort, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Webhook from API 
     * @summary Get Webhook Id
     * @param {string} webhookId ID of the webhook to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getWebhook(webhookId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getWebhook(webhookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get List Webhooks from API 
     * @summary Get List Webhooks
     * @param {ListPageParameters} [page] 
     * @param {GetWebhooksListFilterParameter} [filter] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public getWebhooksList(page?: ListPageParameters, filter?: GetWebhooksListFilterParameter, sort?: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getWebhooksList(page, filter, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Received Payment via API 
     * @summary Update Received Payment
     * @param {string} paymentId ID of the payment to update
     * @param {UpdateReceivedPaymentRequest} updateReceivedPaymentRequest Update Received Payment Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public receivedPaymentsPaymentIdPatch(paymentId: string, updateReceivedPaymentRequest: UpdateReceivedPaymentRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).receivedPaymentsPaymentIdPatch(paymentId, updateReceivedPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove Authorized Users via API
     * @summary Remove Authorized Users by Id
     * @param {string} customerId ID of the customer to remove authorized users from
     * @param {RemoveAuthorizedUsersRequest} removeAuthorizedUsersRequest Add Authorized Users Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public removeAuthorizedUsers(customerId: string, removeAuthorizedUsersRequest: RemoveAuthorizedUsersRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).removeAuthorizedUsers(customerId, removeAuthorizedUsersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reopen an Account via API 
     * @summary Reopen an Account by Id
     * @param {string} accountId ID of the account to close
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public reopenAccount(accountId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).reopenAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Report lost as stolen via API 
     * @summary Report lost as stolen
     * @param {string} cardId ID of the card
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public reportCardAsLost(cardId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).reportCardAsLost(cardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Report card as stolen via API 
     * @summary Report card as stolen
     * @param {string} cardId ID of the card
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public reportCardAsStolen(cardId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).reportCardAsStolen(cardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a Check Payment via API 
     * @summary Return Check Payment by Id
     * @param {string} checkPaymentId ID of the check payment to return
     * @param {ReturnCheckPaymentRequest} returnCheckPaymentRequest Return Check Payment Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public returnCheckPayment(checkPaymentId: string, returnCheckPaymentRequest: ReturnCheckPaymentRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).returnCheckPayment(checkPaymentId, returnCheckPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unfreeze an Account via API 
     * @summary Unfreeze Account by Id
     * @param {string} accountId ID of the account to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public unfreezeAccount(accountId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).unfreezeAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unfreeze a Card via API 
     * @summary Unfreeze a Card
     * @param {string} cardId ID of the card to unfreeze
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public unfreezeCard(cardId: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).unfreezeCard(cardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an Account via API 
     * @summary Update Account
     * @param {string} accountId ID of the account to update
     * @param {UpdateAccountRequest} updateAccountRequest Update Account Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public updateAccount(accountId: string, updateAccountRequest: UpdateAccountRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).updateAccount(accountId, updateAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an Application via API 
     * @summary Update Application
     * @param {string} applicationId ID of the application to update
     * @param {UpdateApplicationRequest} updateApplicationRequest Update Application Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public updateApplication(applicationId: string, updateApplicationRequest: UpdateApplicationRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).updateApplication(applicationId, updateApplicationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Business Beneficial Owner
     * @summary Update a Business Beneficial Owner via API
     * @param {string} beneficialOwnerId ID of the beneficial owner to update
     * @param {UpdateBusinessBeneficialOwnerRequest} updateBusinessBeneficialOwnerRequest Update Business Beneficial Owner Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public updateBusinessBeneficialOwner(beneficialOwnerId: string, updateBusinessBeneficialOwnerRequest: UpdateBusinessBeneficialOwnerRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).updateBusinessBeneficialOwner(beneficialOwnerId, updateBusinessBeneficialOwnerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Card via API 
     * @summary Update Card
     * @param {string} cardId ID of the card to update
     * @param {UpdateCardRequest} updateCardRequest Update Card Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public updateCard(cardId: string, updateCardRequest: UpdateCardRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).updateCard(cardId, updateCardRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Check Deposit via API 
     * @summary Update Check Deposit
     * @param {string} checkDepositId ID of the check deposit to update
     * @param {UpdateCheckDepositRequest} updateCheckDepositRequest Update Check Deposit Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public updateCheckDeposit(checkDepositId: string, updateCheckDepositRequest: UpdateCheckDepositRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).updateCheckDeposit(checkDepositId, updateCheckDepositRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Counterparty via API 
     * @summary Update Counterparty
     * @param {string} counterpartyId ID of the counterparty to update
     * @param {UpdateCounterpartyRequest} updateCounterpartyRequest Update Counterparty Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public updateCounterparty(counterpartyId: string, updateCounterpartyRequest: UpdateCounterpartyRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).updateCounterparty(counterpartyId, updateCounterpartyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an Customer via API 
     * @summary Update Customer
     * @param {string} customerId ID of the customer to update
     * @param {UpdateCustomerRequest} updateCustomerRequest Update Customer Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public updateCustomer(customerId: string, updateCustomerRequest: UpdateCustomerRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).updateCustomer(customerId, updateCustomerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an Payment via API 
     * @summary Update Payment
     * @param {string} paymentId ID of the payment to update
     * @param {UpdatePaymentRequest} updatePaymentRequest Update Payment Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public updatePayment(paymentId: string, updatePaymentRequest: UpdatePaymentRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).updatePayment(paymentId, updatePaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a stop payment
     * @param {string} stopPaymentId ID of the stop payment
     * @param {UpdateStopPaymentRequest} updateStopPaymentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public updateStopPayment(stopPaymentId: string, updateStopPaymentRequest: UpdateStopPaymentRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).updateStopPayment(stopPaymentId, updateStopPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Transaction via API 
     * @summary Update Transaction
     * @param {string} accountId ID of the account to update transaction from
     * @param {string} transactionId ID of the transaction to update
     * @param {UpdateTransactionRequest} updateTransactionRequest Update Transaction Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public updateTransaction(accountId: string, transactionId: string, updateTransactionRequest: UpdateTransactionRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).updateTransaction(accountId, transactionId, updateTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Webhook via API 
     * @summary Update Webhook
     * @param {string} webhookId ID of the Webhook to update
     * @param {UpdateWebhookRequest} updateWebhookRequest Update Webhook Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public updateWebhook(webhookId: string, updateWebhookRequest: UpdateWebhookRequest, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).updateWebhook(webhookId, updateWebhookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload an application document file. Supports PDF, PNG and JPG files
     * @param {string} applicationId ID of the application to upload a file to
     * @param {string} documentId ID of the document to upload a file for
     * @param {File} body An application document file. SDK only temporarily supports only ... files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public uploadApplicationDocumentFile(applicationId: string, documentId: string, body: File, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).uploadApplicationDocumentFile(applicationId, documentId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload an application file via API - Back Side. Supports PDF, PNG and JPG files
     * @summary Upload an application document file - Back Side. Supports PDF, PNG and JPG files
     * @param {string} applicationId ID of the application to upload a file to
     * @param {string} documentId ID of the document to upload a file for
     * @param {object} body Upload an application document file - Back Side. Supports PDF, PNG and JPG files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public uploadApplicationDocumentFileBackSide(applicationId: string, documentId: string, body: object, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).uploadApplicationDocumentFileBackSide(applicationId, documentId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify a document via API 
     * @summary Verify a document
     * @param {string} applicationId ID of the application to verify a file for
     * @param {string} documentId ID of the document to verify
     * @param {VerifyDocument} verifyDocument Verify Document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitApi
     */
    public verifyApplicationDocument(applicationId: string, documentId: string, verifyDocument: VerifyDocument, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).verifyApplicationDocument(applicationId, documentId, verifyDocument, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetRecurringRepaymentsListSortEnum = {
    CreatedAt: 'createdAt',
    CreatedAt2: '-createdAt'
} as const;
export type GetRecurringRepaymentsListSortEnum = typeof GetRecurringRepaymentsListSortEnum[keyof typeof GetRecurringRepaymentsListSortEnum];


